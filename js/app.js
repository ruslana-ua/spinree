(() => {
    var __webpack_modules__ = {
        20: (__unused_webpack_module, exports, __webpack_require__) => {
            "use strict";
            /**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */            var f = __webpack_require__(540), k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = {
                key: !0,
                ref: !0,
                __self: !0,
                __source: !0
            };
            function q(c, a, g) {
                var b, d = {}, e = null, h = null;
                void 0 !== g && (e = "" + g);
                void 0 !== a.key && (e = "" + a.key);
                void 0 !== a.ref && (h = a.ref);
                for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
                if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
                return {
                    $$typeof: k,
                    type: c,
                    key: e,
                    ref: h,
                    props: d,
                    _owner: n.current
                };
            }
            exports.Fragment = l;
            exports.jsx = q;
            exports.jsxs = q;
        },
        69: (__unused_webpack_module, exports) => {
            "use strict";
            0;
            0;
            0;
            const cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
            const cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
            const domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
            const pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
            const __toString = Object.prototype.toString;
            const NullObject = (() => {
                const C = function() {};
                C.prototype = Object.create(null);
                return C;
            })();
            function parse(str, options) {
                const obj = new NullObject;
                const len = str.length;
                if (len < 2) return obj;
                const dec = options?.decode || decode;
                let index = 0;
                do {
                    const eqIdx = str.indexOf("=", index);
                    if (eqIdx === -1) break;
                    const colonIdx = str.indexOf(";", index);
                    const endIdx = colonIdx === -1 ? len : colonIdx;
                    if (eqIdx > endIdx) {
                        str.lastIndexOf(";", eqIdx - 1) + 1;
                        continue;
                    }
                    const keyStartIdx = startIndex(str, index, eqIdx);
                    const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
                    const key = str.slice(keyStartIdx, keyEndIdx);
                    if (obj[key] === void 0) {
                        let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
                        let valEndIdx = endIndex(str, endIdx, valStartIdx);
                        const value = dec(str.slice(valStartIdx, valEndIdx));
                        obj[key] = value;
                    }
                    0;
                } while (index < len);
                return obj;
            }
            function startIndex(str, index, max) {
                do {
                    const code = str.charCodeAt(index);
                    if (code !== 32 && code !== 9) return index;
                } while (++index < max);
                return max;
            }
            function endIndex(str, index, min) {
                while (index > min) {
                    const code = str.charCodeAt(--index);
                    if (code !== 32 && code !== 9) return index + 1;
                }
                return min;
            }
            function serialize(name, val, options) {
                const enc = options?.encode || encodeURIComponent;
                if (!cookieNameRegExp.test(name)) throw new TypeError(`argument name is invalid: ${name}`);
                const value = enc(val);
                if (!cookieValueRegExp.test(value)) throw new TypeError(`argument val is invalid: ${val}`);
                let str = name + "=" + value;
                if (!options) return str;
                if (options.maxAge !== void 0) {
                    if (!Number.isInteger(options.maxAge)) throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
                    str += "; Max-Age=" + options.maxAge;
                }
                if (options.domain) {
                    if (!domainValueRegExp.test(options.domain)) throw new TypeError(`option domain is invalid: ${options.domain}`);
                    str += "; Domain=" + options.domain;
                }
                if (options.path) {
                    if (!pathValueRegExp.test(options.path)) throw new TypeError(`option path is invalid: ${options.path}`);
                    str += "; Path=" + options.path;
                }
                if (options.expires) {
                    if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf())) throw new TypeError(`option expires is invalid: ${options.expires}`);
                    str += "; Expires=" + options.expires.toUTCString();
                }
                if (options.httpOnly) str += "; HttpOnly";
                if (options.secure) str += "; Secure";
                if (options.partitioned) str += "; Partitioned";
                if (options.priority) {
                    const priority = typeof options.priority === "string" ? options.priority.toLowerCase() : void 0;
                    switch (priority) {
                      case "low":
                        str += "; Priority=Low";
                        break;

                      case "medium":
                        str += "; Priority=Medium";
                        break;

                      case "high":
                        str += "; Priority=High";
                        break;

                      default:
                        throw new TypeError(`option priority is invalid: ${options.priority}`);
                    }
                }
                if (options.sameSite) {
                    const sameSite = typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite;
                    switch (sameSite) {
                      case true:
                      case "strict":
                        str += "; SameSite=Strict";
                        break;

                      case "lax":
                        str += "; SameSite=Lax";
                        break;

                      case "none":
                        str += "; SameSite=None";
                        break;

                      default:
                        throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
                    }
                }
                return str;
            }
            function decode(str) {
                if (str.indexOf("%") === -1) return str;
                try {
                    return decodeURIComponent(str);
                } catch (e) {
                    return str;
                }
            }
            function isDate(val) {
                return __toString.call(val) === "[object Date]";
            }
        },
        287: (__unused_webpack_module, exports) => {
            "use strict";
            /**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */            var l = Symbol.for("react.element"), n = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z = Symbol.iterator;
            function A(a) {
                if (null === a || "object" !== typeof a) return null;
                a = z && a[z] || a["@@iterator"];
                return "function" === typeof a ? a : null;
            }
            var B = {
                isMounted: function() {
                    return !1;
                },
                enqueueForceUpdate: function() {},
                enqueueReplaceState: function() {},
                enqueueSetState: function() {}
            }, C = Object.assign, D = {};
            function E(a, b, e) {
                this.props = a;
                this.context = b;
                this.refs = D;
                this.updater = e || B;
            }
            E.prototype.isReactComponent = {};
            E.prototype.setState = function(a, b) {
                if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
                this.updater.enqueueSetState(this, a, b, "setState");
            };
            E.prototype.forceUpdate = function(a) {
                this.updater.enqueueForceUpdate(this, a, "forceUpdate");
            };
            function F() {}
            F.prototype = E.prototype;
            function G(a, b, e) {
                this.props = a;
                this.context = b;
                this.refs = D;
                this.updater = e || B;
            }
            var H = G.prototype = new F;
            H.constructor = G;
            C(H, E.prototype);
            H.isPureReactComponent = !0;
            var I = Array.isArray, J = Object.prototype.hasOwnProperty, K = {
                current: null
            }, L = {
                key: !0,
                ref: !0,
                __self: !0,
                __source: !0
            };
            function M(a, b, e) {
                var d, c = {}, k = null, h = null;
                if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), 
                b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
                var g = arguments.length - 2;
                if (1 === g) c.children = e; else if (1 < g) {
                    for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
                    c.children = f;
                }
                if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
                return {
                    $$typeof: l,
                    type: a,
                    key: k,
                    ref: h,
                    props: c,
                    _owner: K.current
                };
            }
            function N(a, b) {
                return {
                    $$typeof: l,
                    type: a.type,
                    key: b,
                    ref: a.ref,
                    props: a.props,
                    _owner: a._owner
                };
            }
            function O(a) {
                return "object" === typeof a && null !== a && a.$$typeof === l;
            }
            function escape(a) {
                var b = {
                    "=": "=0",
                    ":": "=2"
                };
                return "$" + a.replace(/[=:]/g, function(a) {
                    return b[a];
                });
            }
            var P = /\/+/g;
            function Q(a, b) {
                return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
            }
            function R(a, b, e, d, c) {
                var k = typeof a;
                if ("undefined" === k || "boolean" === k) a = null;
                var h = !1;
                if (null === a) h = !0; else switch (k) {
                  case "string":
                  case "number":
                    h = !0;
                    break;

                  case "object":
                    switch (a.$$typeof) {
                      case l:
                      case n:
                        h = !0;
                    }
                }
                if (h) return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", 
                null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a) {
                    return a;
                })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), 
                b.push(c)), 1;
                h = 0;
                d = "" === d ? "." : d + ":";
                if (I(a)) for (var g = 0; g < a.length; g++) {
                    k = a[g];
                    var f = d + Q(k, g);
                    h += R(k, b, e, f, c);
                } else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done; ) k = k.value, 
                f = d + Q(k, g++), h += R(k, b, e, f, c); else if ("object" === k) throw b = String(a), 
                Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
                return h;
            }
            function S(a, b, e) {
                if (null == a) return a;
                var d = [], c = 0;
                R(a, d, "", "", function(a) {
                    return b.call(e, a, c++);
                });
                return d;
            }
            function T(a) {
                if (-1 === a._status) {
                    var b = a._result;
                    b = b();
                    b.then(function(b) {
                        if (0 === a._status || -1 === a._status) a._status = 1, a._result = b;
                    }, function(b) {
                        if (0 === a._status || -1 === a._status) a._status = 2, a._result = b;
                    });
                    -1 === a._status && (a._status = 0, a._result = b);
                }
                if (1 === a._status) return a._result.default;
                throw a._result;
            }
            var U = {
                current: null
            }, V = {
                transition: null
            }, W = {
                ReactCurrentDispatcher: U,
                ReactCurrentBatchConfig: V,
                ReactCurrentOwner: K
            };
            function X() {
                throw Error("act(...) is not supported in production builds of React.");
            }
            exports.Children = {
                map: S,
                forEach: function(a, b, e) {
                    S(a, function() {
                        b.apply(this, arguments);
                    }, e);
                },
                count: function(a) {
                    var b = 0;
                    S(a, function() {
                        b++;
                    });
                    return b;
                },
                toArray: function(a) {
                    return S(a, function(a) {
                        return a;
                    }) || [];
                },
                only: function(a) {
                    if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
                    return a;
                }
            };
            exports.Component = E;
            exports.Fragment = p;
            exports.Profiler = r;
            exports.PureComponent = G;
            exports.StrictMode = q;
            exports.Suspense = w;
            exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
            exports.act = X;
            exports.cloneElement = function(a, b, e) {
                if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
                var d = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
                if (null != b) {
                    void 0 !== b.ref && (k = b.ref, h = K.current);
                    void 0 !== b.key && (c = "" + b.key);
                    if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
                    for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
                }
                var f = arguments.length - 2;
                if (1 === f) d.children = e; else if (1 < f) {
                    g = Array(f);
                    for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
                    d.children = g;
                }
                return {
                    $$typeof: l,
                    type: a.type,
                    key: c,
                    ref: k,
                    props: d,
                    _owner: h
                };
            };
            exports.createContext = function(a) {
                a = {
                    $$typeof: u,
                    _currentValue: a,
                    _currentValue2: a,
                    _threadCount: 0,
                    Provider: null,
                    Consumer: null,
                    _defaultValue: null,
                    _globalName: null
                };
                a.Provider = {
                    $$typeof: t,
                    _context: a
                };
                return a.Consumer = a;
            };
            exports.createElement = M;
            exports.createFactory = function(a) {
                var b = M.bind(null, a);
                b.type = a;
                return b;
            };
            exports.createRef = function() {
                return {
                    current: null
                };
            };
            exports.forwardRef = function(a) {
                return {
                    $$typeof: v,
                    render: a
                };
            };
            exports.isValidElement = O;
            exports.lazy = function(a) {
                return {
                    $$typeof: y,
                    _payload: {
                        _status: -1,
                        _result: a
                    },
                    _init: T
                };
            };
            exports.memo = function(a, b) {
                return {
                    $$typeof: x,
                    type: a,
                    compare: void 0 === b ? null : b
                };
            };
            exports.startTransition = function(a) {
                var b = V.transition;
                V.transition = {};
                try {
                    a();
                } finally {
                    V.transition = b;
                }
            };
            exports.unstable_act = X;
            exports.useCallback = function(a, b) {
                return U.current.useCallback(a, b);
            };
            exports.useContext = function(a) {
                return U.current.useContext(a);
            };
            exports.useDebugValue = function() {};
            exports.useDeferredValue = function(a) {
                return U.current.useDeferredValue(a);
            };
            exports.useEffect = function(a, b) {
                return U.current.useEffect(a, b);
            };
            exports.useId = function() {
                return U.current.useId();
            };
            exports.useImperativeHandle = function(a, b, e) {
                return U.current.useImperativeHandle(a, b, e);
            };
            exports.useInsertionEffect = function(a, b) {
                return U.current.useInsertionEffect(a, b);
            };
            exports.useLayoutEffect = function(a, b) {
                return U.current.useLayoutEffect(a, b);
            };
            exports.useMemo = function(a, b) {
                return U.current.useMemo(a, b);
            };
            exports.useReducer = function(a, b, e) {
                return U.current.useReducer(a, b, e);
            };
            exports.useRef = function(a) {
                return U.current.useRef(a);
            };
            exports.useState = function(a) {
                return U.current.useState(a);
            };
            exports.useSyncExternalStore = function(a, b, e) {
                return U.current.useSyncExternalStore(a, b, e);
            };
            exports.useTransition = function() {
                return U.current.useTransition();
            };
            exports.version = "18.3.1";
        },
        338: (__unused_webpack_module, exports, __webpack_require__) => {
            "use strict";
            var m = __webpack_require__(961);
            if (true) {
                exports.createRoot = m.createRoot;
                exports.hydrateRoot = m.hydrateRoot;
            } else ;
        },
        463: (__unused_webpack_module, exports) => {
            "use strict";
            /**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */            function f(a, b) {
                var c = a.length;
                a.push(b);
                a: for (;0 < c; ) {
                    var d = c - 1 >>> 1, e = a[d];
                    if (0 < g(e, b)) a[d] = b, a[c] = e, c = d; else break a;
                }
            }
            function h(a) {
                return 0 === a.length ? null : a[0];
            }
            function k(a) {
                if (0 === a.length) return null;
                var b = a[0], c = a.pop();
                if (c !== b) {
                    a[0] = c;
                    a: for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
                        var m = 2 * (d + 1) - 1, C = a[m], n = m + 1, x = a[n];
                        if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, 
                        a[m] = c, d = m); else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n; else break a;
                    }
                }
                return b;
            }
            function g(a, b) {
                var c = a.sortIndex - b.sortIndex;
                return 0 !== c ? c : a.id - b.id;
            }
            if ("object" === typeof performance && "function" === typeof performance.now) {
                var l = performance;
                exports.unstable_now = function() {
                    return l.now();
                };
            } else {
                var p = Date, q = p.now();
                exports.unstable_now = function() {
                    return p.now() - q;
                };
            }
            var r = [], t = [], u = 1, v = null, y = 3, z = !1, A = !1, B = !1, D = "function" === typeof setTimeout ? setTimeout : null, E = "function" === typeof clearTimeout ? clearTimeout : null, F = "undefined" !== typeof setImmediate ? setImmediate : null;
            "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
            function G(a) {
                for (var b = h(t); null !== b; ) {
                    if (null === b.callback) k(t); else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, 
                    f(r, b); else break;
                    b = h(t);
                }
            }
            function H(a) {
                B = !1;
                G(a);
                if (!A) if (null !== h(r)) A = !0, I(J); else {
                    var b = h(t);
                    null !== b && K(H, b.startTime - a);
                }
            }
            function J(a, b) {
                A = !1;
                B && (B = !1, E(L), L = -1);
                z = !0;
                var c = y;
                try {
                    G(b);
                    for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
                        var d = v.callback;
                        if ("function" === typeof d) {
                            v.callback = null;
                            y = v.priorityLevel;
                            var e = d(v.expirationTime <= b);
                            b = exports.unstable_now();
                            "function" === typeof e ? v.callback = e : v === h(r) && k(r);
                            G(b);
                        } else k(r);
                        v = h(r);
                    }
                    if (null !== v) var w = !0; else {
                        var m = h(t);
                        null !== m && K(H, m.startTime - b);
                        w = !1;
                    }
                    return w;
                } finally {
                    v = null, y = c, z = !1;
                }
            }
            var N = !1, O = null, L = -1, P = 5, Q = -1;
            function M() {
                return exports.unstable_now() - Q < P ? !1 : !0;
            }
            function R() {
                if (null !== O) {
                    var a = exports.unstable_now();
                    Q = a;
                    var b = !0;
                    try {
                        b = O(!0, a);
                    } finally {
                        b ? S() : (N = !1, O = null);
                    }
                } else N = !1;
            }
            var S;
            if ("function" === typeof F) S = function() {
                F(R);
            }; else if ("undefined" !== typeof MessageChannel) {
                var T = new MessageChannel, U = T.port2;
                T.port1.onmessage = R;
                S = function() {
                    U.postMessage(null);
                };
            } else S = function() {
                D(R, 0);
            };
            function I(a) {
                O = a;
                N || (N = !0, S());
            }
            function K(a, b) {
                L = D(function() {
                    a(exports.unstable_now());
                }, b);
            }
            exports.unstable_IdlePriority = 5;
            exports.unstable_ImmediatePriority = 1;
            exports.unstable_LowPriority = 4;
            exports.unstable_NormalPriority = 3;
            exports.unstable_Profiling = null;
            exports.unstable_UserBlockingPriority = 2;
            exports.unstable_cancelCallback = function(a) {
                a.callback = null;
            };
            exports.unstable_continueExecution = function() {
                A || z || (A = !0, I(J));
            };
            exports.unstable_forceFrameRate = function(a) {
                0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
            };
            exports.unstable_getCurrentPriorityLevel = function() {
                return y;
            };
            exports.unstable_getFirstCallbackNode = function() {
                return h(r);
            };
            exports.unstable_next = function(a) {
                switch (y) {
                  case 1:
                  case 2:
                  case 3:
                    var b = 3;
                    break;

                  default:
                    b = y;
                }
                var c = y;
                y = b;
                try {
                    return a();
                } finally {
                    y = c;
                }
            };
            exports.unstable_pauseExecution = function() {};
            exports.unstable_requestPaint = function() {};
            exports.unstable_runWithPriority = function(a, b) {
                switch (a) {
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                  case 5:
                    break;

                  default:
                    a = 3;
                }
                var c = y;
                y = a;
                try {
                    return b();
                } finally {
                    y = c;
                }
            };
            exports.unstable_scheduleCallback = function(a, b, c) {
                var d = exports.unstable_now();
                "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
                switch (a) {
                  case 1:
                    var e = -1;
                    break;

                  case 2:
                    e = 250;
                    break;

                  case 5:
                    e = 1073741823;
                    break;

                  case 4:
                    e = 1e4;
                    break;

                  default:
                    e = 5e3;
                }
                e = c + e;
                a = {
                    id: u++,
                    callback: b,
                    priorityLevel: a,
                    startTime: c,
                    expirationTime: e,
                    sortIndex: -1
                };
                c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = !0, 
                K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = !0, I(J)));
                return a;
            };
            exports.unstable_shouldYield = M;
            exports.unstable_wrapCallback = function(a) {
                var b = y;
                return function() {
                    var c = y;
                    y = b;
                    try {
                        return a.apply(this, arguments);
                    } finally {
                        y = c;
                    }
                };
            };
        },
        540: (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            if (true) module.exports = __webpack_require__(287);
        },
        551: (__unused_webpack_module, exports, __webpack_require__) => {
            "use strict";
            /**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */            var aa = __webpack_require__(540), ca = __webpack_require__(982);
            function p(a) {
                for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
                return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
            }
            var da = new Set, ea = {};
            function fa(a, b) {
                ha(a, b);
                ha(a + "Capture", b);
            }
            function ha(a, b) {
                ea[a] = b;
                for (a = 0; a < b.length; a++) da.add(b[a]);
            }
            var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
            function oa(a) {
                if (ja.call(ma, a)) return !0;
                if (ja.call(la, a)) return !1;
                if (ka.test(a)) return ma[a] = !0;
                la[a] = !0;
                return !1;
            }
            function pa(a, b, c, d) {
                if (null !== c && 0 === c.type) return !1;
                switch (typeof b) {
                  case "function":
                  case "symbol":
                    return !0;

                  case "boolean":
                    if (d) return !1;
                    if (null !== c) return !c.acceptsBooleans;
                    a = a.toLowerCase().slice(0, 5);
                    return "data-" !== a && "aria-" !== a;

                  default:
                    return !1;
                }
            }
            function qa(a, b, c, d) {
                if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return !0;
                if (d) return !1;
                if (null !== c) switch (c.type) {
                  case 3:
                    return !b;

                  case 4:
                    return !1 === b;

                  case 5:
                    return isNaN(b);

                  case 6:
                    return isNaN(b) || 1 > b;
                }
                return !1;
            }
            function v(a, b, c, d, e, f, g) {
                this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
                this.attributeName = d;
                this.attributeNamespace = e;
                this.mustUseProperty = c;
                this.propertyName = a;
                this.type = b;
                this.sanitizeURL = f;
                this.removeEmptyString = g;
            }
            var z = {};
            "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
                z[a] = new v(a, 0, !1, a, null, !1, !1);
            });
            [ [ "acceptCharset", "accept-charset" ], [ "className", "class" ], [ "htmlFor", "for" ], [ "httpEquiv", "http-equiv" ] ].forEach(function(a) {
                var b = a[0];
                z[b] = new v(b, 1, !1, a[1], null, !1, !1);
            });
            [ "contentEditable", "draggable", "spellCheck", "value" ].forEach(function(a) {
                z[a] = new v(a, 2, !1, a.toLowerCase(), null, !1, !1);
            });
            [ "autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha" ].forEach(function(a) {
                z[a] = new v(a, 2, !1, a, null, !1, !1);
            });
            "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
                z[a] = new v(a, 3, !1, a.toLowerCase(), null, !1, !1);
            });
            [ "checked", "multiple", "muted", "selected" ].forEach(function(a) {
                z[a] = new v(a, 3, !0, a, null, !1, !1);
            });
            [ "capture", "download" ].forEach(function(a) {
                z[a] = new v(a, 4, !1, a, null, !1, !1);
            });
            [ "cols", "rows", "size", "span" ].forEach(function(a) {
                z[a] = new v(a, 6, !1, a, null, !1, !1);
            });
            [ "rowSpan", "start" ].forEach(function(a) {
                z[a] = new v(a, 5, !1, a.toLowerCase(), null, !1, !1);
            });
            var ra = /[\-:]([a-z])/g;
            function sa(a) {
                return a[1].toUpperCase();
            }
            "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
                var b = a.replace(ra, sa);
                z[b] = new v(b, 1, !1, a, null, !1, !1);
            });
            "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
                var b = a.replace(ra, sa);
                z[b] = new v(b, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
            });
            [ "xml:base", "xml:lang", "xml:space" ].forEach(function(a) {
                var b = a.replace(ra, sa);
                z[b] = new v(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
            });
            [ "tabIndex", "crossOrigin" ].forEach(function(a) {
                z[a] = new v(a, 1, !1, a.toLowerCase(), null, !1, !1);
            });
            z.xlinkHref = new v("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
            [ "src", "href", "action", "formAction" ].forEach(function(a) {
                z[a] = new v(a, 1, !1, a.toLowerCase(), null, !0, !0);
            });
            function ta(a, b, c, d) {
                var e = z.hasOwnProperty(b) ? z[b] : null;
                if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), 
                d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? !1 : "" : c : (b = e.attributeName, 
                d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && !0 === c ? "" : "" + c, 
                d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
            }
            var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
            Symbol.for("react.scope");
            Symbol.for("react.debug_trace_mode");
            var Ia = Symbol.for("react.offscreen");
            Symbol.for("react.legacy_hidden");
            Symbol.for("react.cache");
            Symbol.for("react.tracing_marker");
            var Ja = Symbol.iterator;
            function Ka(a) {
                if (null === a || "object" !== typeof a) return null;
                a = Ja && a[Ja] || a["@@iterator"];
                return "function" === typeof a ? a : null;
            }
            var La, A = Object.assign;
            function Ma(a) {
                if (void 0 === La) try {
                    throw Error();
                } catch (c) {
                    var b = c.stack.trim().match(/\n( *(at )?)/);
                    La = b && b[1] || "";
                }
                return "\n" + La + a;
            }
            var Na = !1;
            function Oa(a, b) {
                if (!a || Na) return "";
                Na = !0;
                var c = Error.prepareStackTrace;
                Error.prepareStackTrace = void 0;
                try {
                    if (b) if (b = function() {
                        throw Error();
                    }, Object.defineProperty(b.prototype, "props", {
                        set: function() {
                            throw Error();
                        }
                    }), "object" === typeof Reflect && Reflect.construct) {
                        try {
                            Reflect.construct(b, []);
                        } catch (l) {
                            var d = l;
                        }
                        Reflect.construct(a, [], b);
                    } else {
                        try {
                            b.call();
                        } catch (l) {
                            d = l;
                        }
                        a.call(b.prototype);
                    } else {
                        try {
                            throw Error();
                        } catch (l) {
                            d = l;
                        }
                        a();
                    }
                } catch (l) {
                    if (l && d && "string" === typeof l.stack) {
                        for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; ) h--;
                        for (;1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
                            if (1 !== g || 1 !== h) do {
                                if (g--, h--, 0 > h || e[g] !== f[h]) {
                                    var k = "\n" + e[g].replace(" at new ", " at ");
                                    a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                                    return k;
                                }
                            } while (1 <= g && 0 <= h);
                            break;
                        }
                    }
                } finally {
                    Na = !1, Error.prepareStackTrace = c;
                }
                return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
            }
            function Pa(a) {
                switch (a.tag) {
                  case 5:
                    return Ma(a.type);

                  case 16:
                    return Ma("Lazy");

                  case 13:
                    return Ma("Suspense");

                  case 19:
                    return Ma("SuspenseList");

                  case 0:
                  case 2:
                  case 15:
                    return a = Oa(a.type, !1), a;

                  case 11:
                    return a = Oa(a.type.render, !1), a;

                  case 1:
                    return a = Oa(a.type, !0), a;

                  default:
                    return "";
                }
            }
            function Qa(a) {
                if (null == a) return null;
                if ("function" === typeof a) return a.displayName || a.name || null;
                if ("string" === typeof a) return a;
                switch (a) {
                  case ya:
                    return "Fragment";

                  case wa:
                    return "Portal";

                  case Aa:
                    return "Profiler";

                  case za:
                    return "StrictMode";

                  case Ea:
                    return "Suspense";

                  case Fa:
                    return "SuspenseList";
                }
                if ("object" === typeof a) switch (a.$$typeof) {
                  case Ca:
                    return (a.displayName || "Context") + ".Consumer";

                  case Ba:
                    return (a._context.displayName || "Context") + ".Provider";

                  case Da:
                    var b = a.render;
                    a = a.displayName;
                    a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
                    return a;

                  case Ga:
                    return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";

                  case Ha:
                    b = a._payload;
                    a = a._init;
                    try {
                        return Qa(a(b));
                    } catch (c) {}
                }
                return null;
            }
            function Ra(a) {
                var b = a.type;
                switch (a.tag) {
                  case 24:
                    return "Cache";

                  case 9:
                    return (b.displayName || "Context") + ".Consumer";

                  case 10:
                    return (b._context.displayName || "Context") + ".Provider";

                  case 18:
                    return "DehydratedFragment";

                  case 11:
                    return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");

                  case 7:
                    return "Fragment";

                  case 5:
                    return b;

                  case 4:
                    return "Portal";

                  case 3:
                    return "Root";

                  case 6:
                    return "Text";

                  case 16:
                    return Qa(b);

                  case 8:
                    return b === za ? "StrictMode" : "Mode";

                  case 22:
                    return "Offscreen";

                  case 12:
                    return "Profiler";

                  case 21:
                    return "Scope";

                  case 13:
                    return "Suspense";

                  case 19:
                    return "SuspenseList";

                  case 25:
                    return "TracingMarker";

                  case 1:
                  case 0:
                  case 17:
                  case 2:
                  case 14:
                  case 15:
                    if ("function" === typeof b) return b.displayName || b.name || null;
                    if ("string" === typeof b) return b;
                }
                return null;
            }
            function Sa(a) {
                switch (typeof a) {
                  case "boolean":
                  case "number":
                  case "string":
                  case "undefined":
                    return a;

                  case "object":
                    return a;

                  default:
                    return "";
                }
            }
            function Ta(a) {
                var b = a.type;
                return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
            }
            function Ua(a) {
                var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
                if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
                    var e = c.get, f = c.set;
                    Object.defineProperty(a, b, {
                        configurable: !0,
                        get: function() {
                            return e.call(this);
                        },
                        set: function(a) {
                            d = "" + a;
                            f.call(this, a);
                        }
                    });
                    Object.defineProperty(a, b, {
                        enumerable: c.enumerable
                    });
                    return {
                        getValue: function() {
                            return d;
                        },
                        setValue: function(a) {
                            d = "" + a;
                        },
                        stopTracking: function() {
                            a._valueTracker = null;
                            delete a[b];
                        }
                    };
                }
            }
            function Va(a) {
                a._valueTracker || (a._valueTracker = Ua(a));
            }
            function Wa(a) {
                if (!a) return !1;
                var b = a._valueTracker;
                if (!b) return !0;
                var c = b.getValue();
                var d = "";
                a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
                a = d;
                return a !== c ? (b.setValue(a), !0) : !1;
            }
            function Xa(a) {
                a = a || ("undefined" !== typeof document ? document : void 0);
                if ("undefined" === typeof a) return null;
                try {
                    return a.activeElement || a.body;
                } catch (b) {
                    return a.body;
                }
            }
            function Ya(a, b) {
                var c = b.checked;
                return A({}, b, {
                    defaultChecked: void 0,
                    defaultValue: void 0,
                    value: void 0,
                    checked: null != c ? c : a._wrapperState.initialChecked
                });
            }
            function Za(a, b) {
                var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
                c = Sa(null != b.value ? b.value : c);
                a._wrapperState = {
                    initialChecked: d,
                    initialValue: c,
                    controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value
                };
            }
            function ab(a, b) {
                b = b.checked;
                null != b && ta(a, "checked", b, !1);
            }
            function bb(a, b) {
                ab(a, b);
                var c = Sa(b.value), d = b.type;
                if (null != c) if ("number" === d) {
                    if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
                } else a.value !== "" + c && (a.value = "" + c); else if ("submit" === d || "reset" === d) {
                    a.removeAttribute("value");
                    return;
                }
                b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
                null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
            }
            function db(a, b, c) {
                if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
                    var d = b.type;
                    if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
                    b = "" + a._wrapperState.initialValue;
                    c || b === a.value || (a.value = b);
                    a.defaultValue = b;
                }
                c = a.name;
                "" !== c && (a.name = "");
                a.defaultChecked = !!a._wrapperState.initialChecked;
                "" !== c && (a.name = c);
            }
            function cb(a, b, c) {
                if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
            }
            var eb = Array.isArray;
            function fb(a, b, c, d) {
                a = a.options;
                if (b) {
                    b = {};
                    for (var e = 0; e < c.length; e++) b["$" + c[e]] = !0;
                    for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), 
                    e && d && (a[c].defaultSelected = !0);
                } else {
                    c = "" + Sa(c);
                    b = null;
                    for (e = 0; e < a.length; e++) {
                        if (a[e].value === c) {
                            a[e].selected = !0;
                            d && (a[e].defaultSelected = !0);
                            return;
                        }
                        null !== b || a[e].disabled || (b = a[e]);
                    }
                    null !== b && (b.selected = !0);
                }
            }
            function gb(a, b) {
                if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
                return A({}, b, {
                    value: void 0,
                    defaultValue: void 0,
                    children: "" + a._wrapperState.initialValue
                });
            }
            function hb(a, b) {
                var c = b.value;
                if (null == c) {
                    c = b.children;
                    b = b.defaultValue;
                    if (null != c) {
                        if (null != b) throw Error(p(92));
                        if (eb(c)) {
                            if (1 < c.length) throw Error(p(93));
                            c = c[0];
                        }
                        b = c;
                    }
                    null == b && (b = "");
                    c = b;
                }
                a._wrapperState = {
                    initialValue: Sa(c)
                };
            }
            function ib(a, b) {
                var c = Sa(b.value), d = Sa(b.defaultValue);
                null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
                null != d && (a.defaultValue = "" + d);
            }
            function jb(a) {
                var b = a.textContent;
                b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
            }
            function kb(a) {
                switch (a) {
                  case "svg":
                    return "http://www.w3.org/2000/svg";

                  case "math":
                    return "http://www.w3.org/1998/Math/MathML";

                  default:
                    return "http://www.w3.org/1999/xhtml";
                }
            }
            function lb(a, b) {
                return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
            }
            var mb, nb = function(a) {
                return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
                    MSApp.execUnsafeLocalFunction(function() {
                        return a(b, c, d, e);
                    });
                } : a;
            }(function(a, b) {
                if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b; else {
                    mb = mb || document.createElement("div");
                    mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
                    for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
                    for (;b.firstChild; ) a.appendChild(b.firstChild);
                }
            });
            function ob(a, b) {
                if (b) {
                    var c = a.firstChild;
                    if (c && c === a.lastChild && 3 === c.nodeType) {
                        c.nodeValue = b;
                        return;
                    }
                }
                a.textContent = b;
            }
            var pb = {
                animationIterationCount: !0,
                aspectRatio: !0,
                borderImageOutset: !0,
                borderImageSlice: !0,
                borderImageWidth: !0,
                boxFlex: !0,
                boxFlexGroup: !0,
                boxOrdinalGroup: !0,
                columnCount: !0,
                columns: !0,
                flex: !0,
                flexGrow: !0,
                flexPositive: !0,
                flexShrink: !0,
                flexNegative: !0,
                flexOrder: !0,
                gridArea: !0,
                gridRow: !0,
                gridRowEnd: !0,
                gridRowSpan: !0,
                gridRowStart: !0,
                gridColumn: !0,
                gridColumnEnd: !0,
                gridColumnSpan: !0,
                gridColumnStart: !0,
                fontWeight: !0,
                lineClamp: !0,
                lineHeight: !0,
                opacity: !0,
                order: !0,
                orphans: !0,
                tabSize: !0,
                widows: !0,
                zIndex: !0,
                zoom: !0,
                fillOpacity: !0,
                floodOpacity: !0,
                stopOpacity: !0,
                strokeDasharray: !0,
                strokeDashoffset: !0,
                strokeMiterlimit: !0,
                strokeOpacity: !0,
                strokeWidth: !0
            }, qb = [ "Webkit", "ms", "Moz", "O" ];
            Object.keys(pb).forEach(function(a) {
                qb.forEach(function(b) {
                    b = b + a.charAt(0).toUpperCase() + a.substring(1);
                    pb[b] = pb[a];
                });
            });
            function rb(a, b, c) {
                return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
            }
            function sb(a, b) {
                a = a.style;
                for (var c in b) if (b.hasOwnProperty(c)) {
                    var d = 0 === c.indexOf("--"), e = rb(c, b[c], d);
                    "float" === c && (c = "cssFloat");
                    d ? a.setProperty(c, e) : a[c] = e;
                }
            }
            var tb = A({
                menuitem: !0
            }, {
                area: !0,
                base: !0,
                br: !0,
                col: !0,
                embed: !0,
                hr: !0,
                img: !0,
                input: !0,
                keygen: !0,
                link: !0,
                meta: !0,
                param: !0,
                source: !0,
                track: !0,
                wbr: !0
            });
            function ub(a, b) {
                if (b) {
                    if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
                    if (null != b.dangerouslySetInnerHTML) {
                        if (null != b.children) throw Error(p(60));
                        if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
                    }
                    if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
                }
            }
            function vb(a, b) {
                if (-1 === a.indexOf("-")) return "string" === typeof b.is;
                switch (a) {
                  case "annotation-xml":
                  case "color-profile":
                  case "font-face":
                  case "font-face-src":
                  case "font-face-uri":
                  case "font-face-format":
                  case "font-face-name":
                  case "missing-glyph":
                    return !1;

                  default:
                    return !0;
                }
            }
            var wb = null;
            function xb(a) {
                a = a.target || a.srcElement || window;
                a.correspondingUseElement && (a = a.correspondingUseElement);
                return 3 === a.nodeType ? a.parentNode : a;
            }
            var yb = null, zb = null, Ab = null;
            function Bb(a) {
                if (a = Cb(a)) {
                    if ("function" !== typeof yb) throw Error(p(280));
                    var b = a.stateNode;
                    b && (b = Db(b), yb(a.stateNode, a.type, b));
                }
            }
            function Eb(a) {
                zb ? Ab ? Ab.push(a) : Ab = [ a ] : zb = a;
            }
            function Fb() {
                if (zb) {
                    var a = zb, b = Ab;
                    Ab = zb = null;
                    Bb(a);
                    if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
                }
            }
            function Gb(a, b) {
                return a(b);
            }
            function Hb() {}
            var Ib = !1;
            function Jb(a, b, c) {
                if (Ib) return a(b, c);
                Ib = !0;
                try {
                    return Gb(a, b, c);
                } finally {
                    if (Ib = !1, null !== zb || null !== Ab) Hb(), Fb();
                }
            }
            function Kb(a, b) {
                var c = a.stateNode;
                if (null === c) return null;
                var d = Db(c);
                if (null === d) return null;
                c = d[b];
                a: switch (b) {
                  case "onClick":
                  case "onClickCapture":
                  case "onDoubleClick":
                  case "onDoubleClickCapture":
                  case "onMouseDown":
                  case "onMouseDownCapture":
                  case "onMouseMove":
                  case "onMouseMoveCapture":
                  case "onMouseUp":
                  case "onMouseUpCapture":
                  case "onMouseEnter":
                    (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
                    a = !d;
                    break a;

                  default:
                    a = !1;
                }
                if (a) return null;
                if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
                return c;
            }
            var Lb = !1;
            if (ia) try {
                var Mb = {};
                Object.defineProperty(Mb, "passive", {
                    get: function() {
                        Lb = !0;
                    }
                });
                window.addEventListener("test", Mb, Mb);
                window.removeEventListener("test", Mb, Mb);
            } catch (a) {
                Lb = !1;
            }
            function Nb(a, b, c, d, e, f, g, h, k) {
                var l = Array.prototype.slice.call(arguments, 3);
                try {
                    b.apply(c, l);
                } catch (m) {
                    this.onError(m);
                }
            }
            var Ob = !1, Pb = null, Qb = !1, Rb = null, Sb = {
                onError: function(a) {
                    Ob = !0;
                    Pb = a;
                }
            };
            function Tb(a, b, c, d, e, f, g, h, k) {
                Ob = !1;
                Pb = null;
                Nb.apply(Sb, arguments);
            }
            function Ub(a, b, c, d, e, f, g, h, k) {
                Tb.apply(this, arguments);
                if (Ob) {
                    if (Ob) {
                        var l = Pb;
                        Ob = !1;
                        Pb = null;
                    } else throw Error(p(198));
                    Qb || (Qb = !0, Rb = l);
                }
            }
            function Vb(a) {
                var b = a, c = a;
                if (a.alternate) for (;b.return; ) b = b.return; else {
                    a = b;
                    do {
                        b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
                    } while (a);
                }
                return 3 === b.tag ? c : null;
            }
            function Wb(a) {
                if (13 === a.tag) {
                    var b = a.memoizedState;
                    null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
                    if (null !== b) return b.dehydrated;
                }
                return null;
            }
            function Xb(a) {
                if (Vb(a) !== a) throw Error(p(188));
            }
            function Yb(a) {
                var b = a.alternate;
                if (!b) {
                    b = Vb(a);
                    if (null === b) throw Error(p(188));
                    return b !== a ? null : a;
                }
                for (var c = a, d = b; ;) {
                    var e = c.return;
                    if (null === e) break;
                    var f = e.alternate;
                    if (null === f) {
                        d = e.return;
                        if (null !== d) {
                            c = d;
                            continue;
                        }
                        break;
                    }
                    if (e.child === f.child) {
                        for (f = e.child; f; ) {
                            if (f === c) return Xb(e), a;
                            if (f === d) return Xb(e), b;
                            f = f.sibling;
                        }
                        throw Error(p(188));
                    }
                    if (c.return !== d.return) c = e, d = f; else {
                        for (var g = !1, h = e.child; h; ) {
                            if (h === c) {
                                g = !0;
                                c = e;
                                d = f;
                                break;
                            }
                            if (h === d) {
                                g = !0;
                                d = e;
                                c = f;
                                break;
                            }
                            h = h.sibling;
                        }
                        if (!g) {
                            for (h = f.child; h; ) {
                                if (h === c) {
                                    g = !0;
                                    c = f;
                                    d = e;
                                    break;
                                }
                                if (h === d) {
                                    g = !0;
                                    d = f;
                                    c = e;
                                    break;
                                }
                                h = h.sibling;
                            }
                            if (!g) throw Error(p(189));
                        }
                    }
                    if (c.alternate !== d) throw Error(p(190));
                }
                if (3 !== c.tag) throw Error(p(188));
                return c.stateNode.current === c ? a : b;
            }
            function Zb(a) {
                a = Yb(a);
                return null !== a ? $b(a) : null;
            }
            function $b(a) {
                if (5 === a.tag || 6 === a.tag) return a;
                for (a = a.child; null !== a; ) {
                    var b = $b(a);
                    if (null !== b) return b;
                    a = a.sibling;
                }
                return null;
            }
            var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
            function mc(a) {
                if (lc && "function" === typeof lc.onCommitFiberRoot) try {
                    lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
                } catch (b) {}
            }
            var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
            function nc(a) {
                a >>>= 0;
                return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
            }
            var rc = 64, sc = 4194304;
            function tc(a) {
                switch (a & -a) {
                  case 1:
                    return 1;

                  case 2:
                    return 2;

                  case 4:
                    return 4;

                  case 8:
                    return 8;

                  case 16:
                    return 16;

                  case 32:
                    return 32;

                  case 64:
                  case 128:
                  case 256:
                  case 512:
                  case 1024:
                  case 2048:
                  case 4096:
                  case 8192:
                  case 16384:
                  case 32768:
                  case 65536:
                  case 131072:
                  case 262144:
                  case 524288:
                  case 1048576:
                  case 2097152:
                    return a & 4194240;

                  case 4194304:
                  case 8388608:
                  case 16777216:
                  case 33554432:
                  case 67108864:
                    return a & 130023424;

                  case 134217728:
                    return 134217728;

                  case 268435456:
                    return 268435456;

                  case 536870912:
                    return 536870912;

                  case 1073741824:
                    return 1073741824;

                  default:
                    return a;
                }
            }
            function uc(a, b) {
                var c = a.pendingLanes;
                if (0 === c) return 0;
                var d = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
                if (0 !== g) {
                    var h = g & ~e;
                    0 !== h ? d = tc(h) : (f &= g, 0 !== f && (d = tc(f)));
                } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
                if (0 === d) return 0;
                if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
                0 !== (d & 4) && (d |= c & 16);
                b = a.entangledLanes;
                if (0 !== b) for (a = a.entanglements, b &= d; 0 < b; ) c = 31 - oc(b), e = 1 << c, 
                d |= a[c], b &= ~e;
                return d;
            }
            function vc(a, b) {
                switch (a) {
                  case 1:
                  case 2:
                  case 4:
                    return b + 250;

                  case 8:
                  case 16:
                  case 32:
                  case 64:
                  case 128:
                  case 256:
                  case 512:
                  case 1024:
                  case 2048:
                  case 4096:
                  case 8192:
                  case 16384:
                  case 32768:
                  case 65536:
                  case 131072:
                  case 262144:
                  case 524288:
                  case 1048576:
                  case 2097152:
                    return b + 5e3;

                  case 4194304:
                  case 8388608:
                  case 16777216:
                  case 33554432:
                  case 67108864:
                    return -1;

                  case 134217728:
                  case 268435456:
                  case 536870912:
                  case 1073741824:
                    return -1;

                  default:
                    return -1;
                }
            }
            function wc(a, b) {
                for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f; ) {
                    var g = 31 - oc(f), h = 1 << g, k = e[g];
                    if (-1 === k) {
                        if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
                    } else k <= b && (a.expiredLanes |= h);
                    f &= ~h;
                }
            }
            function xc(a) {
                a = a.pendingLanes & -1073741825;
                return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
            }
            function yc() {
                var a = rc;
                rc <<= 1;
                0 === (rc & 4194240) && (rc = 64);
                return a;
            }
            function zc(a) {
                for (var b = [], c = 0; 31 > c; c++) b.push(a);
                return b;
            }
            function Ac(a, b, c) {
                a.pendingLanes |= b;
                536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
                a = a.eventTimes;
                b = 31 - oc(b);
                a[b] = c;
            }
            function Bc(a, b) {
                var c = a.pendingLanes & ~b;
                a.pendingLanes = b;
                a.suspendedLanes = 0;
                a.pingedLanes = 0;
                a.expiredLanes &= b;
                a.mutableReadLanes &= b;
                a.entangledLanes &= b;
                b = a.entanglements;
                var d = a.eventTimes;
                for (a = a.expirationTimes; 0 < c; ) {
                    var e = 31 - oc(c), f = 1 << e;
                    b[e] = 0;
                    d[e] = -1;
                    a[e] = -1;
                    c &= ~f;
                }
            }
            function Cc(a, b) {
                var c = a.entangledLanes |= b;
                for (a = a.entanglements; c; ) {
                    var d = 31 - oc(c), e = 1 << d;
                    e & b | a[d] & b && (a[d] |= b);
                    c &= ~e;
                }
            }
            var C = 0;
            function Dc(a) {
                a &= -a;
                return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
            }
            var Ec, Fc, Gc, Hc, Ic, Jc = !1, Kc = [], Lc = null, Mc = null, Nc = null, Oc = new Map, Pc = new Map, Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
            function Sc(a, b) {
                switch (a) {
                  case "focusin":
                  case "focusout":
                    Lc = null;
                    break;

                  case "dragenter":
                  case "dragleave":
                    Mc = null;
                    break;

                  case "mouseover":
                  case "mouseout":
                    Nc = null;
                    break;

                  case "pointerover":
                  case "pointerout":
                    Oc.delete(b.pointerId);
                    break;

                  case "gotpointercapture":
                  case "lostpointercapture":
                    Pc.delete(b.pointerId);
                }
            }
            function Tc(a, b, c, d, e, f) {
                if (null === a || a.nativeEvent !== f) return a = {
                    blockedOn: b,
                    domEventName: c,
                    eventSystemFlags: d,
                    nativeEvent: f,
                    targetContainers: [ e ]
                }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
                a.eventSystemFlags |= d;
                b = a.targetContainers;
                null !== e && -1 === b.indexOf(e) && b.push(e);
                return a;
            }
            function Uc(a, b, c, d, e) {
                switch (b) {
                  case "focusin":
                    return Lc = Tc(Lc, a, b, c, d, e), !0;

                  case "dragenter":
                    return Mc = Tc(Mc, a, b, c, d, e), !0;

                  case "mouseover":
                    return Nc = Tc(Nc, a, b, c, d, e), !0;

                  case "pointerover":
                    var f = e.pointerId;
                    Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
                    return !0;

                  case "gotpointercapture":
                    return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), !0;
                }
                return !1;
            }
            function Vc(a) {
                var b = Wc(a.target);
                if (null !== b) {
                    var c = Vb(b);
                    if (null !== c) if (b = c.tag, 13 === b) {
                        if (b = Wb(c), null !== b) {
                            a.blockedOn = b;
                            Ic(a.priority, function() {
                                Gc(c);
                            });
                            return;
                        }
                    } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
                        a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
                        return;
                    }
                }
                a.blockedOn = null;
            }
            function Xc(a) {
                if (null !== a.blockedOn) return !1;
                for (var b = a.targetContainers; 0 < b.length; ) {
                    var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
                    if (null === c) {
                        c = a.nativeEvent;
                        var d = new c.constructor(c.type, c);
                        wb = d;
                        c.target.dispatchEvent(d);
                        wb = null;
                    } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, !1;
                    b.shift();
                }
                return !0;
            }
            function Zc(a, b, c) {
                Xc(a) && c.delete(b);
            }
            function $c() {
                Jc = !1;
                null !== Lc && Xc(Lc) && (Lc = null);
                null !== Mc && Xc(Mc) && (Mc = null);
                null !== Nc && Xc(Nc) && (Nc = null);
                Oc.forEach(Zc);
                Pc.forEach(Zc);
            }
            function ad(a, b) {
                a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = !0, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
            }
            function bd(a) {
                function b(b) {
                    return ad(b, a);
                }
                if (0 < Kc.length) {
                    ad(Kc[0], a);
                    for (var c = 1; c < Kc.length; c++) {
                        var d = Kc[c];
                        d.blockedOn === a && (d.blockedOn = null);
                    }
                }
                null !== Lc && ad(Lc, a);
                null !== Mc && ad(Mc, a);
                null !== Nc && ad(Nc, a);
                Oc.forEach(b);
                Pc.forEach(b);
                for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
                for (;0 < Qc.length && (c = Qc[0], null === c.blockedOn); ) Vc(c), null === c.blockedOn && Qc.shift();
            }
            var cd = ua.ReactCurrentBatchConfig, dd = !0;
            function ed(a, b, c, d) {
                var e = C, f = cd.transition;
                cd.transition = null;
                try {
                    C = 1, fd(a, b, c, d);
                } finally {
                    C = e, cd.transition = f;
                }
            }
            function gd(a, b, c, d) {
                var e = C, f = cd.transition;
                cd.transition = null;
                try {
                    C = 4, fd(a, b, c, d);
                } finally {
                    C = e, cd.transition = f;
                }
            }
            function fd(a, b, c, d) {
                if (dd) {
                    var e = Yc(a, b, c, d);
                    if (null === e) hd(a, b, d, id, c), Sc(a, d); else if (Uc(e, a, b, c, d)) d.stopPropagation(); else if (Sc(a, d), 
                    b & 4 && -1 < Rc.indexOf(a)) {
                        for (;null !== e; ) {
                            var f = Cb(e);
                            null !== f && Ec(f);
                            f = Yc(a, b, c, d);
                            null === f && hd(a, b, d, id, c);
                            if (f === e) break;
                            e = f;
                        }
                        null !== e && d.stopPropagation();
                    } else hd(a, b, d, null, c);
                }
            }
            var id = null;
            function Yc(a, b, c, d) {
                id = null;
                a = xb(d);
                a = Wc(a);
                if (null !== a) if (b = Vb(a), null === b) a = null; else if (c = b.tag, 13 === c) {
                    a = Wb(b);
                    if (null !== a) return a;
                    a = null;
                } else if (3 === c) {
                    if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
                    a = null;
                } else b !== a && (a = null);
                id = a;
                return null;
            }
            function jd(a) {
                switch (a) {
                  case "cancel":
                  case "click":
                  case "close":
                  case "contextmenu":
                  case "copy":
                  case "cut":
                  case "auxclick":
                  case "dblclick":
                  case "dragend":
                  case "dragstart":
                  case "drop":
                  case "focusin":
                  case "focusout":
                  case "input":
                  case "invalid":
                  case "keydown":
                  case "keypress":
                  case "keyup":
                  case "mousedown":
                  case "mouseup":
                  case "paste":
                  case "pause":
                  case "play":
                  case "pointercancel":
                  case "pointerdown":
                  case "pointerup":
                  case "ratechange":
                  case "reset":
                  case "resize":
                  case "seeked":
                  case "submit":
                  case "touchcancel":
                  case "touchend":
                  case "touchstart":
                  case "volumechange":
                  case "change":
                  case "selectionchange":
                  case "textInput":
                  case "compositionstart":
                  case "compositionend":
                  case "compositionupdate":
                  case "beforeblur":
                  case "afterblur":
                  case "beforeinput":
                  case "blur":
                  case "fullscreenchange":
                  case "focus":
                  case "hashchange":
                  case "popstate":
                  case "select":
                  case "selectstart":
                    return 1;

                  case "drag":
                  case "dragenter":
                  case "dragexit":
                  case "dragleave":
                  case "dragover":
                  case "mousemove":
                  case "mouseout":
                  case "mouseover":
                  case "pointermove":
                  case "pointerout":
                  case "pointerover":
                  case "scroll":
                  case "toggle":
                  case "touchmove":
                  case "wheel":
                  case "mouseenter":
                  case "mouseleave":
                  case "pointerenter":
                  case "pointerleave":
                    return 4;

                  case "message":
                    switch (ec()) {
                      case fc:
                        return 1;

                      case gc:
                        return 4;

                      case hc:
                      case ic:
                        return 16;

                      case jc:
                        return 536870912;

                      default:
                        return 16;
                    }

                  default:
                    return 16;
                }
            }
            var kd = null, ld = null, md = null;
            function nd() {
                if (md) return md;
                var a, d, b = ld, c = b.length, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
                for (a = 0; a < c && b[a] === e[a]; a++) ;
                var g = c - a;
                for (d = 1; d <= g && b[c - d] === e[f - d]; d++) ;
                return md = e.slice(a, 1 < d ? 1 - d : void 0);
            }
            function od(a) {
                var b = a.keyCode;
                "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
                10 === a && (a = 13);
                return 32 <= a || 13 === a ? a : 0;
            }
            function pd() {
                return !0;
            }
            function qd() {
                return !1;
            }
            function rd(a) {
                function b(b, d, e, f, g) {
                    this._reactName = b;
                    this._targetInst = e;
                    this.type = d;
                    this.nativeEvent = f;
                    this.target = g;
                    this.currentTarget = null;
                    for (var c in a) a.hasOwnProperty(c) && (b = a[c], this[c] = b ? b(f) : f[c]);
                    this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : !1 === f.returnValue) ? pd : qd;
                    this.isPropagationStopped = qd;
                    return this;
                }
                A(b.prototype, {
                    preventDefault: function() {
                        this.defaultPrevented = !0;
                        var a = this.nativeEvent;
                        a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = !1), 
                        this.isDefaultPrevented = pd);
                    },
                    stopPropagation: function() {
                        var a = this.nativeEvent;
                        a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = !0), 
                        this.isPropagationStopped = pd);
                    },
                    persist: function() {},
                    isPersistent: pd
                });
                return b;
            }
            var wd, xd, yd, sd = {
                eventPhase: 0,
                bubbles: 0,
                cancelable: 0,
                timeStamp: function(a) {
                    return a.timeStamp || Date.now();
                },
                defaultPrevented: 0,
                isTrusted: 0
            }, td = rd(sd), ud = A({}, sd, {
                view: 0,
                detail: 0
            }), vd = rd(ud), Ad = A({}, ud, {
                screenX: 0,
                screenY: 0,
                clientX: 0,
                clientY: 0,
                pageX: 0,
                pageY: 0,
                ctrlKey: 0,
                shiftKey: 0,
                altKey: 0,
                metaKey: 0,
                getModifierState: zd,
                button: 0,
                buttons: 0,
                relatedTarget: function(a) {
                    return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
                },
                movementX: function(a) {
                    if ("movementX" in a) return a.movementX;
                    a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, 
                    yd = a);
                    return wd;
                },
                movementY: function(a) {
                    return "movementY" in a ? a.movementY : xd;
                }
            }), Bd = rd(Ad), Cd = A({}, Ad, {
                dataTransfer: 0
            }), Dd = rd(Cd), Ed = A({}, ud, {
                relatedTarget: 0
            }), Fd = rd(Ed), Gd = A({}, sd, {
                animationName: 0,
                elapsedTime: 0,
                pseudoElement: 0
            }), Hd = rd(Gd), Id = A({}, sd, {
                clipboardData: function(a) {
                    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
                }
            }), Jd = rd(Id), Kd = A({}, sd, {
                data: 0
            }), Ld = rd(Kd), Md = {
                Esc: "Escape",
                Spacebar: " ",
                Left: "ArrowLeft",
                Up: "ArrowUp",
                Right: "ArrowRight",
                Down: "ArrowDown",
                Del: "Delete",
                Win: "OS",
                Menu: "ContextMenu",
                Apps: "ContextMenu",
                Scroll: "ScrollLock",
                MozPrintableKey: "Unidentified"
            }, Nd = {
                8: "Backspace",
                9: "Tab",
                12: "Clear",
                13: "Enter",
                16: "Shift",
                17: "Control",
                18: "Alt",
                19: "Pause",
                20: "CapsLock",
                27: "Escape",
                32: " ",
                33: "PageUp",
                34: "PageDown",
                35: "End",
                36: "Home",
                37: "ArrowLeft",
                38: "ArrowUp",
                39: "ArrowRight",
                40: "ArrowDown",
                45: "Insert",
                46: "Delete",
                112: "F1",
                113: "F2",
                114: "F3",
                115: "F4",
                116: "F5",
                117: "F6",
                118: "F7",
                119: "F8",
                120: "F9",
                121: "F10",
                122: "F11",
                123: "F12",
                144: "NumLock",
                145: "ScrollLock",
                224: "Meta"
            }, Od = {
                Alt: "altKey",
                Control: "ctrlKey",
                Meta: "metaKey",
                Shift: "shiftKey"
            };
            function Pd(a) {
                var b = this.nativeEvent;
                return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : !1;
            }
            function zd() {
                return Pd;
            }
            var Qd = A({}, ud, {
                key: function(a) {
                    if (a.key) {
                        var b = Md[a.key] || a.key;
                        if ("Unidentified" !== b) return b;
                    }
                    return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
                },
                code: 0,
                location: 0,
                ctrlKey: 0,
                shiftKey: 0,
                altKey: 0,
                metaKey: 0,
                repeat: 0,
                locale: 0,
                getModifierState: zd,
                charCode: function(a) {
                    return "keypress" === a.type ? od(a) : 0;
                },
                keyCode: function(a) {
                    return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
                },
                which: function(a) {
                    return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
                }
            }), Rd = rd(Qd), Sd = A({}, Ad, {
                pointerId: 0,
                width: 0,
                height: 0,
                pressure: 0,
                tangentialPressure: 0,
                tiltX: 0,
                tiltY: 0,
                twist: 0,
                pointerType: 0,
                isPrimary: 0
            }), Td = rd(Sd), Ud = A({}, ud, {
                touches: 0,
                targetTouches: 0,
                changedTouches: 0,
                altKey: 0,
                metaKey: 0,
                ctrlKey: 0,
                shiftKey: 0,
                getModifierState: zd
            }), Vd = rd(Ud), Wd = A({}, sd, {
                propertyName: 0,
                elapsedTime: 0,
                pseudoElement: 0
            }), Xd = rd(Wd), Yd = A({}, Ad, {
                deltaX: function(a) {
                    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
                },
                deltaY: function(a) {
                    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
                },
                deltaZ: 0,
                deltaMode: 0
            }), Zd = rd(Yd), $d = [ 9, 13, 27, 32 ], ae = ia && "CompositionEvent" in window, be = null;
            ia && "documentMode" in document && (be = document.documentMode);
            var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = !1;
            function ge(a, b) {
                switch (a) {
                  case "keyup":
                    return -1 !== $d.indexOf(b.keyCode);

                  case "keydown":
                    return 229 !== b.keyCode;

                  case "keypress":
                  case "mousedown":
                  case "focusout":
                    return !0;

                  default:
                    return !1;
                }
            }
            function he(a) {
                a = a.detail;
                return "object" === typeof a && "data" in a ? a.data : null;
            }
            var ie = !1;
            function je(a, b) {
                switch (a) {
                  case "compositionend":
                    return he(b);

                  case "keypress":
                    if (32 !== b.which) return null;
                    fe = !0;
                    return ee;

                  case "textInput":
                    return a = b.data, a === ee && fe ? null : a;

                  default:
                    return null;
                }
            }
            function ke(a, b) {
                if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, 
                ie = !1, a) : null;
                switch (a) {
                  case "paste":
                    return null;

                  case "keypress":
                    if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
                        if (b.char && 1 < b.char.length) return b.char;
                        if (b.which) return String.fromCharCode(b.which);
                    }
                    return null;

                  case "compositionend":
                    return de && "ko" !== b.locale ? null : b.data;

                  default:
                    return null;
                }
            }
            var le = {
                color: !0,
                date: !0,
                datetime: !0,
                "datetime-local": !0,
                email: !0,
                month: !0,
                number: !0,
                password: !0,
                range: !0,
                search: !0,
                tel: !0,
                text: !0,
                time: !0,
                url: !0,
                week: !0
            };
            function me(a) {
                var b = a && a.nodeName && a.nodeName.toLowerCase();
                return "input" === b ? !!le[a.type] : "textarea" === b ? !0 : !1;
            }
            function ne(a, b, c, d) {
                Eb(d);
                b = oe(b, "onChange");
                0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({
                    event: c,
                    listeners: b
                }));
            }
            var pe = null, qe = null;
            function re(a) {
                se(a, 0);
            }
            function te(a) {
                var b = ue(a);
                if (Wa(b)) return a;
            }
            function ve(a, b) {
                if ("change" === a) return b;
            }
            var we = !1;
            if (ia) {
                var xe;
                if (ia) {
                    var ye = "oninput" in document;
                    if (!ye) {
                        var ze = document.createElement("div");
                        ze.setAttribute("oninput", "return;");
                        ye = "function" === typeof ze.oninput;
                    }
                    xe = ye;
                } else xe = !1;
                we = xe && (!document.documentMode || 9 < document.documentMode);
            }
            function Ae() {
                pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
            }
            function Be(a) {
                if ("value" === a.propertyName && te(qe)) {
                    var b = [];
                    ne(b, qe, a, xb(a));
                    Jb(re, b);
                }
            }
            function Ce(a, b, c) {
                "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
            }
            function De(a) {
                if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
            }
            function Ee(a, b) {
                if ("click" === a) return te(b);
            }
            function Fe(a, b) {
                if ("input" === a || "change" === a) return te(b);
            }
            function Ge(a, b) {
                return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
            }
            var He = "function" === typeof Object.is ? Object.is : Ge;
            function Ie(a, b) {
                if (He(a, b)) return !0;
                if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return !1;
                var c = Object.keys(a), d = Object.keys(b);
                if (c.length !== d.length) return !1;
                for (d = 0; d < c.length; d++) {
                    var e = c[d];
                    if (!ja.call(b, e) || !He(a[e], b[e])) return !1;
                }
                return !0;
            }
            function Je(a) {
                for (;a && a.firstChild; ) a = a.firstChild;
                return a;
            }
            function Ke(a, b) {
                var c = Je(a);
                a = 0;
                for (var d; c; ) {
                    if (3 === c.nodeType) {
                        d = a + c.textContent.length;
                        if (a <= b && d >= b) return {
                            node: c,
                            offset: b - a
                        };
                        a = d;
                    }
                    a: {
                        for (;c; ) {
                            if (c.nextSibling) {
                                c = c.nextSibling;
                                break a;
                            }
                            c = c.parentNode;
                        }
                        c = void 0;
                    }
                    c = Je(c);
                }
            }
            function Le(a, b) {
                return a && b ? a === b ? !0 : a && 3 === a.nodeType ? !1 : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : !1 : !1;
            }
            function Me() {
                for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
                    try {
                        var c = "string" === typeof b.contentWindow.location.href;
                    } catch (d) {
                        c = !1;
                    }
                    if (c) a = b.contentWindow; else break;
                    b = Xa(a.document);
                }
                return b;
            }
            function Ne(a) {
                var b = a && a.nodeName && a.nodeName.toLowerCase();
                return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
            }
            function Oe(a) {
                var b = Me(), c = a.focusedElem, d = a.selectionRange;
                if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
                    if (null !== d && Ne(c)) if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, 
                    c.selectionEnd = Math.min(a, c.value.length); else if (a = (b = c.ownerDocument || document) && b.defaultView || window, 
                    a.getSelection) {
                        a = a.getSelection();
                        var e = c.textContent.length, f = Math.min(d.start, e);
                        d = void 0 === d.end ? f : Math.min(d.end, e);
                        !a.extend && f > d && (e = d, d = f, f = e);
                        e = Ke(c, f);
                        var g = Ke(c, d);
                        e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), 
                        b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), 
                        a.addRange(b)));
                    }
                    b = [];
                    for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({
                        element: a,
                        left: a.scrollLeft,
                        top: a.scrollTop
                    });
                    "function" === typeof c.focus && c.focus();
                    for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
                }
            }
            var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = !1;
            function Ue(a, b, c) {
                var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
                Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = {
                    start: d.selectionStart,
                    end: d.selectionEnd
                } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), 
                d = {
                    anchorNode: d.anchorNode,
                    anchorOffset: d.anchorOffset,
                    focusNode: d.focusNode,
                    focusOffset: d.focusOffset
                }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), 
                a.push({
                    event: b,
                    listeners: d
                }), b.target = Qe)));
            }
            function Ve(a, b) {
                var c = {};
                c[a.toLowerCase()] = b.toLowerCase();
                c["Webkit" + a] = "webkit" + b;
                c["Moz" + a] = "moz" + b;
                return c;
            }
            var We = {
                animationend: Ve("Animation", "AnimationEnd"),
                animationiteration: Ve("Animation", "AnimationIteration"),
                animationstart: Ve("Animation", "AnimationStart"),
                transitionend: Ve("Transition", "TransitionEnd")
            }, Xe = {}, Ye = {};
            ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, 
            delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
            function Ze(a) {
                if (Xe[a]) return Xe[a];
                if (!We[a]) return a;
                var c, b = We[a];
                for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
                return a;
            }
            var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = new Map, ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
            function ff(a, b) {
                df.set(a, b);
                fa(b, [ a ]);
            }
            for (var gf = 0; gf < ef.length; gf++) {
                var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
                ff(jf, "on" + kf);
            }
            ff($e, "onAnimationEnd");
            ff(af, "onAnimationIteration");
            ff(bf, "onAnimationStart");
            ff("dblclick", "onDoubleClick");
            ff("focusin", "onFocus");
            ff("focusout", "onBlur");
            ff(cf, "onTransitionEnd");
            ha("onMouseEnter", [ "mouseout", "mouseover" ]);
            ha("onMouseLeave", [ "mouseout", "mouseover" ]);
            ha("onPointerEnter", [ "pointerout", "pointerover" ]);
            ha("onPointerLeave", [ "pointerout", "pointerover" ]);
            fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
            fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
            fa("onBeforeInput", [ "compositionend", "keypress", "textInput", "paste" ]);
            fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
            fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
            fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
            var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
            function nf(a, b, c) {
                var d = a.type || "unknown-event";
                a.currentTarget = c;
                Ub(d, b, void 0, a);
                a.currentTarget = null;
            }
            function se(a, b) {
                b = 0 !== (b & 4);
                for (var c = 0; c < a.length; c++) {
                    var d = a[c], e = d.event;
                    d = d.listeners;
                    a: {
                        var f = void 0;
                        if (b) for (var g = d.length - 1; 0 <= g; g--) {
                            var h = d[g], k = h.instance, l = h.currentTarget;
                            h = h.listener;
                            if (k !== f && e.isPropagationStopped()) break a;
                            nf(e, h, l);
                            f = k;
                        } else for (g = 0; g < d.length; g++) {
                            h = d[g];
                            k = h.instance;
                            l = h.currentTarget;
                            h = h.listener;
                            if (k !== f && e.isPropagationStopped()) break a;
                            nf(e, h, l);
                            f = k;
                        }
                    }
                }
                if (Qb) throw a = Rb, Qb = !1, Rb = null, a;
            }
            function D(a, b) {
                var c = b[of];
                void 0 === c && (c = b[of] = new Set);
                var d = a + "__bubble";
                c.has(d) || (pf(b, a, 2, !1), c.add(d));
            }
            function qf(a, b, c) {
                var d = 0;
                b && (d |= 4);
                pf(c, a, d, b);
            }
            var rf = "_reactListening" + Math.random().toString(36).slice(2);
            function sf(a) {
                if (!a[rf]) {
                    a[rf] = !0;
                    da.forEach(function(b) {
                        "selectionchange" !== b && (mf.has(b) || qf(b, !1, a), qf(b, !0, a));
                    });
                    var b = 9 === a.nodeType ? a : a.ownerDocument;
                    null === b || b[rf] || (b[rf] = !0, qf("selectionchange", !1, b));
                }
            }
            function pf(a, b, c, d) {
                switch (jd(b)) {
                  case 1:
                    var e = ed;
                    break;

                  case 4:
                    e = gd;
                    break;

                  default:
                    e = fd;
                }
                c = e.bind(null, b, c, a);
                e = void 0;
                !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = !0);
                d ? void 0 !== e ? a.addEventListener(b, c, {
                    capture: !0,
                    passive: e
                }) : a.addEventListener(b, c, !0) : void 0 !== e ? a.addEventListener(b, c, {
                    passive: e
                }) : a.addEventListener(b, c, !1);
            }
            function hd(a, b, c, d, e) {
                var f = d;
                if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (;;) {
                    if (null === d) return;
                    var g = d.tag;
                    if (3 === g || 4 === g) {
                        var h = d.stateNode.containerInfo;
                        if (h === e || 8 === h.nodeType && h.parentNode === e) break;
                        if (4 === g) for (g = d.return; null !== g; ) {
                            var k = g.tag;
                            if (3 === k || 4 === k) if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
                            g = g.return;
                        }
                        for (;null !== h; ) {
                            g = Wc(h);
                            if (null === g) return;
                            k = g.tag;
                            if (5 === k || 6 === k) {
                                d = f = g;
                                continue a;
                            }
                            h = h.parentNode;
                        }
                    }
                    d = d.return;
                }
                Jb(function() {
                    var d = f, e = xb(c), g = [];
                    a: {
                        var h = df.get(a);
                        if (void 0 !== h) {
                            var k = td, n = a;
                            switch (a) {
                              case "keypress":
                                if (0 === od(c)) break a;

                              case "keydown":
                              case "keyup":
                                k = Rd;
                                break;

                              case "focusin":
                                n = "focus";
                                k = Fd;
                                break;

                              case "focusout":
                                n = "blur";
                                k = Fd;
                                break;

                              case "beforeblur":
                              case "afterblur":
                                k = Fd;
                                break;

                              case "click":
                                if (2 === c.button) break a;

                              case "auxclick":
                              case "dblclick":
                              case "mousedown":
                              case "mousemove":
                              case "mouseup":
                              case "mouseout":
                              case "mouseover":
                              case "contextmenu":
                                k = Bd;
                                break;

                              case "drag":
                              case "dragend":
                              case "dragenter":
                              case "dragexit":
                              case "dragleave":
                              case "dragover":
                              case "dragstart":
                              case "drop":
                                k = Dd;
                                break;

                              case "touchcancel":
                              case "touchend":
                              case "touchmove":
                              case "touchstart":
                                k = Vd;
                                break;

                              case $e:
                              case af:
                              case bf:
                                k = Hd;
                                break;

                              case cf:
                                k = Xd;
                                break;

                              case "scroll":
                                k = vd;
                                break;

                              case "wheel":
                                k = Zd;
                                break;

                              case "copy":
                              case "cut":
                              case "paste":
                                k = Jd;
                                break;

                              case "gotpointercapture":
                              case "lostpointercapture":
                              case "pointercancel":
                              case "pointerdown":
                              case "pointermove":
                              case "pointerout":
                              case "pointerover":
                              case "pointerup":
                                k = Td;
                            }
                            var t = 0 !== (b & 4), J = !t && "scroll" === a, x = t ? null !== h ? h + "Capture" : null : h;
                            t = [];
                            for (var u, w = d; null !== w; ) {
                                u = w;
                                var F = u.stateNode;
                                5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t.push(tf(w, F, u))));
                                if (J) break;
                                w = w.return;
                            }
                            0 < t.length && (h = new k(h, n, null, c, e), g.push({
                                event: h,
                                listeners: t
                            }));
                        }
                    }
                    if (0 === (b & 7)) {
                        a: {
                            h = "mouseover" === a || "pointerover" === a;
                            k = "mouseout" === a || "pointerout" === a;
                            if (h && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
                            if (k || h) {
                                h = e.window === e ? e : (h = e.ownerDocument) ? h.defaultView || h.parentWindow : window;
                                if (k) {
                                    if (n = c.relatedTarget || c.toElement, k = d, n = n ? Wc(n) : null, null !== n && (J = Vb(n), 
                                    n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
                                } else k = null, n = d;
                                if (k !== n) {
                                    t = Bd;
                                    F = "onMouseLeave";
                                    x = "onMouseEnter";
                                    w = "mouse";
                                    if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x = "onPointerEnter", 
                                    w = "pointer";
                                    J = null == k ? h : ue(k);
                                    u = null == n ? h : ue(n);
                                    h = new t(F, w + "leave", k, c, e);
                                    h.target = J;
                                    h.relatedTarget = u;
                                    F = null;
                                    Wc(e) === d && (t = new t(x, w + "enter", n, c, e), t.target = u, t.relatedTarget = J, 
                                    F = t);
                                    J = F;
                                    if (k && n) b: {
                                        t = k;
                                        x = n;
                                        w = 0;
                                        for (u = t; u; u = vf(u)) w++;
                                        u = 0;
                                        for (F = x; F; F = vf(F)) u++;
                                        for (;0 < w - u; ) t = vf(t), w--;
                                        for (;0 < u - w; ) x = vf(x), u--;
                                        for (;w--; ) {
                                            if (t === x || null !== x && t === x.alternate) break b;
                                            t = vf(t);
                                            x = vf(x);
                                        }
                                        t = null;
                                    } else t = null;
                                    null !== k && wf(g, h, k, t, !1);
                                    null !== n && null !== J && wf(g, J, n, t, !0);
                                }
                            }
                        }
                        a: {
                            h = d ? ue(d) : window;
                            k = h.nodeName && h.nodeName.toLowerCase();
                            if ("select" === k || "input" === k && "file" === h.type) var na = ve; else if (me(h)) if (we) na = Fe; else {
                                na = De;
                                var xa = Ce;
                            } else (k = h.nodeName) && "input" === k.toLowerCase() && ("checkbox" === h.type || "radio" === h.type) && (na = Ee);
                            if (na && (na = na(a, d))) {
                                ne(g, na, c, e);
                                break a;
                            }
                            xa && xa(a, h, d);
                            "focusout" === a && (xa = h._wrapperState) && xa.controlled && "number" === h.type && cb(h, "number", h.value);
                        }
                        xa = d ? ue(d) : window;
                        switch (a) {
                          case "focusin":
                            if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d, Se = null;
                            break;

                          case "focusout":
                            Se = Re = Qe = null;
                            break;

                          case "mousedown":
                            Te = !0;
                            break;

                          case "contextmenu":
                          case "mouseup":
                          case "dragend":
                            Te = !1;
                            Ue(g, c, e);
                            break;

                          case "selectionchange":
                            if (Pe) break;

                          case "keydown":
                          case "keyup":
                            Ue(g, c, e);
                        }
                        var $a;
                        if (ae) b: {
                            switch (a) {
                              case "compositionstart":
                                var ba = "onCompositionStart";
                                break b;

                              case "compositionend":
                                ba = "onCompositionEnd";
                                break b;

                              case "compositionupdate":
                                ba = "onCompositionUpdate";
                                break b;
                            }
                            ba = void 0;
                        } else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
                        ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e, 
                        ld = "value" in kd ? kd.value : kd.textContent, ie = !0)), xa = oe(d, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e), 
                        g.push({
                            event: ba,
                            listeners: xa
                        }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
                        if ($a = ce ? je(a, c) : ke(a, c)) d = oe(d, "onBeforeInput"), 0 < d.length && (e = new Ld("onBeforeInput", "beforeinput", null, c, e), 
                        g.push({
                            event: e,
                            listeners: d
                        }), e.data = $a);
                    }
                    se(g, b);
                });
            }
            function tf(a, b, c) {
                return {
                    instance: a,
                    listener: b,
                    currentTarget: c
                };
            }
            function oe(a, b) {
                for (var c = b + "Capture", d = []; null !== a; ) {
                    var e = a, f = e.stateNode;
                    5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d.unshift(tf(a, f, e)), 
                    f = Kb(a, b), null != f && d.push(tf(a, f, e)));
                    a = a.return;
                }
                return d;
            }
            function vf(a) {
                if (null === a) return null;
                do {
                    a = a.return;
                } while (a && 5 !== a.tag);
                return a ? a : null;
            }
            function wf(a, b, c, d, e) {
                for (var f = b._reactName, g = []; null !== c && c !== d; ) {
                    var h = c, k = h.alternate, l = h.stateNode;
                    if (null !== k && k === d) break;
                    5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), 
                    null != k && g.push(tf(c, k, h))));
                    c = c.return;
                }
                0 !== g.length && a.push({
                    event: b,
                    listeners: g
                });
            }
            var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
            function zf(a) {
                return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
            }
            function Af(a, b, c) {
                b = zf(b);
                if (zf(a) !== b && c) throw Error(p(425));
            }
            function Bf() {}
            var Cf = null, Df = null;
            function Ef(a, b) {
                return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
            }
            var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
                return Hf.resolve(null).then(a).catch(If);
            } : Ff;
            function If(a) {
                setTimeout(function() {
                    throw a;
                });
            }
            function Kf(a, b) {
                var c = b, d = 0;
                do {
                    var e = c.nextSibling;
                    a.removeChild(c);
                    if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
                        if (0 === d) {
                            a.removeChild(e);
                            bd(b);
                            return;
                        }
                        d--;
                    } else "$" !== c && "$?" !== c && "$!" !== c || d++;
                    c = e;
                } while (c);
                bd(b);
            }
            function Lf(a) {
                for (;null != a; a = a.nextSibling) {
                    var b = a.nodeType;
                    if (1 === b || 3 === b) break;
                    if (8 === b) {
                        b = a.data;
                        if ("$" === b || "$!" === b || "$?" === b) break;
                        if ("/$" === b) return null;
                    }
                }
                return a;
            }
            function Mf(a) {
                a = a.previousSibling;
                for (var b = 0; a; ) {
                    if (8 === a.nodeType) {
                        var c = a.data;
                        if ("$" === c || "$!" === c || "$?" === c) {
                            if (0 === b) return a;
                            b--;
                        } else "/$" === c && b++;
                    }
                    a = a.previousSibling;
                }
                return null;
            }
            var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
            function Wc(a) {
                var b = a[Of];
                if (b) return b;
                for (var c = a.parentNode; c; ) {
                    if (b = c[uf] || c[Of]) {
                        c = b.alternate;
                        if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a; ) {
                            if (c = a[Of]) return c;
                            a = Mf(a);
                        }
                        return b;
                    }
                    a = c;
                    c = a.parentNode;
                }
                return null;
            }
            function Cb(a) {
                a = a[Of] || a[uf];
                return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
            }
            function ue(a) {
                if (5 === a.tag || 6 === a.tag) return a.stateNode;
                throw Error(p(33));
            }
            function Db(a) {
                return a[Pf] || null;
            }
            var Sf = [], Tf = -1;
            function Uf(a) {
                return {
                    current: a
                };
            }
            function E(a) {
                0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
            }
            function G(a, b) {
                Tf++;
                Sf[Tf] = a.current;
                a.current = b;
            }
            var Vf = {}, H = Uf(Vf), Wf = Uf(!1), Xf = Vf;
            function Yf(a, b) {
                var c = a.type.contextTypes;
                if (!c) return Vf;
                var d = a.stateNode;
                if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
                var f, e = {};
                for (f in c) e[f] = b[f];
                d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
                return e;
            }
            function Zf(a) {
                a = a.childContextTypes;
                return null !== a && void 0 !== a;
            }
            function $f() {
                E(Wf);
                E(H);
            }
            function ag(a, b, c) {
                if (H.current !== Vf) throw Error(p(168));
                G(H, b);
                G(Wf, c);
            }
            function bg(a, b, c) {
                var d = a.stateNode;
                b = b.childContextTypes;
                if ("function" !== typeof d.getChildContext) return c;
                d = d.getChildContext();
                for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
                return A({}, c, d);
            }
            function cg(a) {
                a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
                Xf = H.current;
                G(H, a);
                G(Wf, Wf.current);
                return !0;
            }
            function dg(a, b, c) {
                var d = a.stateNode;
                if (!d) throw Error(p(169));
                c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), 
                G(H, a)) : E(Wf);
                G(Wf, c);
            }
            var eg = null, fg = !1, gg = !1;
            function hg(a) {
                null === eg ? eg = [ a ] : eg.push(a);
            }
            function ig(a) {
                fg = !0;
                hg(a);
            }
            function jg() {
                if (!gg && null !== eg) {
                    gg = !0;
                    var a = 0, b = C;
                    try {
                        var c = eg;
                        for (C = 1; a < c.length; a++) {
                            var d = c[a];
                            do {
                                d = d(!0);
                            } while (null !== d);
                        }
                        eg = null;
                        fg = !1;
                    } catch (e) {
                        throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
                    } finally {
                        C = b, gg = !1;
                    }
                }
                return null;
            }
            var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
            function tg(a, b) {
                kg[lg++] = ng;
                kg[lg++] = mg;
                mg = a;
                ng = b;
            }
            function ug(a, b, c) {
                og[pg++] = rg;
                og[pg++] = sg;
                og[pg++] = qg;
                qg = a;
                var d = rg;
                a = sg;
                var e = 32 - oc(d) - 1;
                d &= ~(1 << e);
                c += 1;
                var f = 32 - oc(b) + e;
                if (30 < f) {
                    var g = e - e % 5;
                    f = (d & (1 << g) - 1).toString(32);
                    d >>= g;
                    e -= g;
                    rg = 1 << 32 - oc(b) + e | c << e | d;
                    sg = f + a;
                } else rg = 1 << f | c << e | d, sg = a;
            }
            function vg(a) {
                null !== a.return && (tg(a, 1), ug(a, 1, 0));
            }
            function wg(a) {
                for (;a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
                for (;a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], 
                og[pg] = null;
            }
            var xg = null, yg = null, I = !1, zg = null;
            function Ag(a, b) {
                var c = Bg(5, null, null, 0);
                c.elementType = "DELETED";
                c.stateNode = b;
                c.return = a;
                b = a.deletions;
                null === b ? (a.deletions = [ c ], a.flags |= 16) : b.push(c);
            }
            function Cg(a, b) {
                switch (a.tag) {
                  case 5:
                    var c = a.type;
                    b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
                    return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), !0) : !1;

                  case 6:
                    return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, 
                    xg = a, yg = null, !0) : !1;

                  case 13:
                    return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? {
                        id: rg,
                        overflow: sg
                    } : null, a.memoizedState = {
                        dehydrated: b,
                        treeContext: c,
                        retryLane: 1073741824
                    }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, 
                    yg = null, !0) : !1;

                  default:
                    return !1;
                }
            }
            function Dg(a) {
                return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
            }
            function Eg(a) {
                if (I) {
                    var b = yg;
                    if (b) {
                        var c = b;
                        if (!Cg(a, b)) {
                            if (Dg(a)) throw Error(p(418));
                            b = Lf(c.nextSibling);
                            var d = xg;
                            b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = !1, xg = a);
                        }
                    } else {
                        if (Dg(a)) throw Error(p(418));
                        a.flags = a.flags & -4097 | 2;
                        I = !1;
                        xg = a;
                    }
                }
            }
            function Fg(a) {
                for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
                xg = a;
            }
            function Gg(a) {
                if (a !== xg) return !1;
                if (!I) return Fg(a), I = !0, !1;
                var b;
                (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
                if (b && (b = yg)) {
                    if (Dg(a)) throw Hg(), Error(p(418));
                    for (;b; ) Ag(a, b), b = Lf(b.nextSibling);
                }
                Fg(a);
                if (13 === a.tag) {
                    a = a.memoizedState;
                    a = null !== a ? a.dehydrated : null;
                    if (!a) throw Error(p(317));
                    a: {
                        a = a.nextSibling;
                        for (b = 0; a; ) {
                            if (8 === a.nodeType) {
                                var c = a.data;
                                if ("/$" === c) {
                                    if (0 === b) {
                                        yg = Lf(a.nextSibling);
                                        break a;
                                    }
                                    b--;
                                } else "$" !== c && "$!" !== c && "$?" !== c || b++;
                            }
                            a = a.nextSibling;
                        }
                        yg = null;
                    }
                } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
                return !0;
            }
            function Hg() {
                for (var a = yg; a; ) a = Lf(a.nextSibling);
            }
            function Ig() {
                yg = xg = null;
                I = !1;
            }
            function Jg(a) {
                null === zg ? zg = [ a ] : zg.push(a);
            }
            var Kg = ua.ReactCurrentBatchConfig;
            function Lg(a, b, c) {
                a = c.ref;
                if (null !== a && "function" !== typeof a && "object" !== typeof a) {
                    if (c._owner) {
                        c = c._owner;
                        if (c) {
                            if (1 !== c.tag) throw Error(p(309));
                            var d = c.stateNode;
                        }
                        if (!d) throw Error(p(147, a));
                        var e = d, f = "" + a;
                        if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
                        b = function(a) {
                            var b = e.refs;
                            null === a ? delete b[f] : b[f] = a;
                        };
                        b._stringRef = f;
                        return b;
                    }
                    if ("string" !== typeof a) throw Error(p(284));
                    if (!c._owner) throw Error(p(290, a));
                }
                return a;
            }
            function Mg(a, b) {
                a = Object.prototype.toString.call(b);
                throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
            }
            function Ng(a) {
                var b = a._init;
                return b(a._payload);
            }
            function Og(a) {
                function b(b, c) {
                    if (a) {
                        var d = b.deletions;
                        null === d ? (b.deletions = [ c ], b.flags |= 16) : d.push(c);
                    }
                }
                function c(c, d) {
                    if (!a) return null;
                    for (;null !== d; ) b(c, d), d = d.sibling;
                    return null;
                }
                function d(a, b) {
                    for (a = new Map; null !== b; ) null !== b.key ? a.set(b.key, b) : a.set(b.index, b), 
                    b = b.sibling;
                    return a;
                }
                function e(a, b) {
                    a = Pg(a, b);
                    a.index = 0;
                    a.sibling = null;
                    return a;
                }
                function f(b, c, d) {
                    b.index = d;
                    if (!a) return b.flags |= 1048576, c;
                    d = b.alternate;
                    if (null !== d) return d = d.index, d < c ? (b.flags |= 2, c) : d;
                    b.flags |= 2;
                    return c;
                }
                function g(b) {
                    a && null === b.alternate && (b.flags |= 2);
                    return b;
                }
                function h(a, b, c, d) {
                    if (null === b || 6 !== b.tag) return b = Qg(c, a.mode, d), b.return = a, b;
                    b = e(b, c);
                    b.return = a;
                    return b;
                }
                function k(a, b, c, d) {
                    var f = c.type;
                    if (f === ya) return m(a, b, c.props.children, d, c.key);
                    if (null !== b && (b.elementType === f || "object" === typeof f && null !== f && f.$$typeof === Ha && Ng(f) === b.type)) return d = e(b, c.props), 
                    d.ref = Lg(a, b, c), d.return = a, d;
                    d = Rg(c.type, c.key, c.props, null, a.mode, d);
                    d.ref = Lg(a, b, c);
                    d.return = a;
                    return d;
                }
                function l(a, b, c, d) {
                    if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = Sg(c, a.mode, d), 
                    b.return = a, b;
                    b = e(b, c.children || []);
                    b.return = a;
                    return b;
                }
                function m(a, b, c, d, f) {
                    if (null === b || 7 !== b.tag) return b = Tg(c, a.mode, d, f), b.return = a, b;
                    b = e(b, c);
                    b.return = a;
                    return b;
                }
                function q(a, b, c) {
                    if ("string" === typeof b && "" !== b || "number" === typeof b) return b = Qg("" + b, a.mode, c), 
                    b.return = a, b;
                    if ("object" === typeof b && null !== b) {
                        switch (b.$$typeof) {
                          case va:
                            return c = Rg(b.type, b.key, b.props, null, a.mode, c), c.ref = Lg(a, null, b), 
                            c.return = a, c;

                          case wa:
                            return b = Sg(b, a.mode, c), b.return = a, b;

                          case Ha:
                            var d = b._init;
                            return q(a, d(b._payload), c);
                        }
                        if (eb(b) || Ka(b)) return b = Tg(b, a.mode, c, null), b.return = a, b;
                        Mg(a, b);
                    }
                    return null;
                }
                function r(a, b, c, d) {
                    var e = null !== b ? b.key : null;
                    if ("string" === typeof c && "" !== c || "number" === typeof c) return null !== e ? null : h(a, b, "" + c, d);
                    if ("object" === typeof c && null !== c) {
                        switch (c.$$typeof) {
                          case va:
                            return c.key === e ? k(a, b, c, d) : null;

                          case wa:
                            return c.key === e ? l(a, b, c, d) : null;

                          case Ha:
                            return e = c._init, r(a, b, e(c._payload), d);
                        }
                        if (eb(c) || Ka(c)) return null !== e ? null : m(a, b, c, d, null);
                        Mg(a, c);
                    }
                    return null;
                }
                function y(a, b, c, d, e) {
                    if ("string" === typeof d && "" !== d || "number" === typeof d) return a = a.get(c) || null, 
                    h(b, a, "" + d, e);
                    if ("object" === typeof d && null !== d) {
                        switch (d.$$typeof) {
                          case va:
                            return a = a.get(null === d.key ? c : d.key) || null, k(b, a, d, e);

                          case wa:
                            return a = a.get(null === d.key ? c : d.key) || null, l(b, a, d, e);

                          case Ha:
                            var f = d._init;
                            return y(a, b, c, f(d._payload), e);
                        }
                        if (eb(d) || Ka(d)) return a = a.get(c) || null, m(b, a, d, e, null);
                        Mg(b, d);
                    }
                    return null;
                }
                function n(e, g, h, k) {
                    for (var l = null, m = null, u = g, w = g = 0, x = null; null !== u && w < h.length; w++) {
                        u.index > w ? (x = u, u = null) : x = u.sibling;
                        var n = r(e, u, h[w], k);
                        if (null === n) {
                            null === u && (u = x);
                            break;
                        }
                        a && u && null === n.alternate && b(e, u);
                        g = f(n, g, w);
                        null === m ? l = n : m.sibling = n;
                        m = n;
                        u = x;
                    }
                    if (w === h.length) return c(e, u), I && tg(e, w), l;
                    if (null === u) {
                        for (;w < h.length; w++) u = q(e, h[w], k), null !== u && (g = f(u, g, w), null === m ? l = u : m.sibling = u, 
                        m = u);
                        I && tg(e, w);
                        return l;
                    }
                    for (u = d(e, u); w < h.length; w++) x = y(u, e, w, h[w], k), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), 
                    g = f(x, g, w), null === m ? l = x : m.sibling = x, m = x);
                    a && u.forEach(function(a) {
                        return b(e, a);
                    });
                    I && tg(e, w);
                    return l;
                }
                function t(e, g, h, k) {
                    var l = Ka(h);
                    if ("function" !== typeof l) throw Error(p(150));
                    h = l.call(h);
                    if (null == h) throw Error(p(151));
                    for (var u = l = null, m = g, w = g = 0, x = null, n = h.next(); null !== m && !n.done; w++, 
                    n = h.next()) {
                        m.index > w ? (x = m, m = null) : x = m.sibling;
                        var t = r(e, m, n.value, k);
                        if (null === t) {
                            null === m && (m = x);
                            break;
                        }
                        a && m && null === t.alternate && b(e, m);
                        g = f(t, g, w);
                        null === u ? l = t : u.sibling = t;
                        u = t;
                        m = x;
                    }
                    if (n.done) return c(e, m), I && tg(e, w), l;
                    if (null === m) {
                        for (;!n.done; w++, n = h.next()) n = q(e, n.value, k), null !== n && (g = f(n, g, w), 
                        null === u ? l = n : u.sibling = n, u = n);
                        I && tg(e, w);
                        return l;
                    }
                    for (m = d(e, m); !n.done; w++, n = h.next()) n = y(m, e, w, n.value, k), null !== n && (a && null !== n.alternate && m.delete(null === n.key ? w : n.key), 
                    g = f(n, g, w), null === u ? l = n : u.sibling = n, u = n);
                    a && m.forEach(function(a) {
                        return b(e, a);
                    });
                    I && tg(e, w);
                    return l;
                }
                function J(a, d, f, h) {
                    "object" === typeof f && null !== f && f.type === ya && null === f.key && (f = f.props.children);
                    if ("object" === typeof f && null !== f) {
                        switch (f.$$typeof) {
                          case va:
                            a: {
                                for (var k = f.key, l = d; null !== l; ) {
                                    if (l.key === k) {
                                        k = f.type;
                                        if (k === ya) {
                                            if (7 === l.tag) {
                                                c(a, l.sibling);
                                                d = e(l, f.props.children);
                                                d.return = a;
                                                a = d;
                                                break a;
                                            }
                                        } else if (l.elementType === k || "object" === typeof k && null !== k && k.$$typeof === Ha && Ng(k) === l.type) {
                                            c(a, l.sibling);
                                            d = e(l, f.props);
                                            d.ref = Lg(a, l, f);
                                            d.return = a;
                                            a = d;
                                            break a;
                                        }
                                        c(a, l);
                                        break;
                                    } else b(a, l);
                                    l = l.sibling;
                                }
                                f.type === ya ? (d = Tg(f.props.children, a.mode, h, f.key), d.return = a, a = d) : (h = Rg(f.type, f.key, f.props, null, a.mode, h), 
                                h.ref = Lg(a, d, f), h.return = a, a = h);
                            }
                            return g(a);

                          case wa:
                            a: {
                                for (l = f.key; null !== d; ) {
                                    if (d.key === l) if (4 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {
                                        c(a, d.sibling);
                                        d = e(d, f.children || []);
                                        d.return = a;
                                        a = d;
                                        break a;
                                    } else {
                                        c(a, d);
                                        break;
                                    } else b(a, d);
                                    d = d.sibling;
                                }
                                d = Sg(f, a.mode, h);
                                d.return = a;
                                a = d;
                            }
                            return g(a);

                          case Ha:
                            return l = f._init, J(a, d, l(f._payload), h);
                        }
                        if (eb(f)) return n(a, d, f, h);
                        if (Ka(f)) return t(a, d, f, h);
                        Mg(a, f);
                    }
                    return "string" === typeof f && "" !== f || "number" === typeof f ? (f = "" + f, 
                    null !== d && 6 === d.tag ? (c(a, d.sibling), d = e(d, f), d.return = a, a = d) : (c(a, d), 
                    d = Qg(f, a.mode, h), d.return = a, a = d), g(a)) : c(a, d);
                }
                return J;
            }
            var Ug = Og(!0), Vg = Og(!1), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
            function $g() {
                Zg = Yg = Xg = null;
            }
            function ah(a) {
                var b = Wg.current;
                E(Wg);
                a._currentValue = b;
            }
            function bh(a, b, c) {
                for (;null !== a; ) {
                    var d = a.alternate;
                    (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
                    if (a === c) break;
                    a = a.return;
                }
            }
            function ch(a, b) {
                Xg = a;
                Zg = Yg = null;
                a = a.dependencies;
                null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (dh = !0), a.firstContext = null);
            }
            function eh(a) {
                var b = a._currentValue;
                if (Zg !== a) if (a = {
                    context: a,
                    memoizedValue: b,
                    next: null
                }, null === Yg) {
                    if (null === Xg) throw Error(p(308));
                    Yg = a;
                    Xg.dependencies = {
                        lanes: 0,
                        firstContext: a
                    };
                } else Yg = Yg.next = a;
                return b;
            }
            var fh = null;
            function gh(a) {
                null === fh ? fh = [ a ] : fh.push(a);
            }
            function hh(a, b, c, d) {
                var e = b.interleaved;
                null === e ? (c.next = c, gh(b)) : (c.next = e.next, e.next = c);
                b.interleaved = c;
                return ih(a, d);
            }
            function ih(a, b) {
                a.lanes |= b;
                var c = a.alternate;
                null !== c && (c.lanes |= b);
                c = a;
                for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), 
                c = a, a = a.return;
                return 3 === c.tag ? c.stateNode : null;
            }
            var jh = !1;
            function kh(a) {
                a.updateQueue = {
                    baseState: a.memoizedState,
                    firstBaseUpdate: null,
                    lastBaseUpdate: null,
                    shared: {
                        pending: null,
                        interleaved: null,
                        lanes: 0
                    },
                    effects: null
                };
            }
            function lh(a, b) {
                a = a.updateQueue;
                b.updateQueue === a && (b.updateQueue = {
                    baseState: a.baseState,
                    firstBaseUpdate: a.firstBaseUpdate,
                    lastBaseUpdate: a.lastBaseUpdate,
                    shared: a.shared,
                    effects: a.effects
                });
            }
            function mh(a, b) {
                return {
                    eventTime: a,
                    lane: b,
                    tag: 0,
                    payload: null,
                    callback: null,
                    next: null
                };
            }
            function nh(a, b, c) {
                var d = a.updateQueue;
                if (null === d) return null;
                d = d.shared;
                if (0 !== (K & 2)) {
                    var e = d.pending;
                    null === e ? b.next = b : (b.next = e.next, e.next = b);
                    d.pending = b;
                    return ih(a, c);
                }
                e = d.interleaved;
                null === e ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b);
                d.interleaved = b;
                return ih(a, c);
            }
            function oh(a, b, c) {
                b = b.updateQueue;
                if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
                    var d = b.lanes;
                    d &= a.pendingLanes;
                    c |= d;
                    b.lanes = c;
                    Cc(a, c);
                }
            }
            function ph(a, b) {
                var c = a.updateQueue, d = a.alternate;
                if (null !== d && (d = d.updateQueue, c === d)) {
                    var e = null, f = null;
                    c = c.firstBaseUpdate;
                    if (null !== c) {
                        do {
                            var g = {
                                eventTime: c.eventTime,
                                lane: c.lane,
                                tag: c.tag,
                                payload: c.payload,
                                callback: c.callback,
                                next: null
                            };
                            null === f ? e = f = g : f = f.next = g;
                            c = c.next;
                        } while (null !== c);
                        null === f ? e = f = b : f = f.next = b;
                    } else e = f = b;
                    c = {
                        baseState: d.baseState,
                        firstBaseUpdate: e,
                        lastBaseUpdate: f,
                        shared: d.shared,
                        effects: d.effects
                    };
                    a.updateQueue = c;
                    return;
                }
                a = c.lastBaseUpdate;
                null === a ? c.firstBaseUpdate = b : a.next = b;
                c.lastBaseUpdate = b;
            }
            function qh(a, b, c, d) {
                var e = a.updateQueue;
                jh = !1;
                var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
                if (null !== h) {
                    e.shared.pending = null;
                    var k = h, l = k.next;
                    k.next = null;
                    null === g ? f = l : g.next = l;
                    g = k;
                    var m = a.alternate;
                    null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, 
                    m.lastBaseUpdate = k));
                }
                if (null !== f) {
                    var q = e.baseState;
                    g = 0;
                    m = l = k = null;
                    h = f;
                    do {
                        var r = h.lane, y = h.eventTime;
                        if ((d & r) === r) {
                            null !== m && (m = m.next = {
                                eventTime: y,
                                lane: 0,
                                tag: h.tag,
                                payload: h.payload,
                                callback: h.callback,
                                next: null
                            });
                            a: {
                                var n = a, t = h;
                                r = b;
                                y = c;
                                switch (t.tag) {
                                  case 1:
                                    n = t.payload;
                                    if ("function" === typeof n) {
                                        q = n.call(y, q, r);
                                        break a;
                                    }
                                    q = n;
                                    break a;

                                  case 3:
                                    n.flags = n.flags & -65537 | 128;

                                  case 0:
                                    n = t.payload;
                                    r = "function" === typeof n ? n.call(y, q, r) : n;
                                    if (null === r || void 0 === r) break a;
                                    q = A({}, q, r);
                                    break a;

                                  case 2:
                                    jh = !0;
                                }
                            }
                            null !== h.callback && 0 !== h.lane && (a.flags |= 64, r = e.effects, null === r ? e.effects = [ h ] : r.push(h));
                        } else y = {
                            eventTime: y,
                            lane: r,
                            tag: h.tag,
                            payload: h.payload,
                            callback: h.callback,
                            next: null
                        }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r;
                        h = h.next;
                        if (null === h) if (h = e.shared.pending, null === h) break; else r = h, h = r.next, 
                        r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
                    } while (1);
                    null === m && (k = q);
                    e.baseState = k;
                    e.firstBaseUpdate = l;
                    e.lastBaseUpdate = m;
                    b = e.shared.interleaved;
                    if (null !== b) {
                        e = b;
                        do {
                            g |= e.lane, e = e.next;
                        } while (e !== b);
                    } else null === f && (e.shared.lanes = 0);
                    rh |= g;
                    a.lanes = g;
                    a.memoizedState = q;
                }
            }
            function sh(a, b, c) {
                a = b.effects;
                b.effects = null;
                if (null !== a) for (b = 0; b < a.length; b++) {
                    var d = a[b], e = d.callback;
                    if (null !== e) {
                        d.callback = null;
                        d = c;
                        if ("function" !== typeof e) throw Error(p(191, e));
                        e.call(d);
                    }
                }
            }
            var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
            function xh(a) {
                if (a === th) throw Error(p(174));
                return a;
            }
            function yh(a, b) {
                G(wh, b);
                G(vh, a);
                G(uh, th);
                a = b.nodeType;
                switch (a) {
                  case 9:
                  case 11:
                    b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
                    break;

                  default:
                    a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
                }
                E(uh);
                G(uh, b);
            }
            function zh() {
                E(uh);
                E(vh);
                E(wh);
            }
            function Ah(a) {
                xh(wh.current);
                var b = xh(uh.current);
                var c = lb(b, a.type);
                b !== c && (G(vh, a), G(uh, c));
            }
            function Bh(a) {
                vh.current === a && (E(uh), E(vh));
            }
            var L = Uf(0);
            function Ch(a) {
                for (var b = a; null !== b; ) {
                    if (13 === b.tag) {
                        var c = b.memoizedState;
                        if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
                    } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
                        if (0 !== (b.flags & 128)) return b;
                    } else if (null !== b.child) {
                        b.child.return = b;
                        b = b.child;
                        continue;
                    }
                    if (b === a) break;
                    for (;null === b.sibling; ) {
                        if (null === b.return || b.return === a) return null;
                        b = b.return;
                    }
                    b.sibling.return = b.return;
                    b = b.sibling;
                }
                return null;
            }
            var Dh = [];
            function Eh() {
                for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
                Dh.length = 0;
            }
            var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = !1, Jh = !1, Kh = 0, Lh = 0;
            function P() {
                throw Error(p(321));
            }
            function Mh(a, b) {
                if (null === b) return !1;
                for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return !1;
                return !0;
            }
            function Nh(a, b, c, d, e, f) {
                Hh = f;
                M = b;
                b.memoizedState = null;
                b.updateQueue = null;
                b.lanes = 0;
                Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
                a = c(d, e);
                if (Jh) {
                    f = 0;
                    do {
                        Jh = !1;
                        Kh = 0;
                        if (25 <= f) throw Error(p(301));
                        f += 1;
                        O = N = null;
                        b.updateQueue = null;
                        Fh.current = Qh;
                        a = c(d, e);
                    } while (Jh);
                }
                Fh.current = Rh;
                b = null !== N && null !== N.next;
                Hh = 0;
                O = N = M = null;
                Ih = !1;
                if (b) throw Error(p(300));
                return a;
            }
            function Sh() {
                var a = 0 !== Kh;
                Kh = 0;
                return a;
            }
            function Th() {
                var a = {
                    memoizedState: null,
                    baseState: null,
                    baseQueue: null,
                    queue: null,
                    next: null
                };
                null === O ? M.memoizedState = O = a : O = O.next = a;
                return O;
            }
            function Uh() {
                if (null === N) {
                    var a = M.alternate;
                    a = null !== a ? a.memoizedState : null;
                } else a = N.next;
                var b = null === O ? M.memoizedState : O.next;
                if (null !== b) O = b, N = a; else {
                    if (null === a) throw Error(p(310));
                    N = a;
                    a = {
                        memoizedState: N.memoizedState,
                        baseState: N.baseState,
                        baseQueue: N.baseQueue,
                        queue: N.queue,
                        next: null
                    };
                    null === O ? M.memoizedState = O = a : O = O.next = a;
                }
                return O;
            }
            function Vh(a, b) {
                return "function" === typeof b ? b(a) : b;
            }
            function Wh(a) {
                var b = Uh(), c = b.queue;
                if (null === c) throw Error(p(311));
                c.lastRenderedReducer = a;
                var d = N, e = d.baseQueue, f = c.pending;
                if (null !== f) {
                    if (null !== e) {
                        var g = e.next;
                        e.next = f.next;
                        f.next = g;
                    }
                    d.baseQueue = e = f;
                    c.pending = null;
                }
                if (null !== e) {
                    f = e.next;
                    d = d.baseState;
                    var h = g = null, k = null, l = f;
                    do {
                        var m = l.lane;
                        if ((Hh & m) === m) null !== k && (k = k.next = {
                            lane: 0,
                            action: l.action,
                            hasEagerState: l.hasEagerState,
                            eagerState: l.eagerState,
                            next: null
                        }), d = l.hasEagerState ? l.eagerState : a(d, l.action); else {
                            var q = {
                                lane: m,
                                action: l.action,
                                hasEagerState: l.hasEagerState,
                                eagerState: l.eagerState,
                                next: null
                            };
                            null === k ? (h = k = q, g = d) : k = k.next = q;
                            M.lanes |= m;
                            rh |= m;
                        }
                        l = l.next;
                    } while (null !== l && l !== f);
                    null === k ? g = d : k.next = h;
                    He(d, b.memoizedState) || (dh = !0);
                    b.memoizedState = d;
                    b.baseState = g;
                    b.baseQueue = k;
                    c.lastRenderedState = d;
                }
                a = c.interleaved;
                if (null !== a) {
                    e = a;
                    do {
                        f = e.lane, M.lanes |= f, rh |= f, e = e.next;
                    } while (e !== a);
                } else null === e && (c.lanes = 0);
                return [ b.memoizedState, c.dispatch ];
            }
            function Xh(a) {
                var b = Uh(), c = b.queue;
                if (null === c) throw Error(p(311));
                c.lastRenderedReducer = a;
                var d = c.dispatch, e = c.pending, f = b.memoizedState;
                if (null !== e) {
                    c.pending = null;
                    var g = e = e.next;
                    do {
                        f = a(f, g.action), g = g.next;
                    } while (g !== e);
                    He(f, b.memoizedState) || (dh = !0);
                    b.memoizedState = f;
                    null === b.baseQueue && (b.baseState = f);
                    c.lastRenderedState = f;
                }
                return [ f, d ];
            }
            function Yh() {}
            function Zh(a, b) {
                var c = M, d = Uh(), e = b(), f = !He(d.memoizedState, e);
                f && (d.memoizedState = e, dh = !0);
                d = d.queue;
                $h(ai.bind(null, c, d, a), [ a ]);
                if (d.getSnapshot !== b || f || null !== O && O.memoizedState.tag & 1) {
                    c.flags |= 2048;
                    bi(9, ci.bind(null, c, d, e, b), void 0, null);
                    if (null === Q) throw Error(p(349));
                    0 !== (Hh & 30) || di(c, b, e);
                }
                return e;
            }
            function di(a, b, c) {
                a.flags |= 16384;
                a = {
                    getSnapshot: b,
                    value: c
                };
                b = M.updateQueue;
                null === b ? (b = {
                    lastEffect: null,
                    stores: null
                }, M.updateQueue = b, b.stores = [ a ]) : (c = b.stores, null === c ? b.stores = [ a ] : c.push(a));
            }
            function ci(a, b, c, d) {
                b.value = c;
                b.getSnapshot = d;
                ei(b) && fi(a);
            }
            function ai(a, b, c) {
                return c(function() {
                    ei(b) && fi(a);
                });
            }
            function ei(a) {
                var b = a.getSnapshot;
                a = a.value;
                try {
                    var c = b();
                    return !He(a, c);
                } catch (d) {
                    return !0;
                }
            }
            function fi(a) {
                var b = ih(a, 1);
                null !== b && gi(b, a, 1, -1);
            }
            function hi(a) {
                var b = Th();
                "function" === typeof a && (a = a());
                b.memoizedState = b.baseState = a;
                a = {
                    pending: null,
                    interleaved: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: Vh,
                    lastRenderedState: a
                };
                b.queue = a;
                a = a.dispatch = ii.bind(null, M, a);
                return [ b.memoizedState, a ];
            }
            function bi(a, b, c, d) {
                a = {
                    tag: a,
                    create: b,
                    destroy: c,
                    deps: d,
                    next: null
                };
                b = M.updateQueue;
                null === b ? (b = {
                    lastEffect: null,
                    stores: null
                }, M.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, 
                c.next = a, a.next = d, b.lastEffect = a));
                return a;
            }
            function ji() {
                return Uh().memoizedState;
            }
            function ki(a, b, c, d) {
                var e = Th();
                M.flags |= a;
                e.memoizedState = bi(1 | b, c, void 0, void 0 === d ? null : d);
            }
            function li(a, b, c, d) {
                var e = Uh();
                d = void 0 === d ? null : d;
                var f = void 0;
                if (null !== N) {
                    var g = N.memoizedState;
                    f = g.destroy;
                    if (null !== d && Mh(d, g.deps)) {
                        e.memoizedState = bi(b, c, f, d);
                        return;
                    }
                }
                M.flags |= a;
                e.memoizedState = bi(1 | b, c, f, d);
            }
            function mi(a, b) {
                return ki(8390656, 8, a, b);
            }
            function $h(a, b) {
                return li(2048, 8, a, b);
            }
            function ni(a, b) {
                return li(4, 2, a, b);
            }
            function oi(a, b) {
                return li(4, 4, a, b);
            }
            function pi(a, b) {
                if ("function" === typeof b) return a = a(), b(a), function() {
                    b(null);
                };
                if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
                    b.current = null;
                };
            }
            function qi(a, b, c) {
                c = null !== c && void 0 !== c ? c.concat([ a ]) : null;
                return li(4, 4, pi.bind(null, b, a), c);
            }
            function ri() {}
            function si(a, b) {
                var c = Uh();
                b = void 0 === b ? null : b;
                var d = c.memoizedState;
                if (null !== d && null !== b && Mh(b, d[1])) return d[0];
                c.memoizedState = [ a, b ];
                return a;
            }
            function ti(a, b) {
                var c = Uh();
                b = void 0 === b ? null : b;
                var d = c.memoizedState;
                if (null !== d && null !== b && Mh(b, d[1])) return d[0];
                a = a();
                c.memoizedState = [ a, b ];
                return a;
            }
            function ui(a, b, c) {
                if (0 === (Hh & 21)) return a.baseState && (a.baseState = !1, dh = !0), a.memoizedState = c;
                He(c, b) || (c = yc(), M.lanes |= c, rh |= c, a.baseState = !0);
                return b;
            }
            function vi(a, b) {
                var c = C;
                C = 0 !== c && 4 > c ? c : 4;
                a(!0);
                var d = Gh.transition;
                Gh.transition = {};
                try {
                    a(!1), b();
                } finally {
                    C = c, Gh.transition = d;
                }
            }
            function wi() {
                return Uh().memoizedState;
            }
            function xi(a, b, c) {
                var d = yi(a);
                c = {
                    lane: d,
                    action: c,
                    hasEagerState: !1,
                    eagerState: null,
                    next: null
                };
                if (zi(a)) Ai(b, c); else if (c = hh(a, b, c, d), null !== c) {
                    var e = R();
                    gi(c, a, d, e);
                    Bi(c, b, d);
                }
            }
            function ii(a, b, c) {
                var d = yi(a), e = {
                    lane: d,
                    action: c,
                    hasEagerState: !1,
                    eagerState: null,
                    next: null
                };
                if (zi(a)) Ai(b, e); else {
                    var f = a.alternate;
                    if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, 
                    null !== f)) try {
                        var g = b.lastRenderedState, h = f(g, c);
                        e.hasEagerState = !0;
                        e.eagerState = h;
                        if (He(h, g)) {
                            var k = b.interleaved;
                            null === k ? (e.next = e, gh(b)) : (e.next = k.next, k.next = e);
                            b.interleaved = e;
                            return;
                        }
                    } catch (l) {}
                    c = hh(a, b, e, d);
                    null !== c && (e = R(), gi(c, a, d, e), Bi(c, b, d));
                }
            }
            function zi(a) {
                var b = a.alternate;
                return a === M || null !== b && b === M;
            }
            function Ai(a, b) {
                Jh = Ih = !0;
                var c = a.pending;
                null === c ? b.next = b : (b.next = c.next, c.next = b);
                a.pending = b;
            }
            function Bi(a, b, c) {
                if (0 !== (c & 4194240)) {
                    var d = b.lanes;
                    d &= a.pendingLanes;
                    c |= d;
                    b.lanes = c;
                    Cc(a, c);
                }
            }
            var Rh = {
                readContext: eh,
                useCallback: P,
                useContext: P,
                useEffect: P,
                useImperativeHandle: P,
                useInsertionEffect: P,
                useLayoutEffect: P,
                useMemo: P,
                useReducer: P,
                useRef: P,
                useState: P,
                useDebugValue: P,
                useDeferredValue: P,
                useTransition: P,
                useMutableSource: P,
                useSyncExternalStore: P,
                useId: P,
                unstable_isNewReconciler: !1
            }, Oh = {
                readContext: eh,
                useCallback: function(a, b) {
                    Th().memoizedState = [ a, void 0 === b ? null : b ];
                    return a;
                },
                useContext: eh,
                useEffect: mi,
                useImperativeHandle: function(a, b, c) {
                    c = null !== c && void 0 !== c ? c.concat([ a ]) : null;
                    return ki(4194308, 4, pi.bind(null, b, a), c);
                },
                useLayoutEffect: function(a, b) {
                    return ki(4194308, 4, a, b);
                },
                useInsertionEffect: function(a, b) {
                    return ki(4, 2, a, b);
                },
                useMemo: function(a, b) {
                    var c = Th();
                    b = void 0 === b ? null : b;
                    a = a();
                    c.memoizedState = [ a, b ];
                    return a;
                },
                useReducer: function(a, b, c) {
                    var d = Th();
                    b = void 0 !== c ? c(b) : b;
                    d.memoizedState = d.baseState = b;
                    a = {
                        pending: null,
                        interleaved: null,
                        lanes: 0,
                        dispatch: null,
                        lastRenderedReducer: a,
                        lastRenderedState: b
                    };
                    d.queue = a;
                    a = a.dispatch = xi.bind(null, M, a);
                    return [ d.memoizedState, a ];
                },
                useRef: function(a) {
                    var b = Th();
                    a = {
                        current: a
                    };
                    return b.memoizedState = a;
                },
                useState: hi,
                useDebugValue: ri,
                useDeferredValue: function(a) {
                    return Th().memoizedState = a;
                },
                useTransition: function() {
                    var a = hi(!1), b = a[0];
                    a = vi.bind(null, a[1]);
                    Th().memoizedState = a;
                    return [ b, a ];
                },
                useMutableSource: function() {},
                useSyncExternalStore: function(a, b, c) {
                    var d = M, e = Th();
                    if (I) {
                        if (void 0 === c) throw Error(p(407));
                        c = c();
                    } else {
                        c = b();
                        if (null === Q) throw Error(p(349));
                        0 !== (Hh & 30) || di(d, b, c);
                    }
                    e.memoizedState = c;
                    var f = {
                        value: c,
                        getSnapshot: b
                    };
                    e.queue = f;
                    mi(ai.bind(null, d, f, a), [ a ]);
                    d.flags |= 2048;
                    bi(9, ci.bind(null, d, f, c, b), void 0, null);
                    return c;
                },
                useId: function() {
                    var a = Th(), b = Q.identifierPrefix;
                    if (I) {
                        var c = sg;
                        var d = rg;
                        c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
                        b = ":" + b + "R" + c;
                        c = Kh++;
                        0 < c && (b += "H" + c.toString(32));
                        b += ":";
                    } else c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
                    return a.memoizedState = b;
                },
                unstable_isNewReconciler: !1
            }, Ph = {
                readContext: eh,
                useCallback: si,
                useContext: eh,
                useEffect: $h,
                useImperativeHandle: qi,
                useInsertionEffect: ni,
                useLayoutEffect: oi,
                useMemo: ti,
                useReducer: Wh,
                useRef: ji,
                useState: function() {
                    return Wh(Vh);
                },
                useDebugValue: ri,
                useDeferredValue: function(a) {
                    var b = Uh();
                    return ui(b, N.memoizedState, a);
                },
                useTransition: function() {
                    var a = Wh(Vh)[0], b = Uh().memoizedState;
                    return [ a, b ];
                },
                useMutableSource: Yh,
                useSyncExternalStore: Zh,
                useId: wi,
                unstable_isNewReconciler: !1
            }, Qh = {
                readContext: eh,
                useCallback: si,
                useContext: eh,
                useEffect: $h,
                useImperativeHandle: qi,
                useInsertionEffect: ni,
                useLayoutEffect: oi,
                useMemo: ti,
                useReducer: Xh,
                useRef: ji,
                useState: function() {
                    return Xh(Vh);
                },
                useDebugValue: ri,
                useDeferredValue: function(a) {
                    var b = Uh();
                    return null === N ? b.memoizedState = a : ui(b, N.memoizedState, a);
                },
                useTransition: function() {
                    var a = Xh(Vh)[0], b = Uh().memoizedState;
                    return [ a, b ];
                },
                useMutableSource: Yh,
                useSyncExternalStore: Zh,
                useId: wi,
                unstable_isNewReconciler: !1
            };
            function Ci(a, b) {
                if (a && a.defaultProps) {
                    b = A({}, b);
                    a = a.defaultProps;
                    for (var c in a) void 0 === b[c] && (b[c] = a[c]);
                    return b;
                }
                return b;
            }
            function Di(a, b, c, d) {
                b = a.memoizedState;
                c = c(d, b);
                c = null === c || void 0 === c ? b : A({}, b, c);
                a.memoizedState = c;
                0 === a.lanes && (a.updateQueue.baseState = c);
            }
            var Ei = {
                isMounted: function(a) {
                    return (a = a._reactInternals) ? Vb(a) === a : !1;
                },
                enqueueSetState: function(a, b, c) {
                    a = a._reactInternals;
                    var d = R(), e = yi(a), f = mh(d, e);
                    f.payload = b;
                    void 0 !== c && null !== c && (f.callback = c);
                    b = nh(a, f, e);
                    null !== b && (gi(b, a, e, d), oh(b, a, e));
                },
                enqueueReplaceState: function(a, b, c) {
                    a = a._reactInternals;
                    var d = R(), e = yi(a), f = mh(d, e);
                    f.tag = 1;
                    f.payload = b;
                    void 0 !== c && null !== c && (f.callback = c);
                    b = nh(a, f, e);
                    null !== b && (gi(b, a, e, d), oh(b, a, e));
                },
                enqueueForceUpdate: function(a, b) {
                    a = a._reactInternals;
                    var c = R(), d = yi(a), e = mh(c, d);
                    e.tag = 2;
                    void 0 !== b && null !== b && (e.callback = b);
                    b = nh(a, e, d);
                    null !== b && (gi(b, a, d, c), oh(b, a, d));
                }
            };
            function Fi(a, b, c, d, e, f, g) {
                a = a.stateNode;
                return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : !0;
            }
            function Gi(a, b, c) {
                var d = !1, e = Vf;
                var f = b.contextType;
                "object" === typeof f && null !== f ? f = eh(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, 
                f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
                b = new b(c, f);
                a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
                b.updater = Ei;
                a.stateNode = b;
                b._reactInternals = a;
                d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
                return b;
            }
            function Hi(a, b, c, d) {
                a = b.state;
                "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
                "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
                b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
            }
            function Ii(a, b, c, d) {
                var e = a.stateNode;
                e.props = c;
                e.state = a.memoizedState;
                e.refs = {};
                kh(a);
                var f = b.contextType;
                "object" === typeof f && null !== f ? e.context = eh(f) : (f = Zf(b) ? Xf : H.current, 
                e.context = Yf(a, f));
                e.state = a.memoizedState;
                f = b.getDerivedStateFromProps;
                "function" === typeof f && (Di(a, b, f, c), e.state = a.memoizedState);
                "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, 
                "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), 
                b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a, c, e, d), e.state = a.memoizedState);
                "function" === typeof e.componentDidMount && (a.flags |= 4194308);
            }
            function Ji(a, b) {
                try {
                    var c = "", d = b;
                    do {
                        c += Pa(d), d = d.return;
                    } while (d);
                    var e = c;
                } catch (f) {
                    e = "\nError generating stack: " + f.message + "\n" + f.stack;
                }
                return {
                    value: a,
                    source: b,
                    stack: e,
                    digest: null
                };
            }
            function Ki(a, b, c) {
                return {
                    value: a,
                    source: null,
                    stack: null != c ? c : null,
                    digest: null != b ? b : null
                };
            }
            function Li(a, b) {
                try {
                    console.error(b.value);
                } catch (c) {
                    setTimeout(function() {
                        throw c;
                    });
                }
            }
            var Mi = "function" === typeof WeakMap ? WeakMap : Map;
            function Ni(a, b, c) {
                c = mh(-1, c);
                c.tag = 3;
                c.payload = {
                    element: null
                };
                var d = b.value;
                c.callback = function() {
                    Oi || (Oi = !0, Pi = d);
                    Li(a, b);
                };
                return c;
            }
            function Qi(a, b, c) {
                c = mh(-1, c);
                c.tag = 3;
                var d = a.type.getDerivedStateFromError;
                if ("function" === typeof d) {
                    var e = b.value;
                    c.payload = function() {
                        return d(e);
                    };
                    c.callback = function() {
                        Li(a, b);
                    };
                }
                var f = a.stateNode;
                null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
                    Li(a, b);
                    "function" !== typeof d && (null === Ri ? Ri = new Set([ this ]) : Ri.add(this));
                    var c = b.stack;
                    this.componentDidCatch(b.value, {
                        componentStack: null !== c ? c : ""
                    });
                });
                return c;
            }
            function Si(a, b, c) {
                var d = a.pingCache;
                if (null === d) {
                    d = a.pingCache = new Mi;
                    var e = new Set;
                    d.set(b, e);
                } else e = d.get(b), void 0 === e && (e = new Set, d.set(b, e));
                e.has(c) || (e.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
            }
            function Ui(a) {
                do {
                    var b;
                    if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? !0 : !1 : !0;
                    if (b) return a;
                    a = a.return;
                } while (null !== a);
                return null;
            }
            function Vi(a, b, c, d, e) {
                if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, 
                c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = mh(-1, 1), 
                b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a;
                a.flags |= 65536;
                a.lanes = e;
                return a;
            }
            var Wi = ua.ReactCurrentOwner, dh = !1;
            function Xi(a, b, c, d) {
                b.child = null === a ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
            }
            function Yi(a, b, c, d, e) {
                c = c.render;
                var f = b.ref;
                ch(b, e);
                d = Nh(a, b, c, d, f, e);
                c = Sh();
                if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, 
                Zi(a, b, e);
                I && c && vg(b);
                b.flags |= 1;
                Xi(a, b, d, e);
                return b.child;
            }
            function $i(a, b, c, d, e) {
                if (null === a) {
                    var f = c.type;
                    if ("function" === typeof f && !aj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, 
                    b.type = f, bj(a, b, f, d, e);
                    a = Rg(c.type, null, d, b, b.mode, e);
                    a.ref = b.ref;
                    a.return = b;
                    return b.child = a;
                }
                f = a.child;
                if (0 === (a.lanes & e)) {
                    var g = f.memoizedProps;
                    c = c.compare;
                    c = null !== c ? c : Ie;
                    if (c(g, d) && a.ref === b.ref) return Zi(a, b, e);
                }
                b.flags |= 1;
                a = Pg(f, d);
                a.ref = b.ref;
                a.return = b;
                return b.child = a;
            }
            function bj(a, b, c, d, e) {
                if (null !== a) {
                    var f = a.memoizedProps;
                    if (Ie(f, d) && a.ref === b.ref) if (dh = !1, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (dh = !0); else return b.lanes = a.lanes, 
                    Zi(a, b, e);
                }
                return cj(a, b, c, d, e);
            }
            function dj(a, b, c) {
                var d = b.pendingProps, e = d.children, f = null !== a ? a.memoizedState : null;
                if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = {
                    baseLanes: 0,
                    cachePool: null,
                    transitions: null
                }, G(ej, fj), fj |= c; else {
                    if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, 
                    b.memoizedState = {
                        baseLanes: a,
                        cachePool: null,
                        transitions: null
                    }, b.updateQueue = null, G(ej, fj), fj |= a, null;
                    b.memoizedState = {
                        baseLanes: 0,
                        cachePool: null,
                        transitions: null
                    };
                    d = null !== f ? f.baseLanes : c;
                    G(ej, fj);
                    fj |= d;
                } else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(ej, fj), 
                fj |= d;
                Xi(a, b, e, c);
                return b.child;
            }
            function gj(a, b) {
                var c = b.ref;
                if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
            }
            function cj(a, b, c, d, e) {
                var f = Zf(c) ? Xf : H.current;
                f = Yf(b, f);
                ch(b, e);
                c = Nh(a, b, c, d, f, e);
                d = Sh();
                if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, 
                Zi(a, b, e);
                I && d && vg(b);
                b.flags |= 1;
                Xi(a, b, c, e);
                return b.child;
            }
            function hj(a, b, c, d, e) {
                if (Zf(c)) {
                    var f = !0;
                    cg(b);
                } else f = !1;
                ch(b, e);
                if (null === b.stateNode) ij(a, b), Gi(b, c, d), Ii(b, c, d, e), d = !0; else if (null === a) {
                    var g = b.stateNode, h = b.memoizedProps;
                    g.props = h;
                    var k = g.context, l = c.contextType;
                    "object" === typeof l && null !== l ? l = eh(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
                    var m = c.getDerivedStateFromProps, q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
                    q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Hi(b, g, d, l);
                    jh = !1;
                    var r = b.memoizedState;
                    g.state = r;
                    qh(b, d, g, e);
                    k = b.memoizedState;
                    h !== d || r !== k || Wf.current || jh ? ("function" === typeof m && (Di(b, c, m, d), 
                    k = b.memoizedState), (h = jh || Fi(b, c, h, d, r, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), 
                    "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), 
                    "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), 
                    b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, 
                    d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = !1);
                } else {
                    g = b.stateNode;
                    lh(a, b);
                    h = b.memoizedProps;
                    l = b.type === b.elementType ? h : Ci(b.type, h);
                    g.props = l;
                    q = b.pendingProps;
                    r = g.context;
                    k = c.contextType;
                    "object" === typeof k && null !== k ? k = eh(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
                    var y = c.getDerivedStateFromProps;
                    (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r !== k) && Hi(b, g, d, k);
                    jh = !1;
                    r = b.memoizedState;
                    g.state = r;
                    qh(b, d, g, e);
                    var n = b.memoizedState;
                    h !== q || r !== n || Wf.current || jh ? ("function" === typeof y && (Di(b, c, y, d), 
                    n = b.memoizedState), (l = jh || Fi(b, c, l, d, r, n, k) || !1) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), 
                    "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), 
                    "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), 
                    "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), 
                    b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, 
                    d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), 
                    "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), 
                    d = !1);
                }
                return jj(a, b, c, d, f, e);
            }
            function jj(a, b, c, d, e, f) {
                gj(a, b);
                var g = 0 !== (b.flags & 128);
                if (!d && !g) return e && dg(b, c, !1), Zi(a, b, f);
                d = b.stateNode;
                Wi.current = b;
                var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
                b.flags |= 1;
                null !== a && g ? (b.child = Ug(b, a.child, null, f), b.child = Ug(b, null, h, f)) : Xi(a, b, h, f);
                b.memoizedState = d.state;
                e && dg(b, c, !0);
                return b.child;
            }
            function kj(a) {
                var b = a.stateNode;
                b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, !1);
                yh(a, b.containerInfo);
            }
            function lj(a, b, c, d, e) {
                Ig();
                Jg(e);
                b.flags |= 256;
                Xi(a, b, c, d);
                return b.child;
            }
            var mj = {
                dehydrated: null,
                treeContext: null,
                retryLane: 0
            };
            function nj(a) {
                return {
                    baseLanes: a,
                    cachePool: null,
                    transitions: null
                };
            }
            function oj(a, b, c) {
                var h, d = b.pendingProps, e = L.current, f = !1, g = 0 !== (b.flags & 128);
                (h = g) || (h = null !== a && null === a.memoizedState ? !1 : 0 !== (e & 2));
                if (h) f = !0, b.flags &= -129; else if (null === a || null !== a.memoizedState) e |= 1;
                G(L, e & 1);
                if (null === a) {
                    Eg(b);
                    a = b.memoizedState;
                    if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, 
                    null;
                    g = d.children;
                    a = d.fallback;
                    return f ? (d = b.mode, f = b.child, g = {
                        mode: "hidden",
                        children: g
                    }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = pj(g, d, 0, null), 
                    a = Tg(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = nj(c), 
                    b.memoizedState = mj, a) : qj(b, g);
                }
                e = a.memoizedState;
                if (null !== e && (h = e.dehydrated, null !== h)) return rj(a, b, g, d, h, e, c);
                if (f) {
                    f = d.fallback;
                    g = b.mode;
                    e = a.child;
                    h = e.sibling;
                    var k = {
                        mode: "hidden",
                        children: d.children
                    };
                    0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, 
                    b.deletions = null) : (d = Pg(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
                    null !== h ? f = Pg(h, f) : (f = Tg(f, g, c, null), f.flags |= 2);
                    f.return = b;
                    d.return = b;
                    d.sibling = f;
                    b.child = d;
                    d = f;
                    f = b.child;
                    g = a.child.memoizedState;
                    g = null === g ? nj(c) : {
                        baseLanes: g.baseLanes | c,
                        cachePool: null,
                        transitions: g.transitions
                    };
                    f.memoizedState = g;
                    f.childLanes = a.childLanes & ~c;
                    b.memoizedState = mj;
                    return d;
                }
                f = a.child;
                a = f.sibling;
                d = Pg(f, {
                    mode: "visible",
                    children: d.children
                });
                0 === (b.mode & 1) && (d.lanes = c);
                d.return = b;
                d.sibling = null;
                null !== a && (c = b.deletions, null === c ? (b.deletions = [ a ], b.flags |= 16) : c.push(a));
                b.child = d;
                b.memoizedState = null;
                return d;
            }
            function qj(a, b) {
                b = pj({
                    mode: "visible",
                    children: b
                }, a.mode, 0, null);
                b.return = a;
                return a.child = b;
            }
            function sj(a, b, c, d) {
                null !== d && Jg(d);
                Ug(b, a.child, null, c);
                a = qj(b, b.pendingProps.children);
                a.flags |= 2;
                b.memoizedState = null;
                return a;
            }
            function rj(a, b, c, d, e, f, g) {
                if (c) {
                    if (b.flags & 256) return b.flags &= -257, d = Ki(Error(p(422))), sj(a, b, g, d);
                    if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
                    f = d.fallback;
                    e = b.mode;
                    d = pj({
                        mode: "visible",
                        children: d.children
                    }, e, 0, null);
                    f = Tg(f, e, g, null);
                    f.flags |= 2;
                    d.return = b;
                    f.return = b;
                    d.sibling = f;
                    b.child = d;
                    0 !== (b.mode & 1) && Ug(b, a.child, null, g);
                    b.child.memoizedState = nj(g);
                    b.memoizedState = mj;
                    return f;
                }
                if (0 === (b.mode & 1)) return sj(a, b, g, null);
                if ("$!" === e.data) {
                    d = e.nextSibling && e.nextSibling.dataset;
                    if (d) var h = d.dgst;
                    d = h;
                    f = Error(p(419));
                    d = Ki(f, d, void 0);
                    return sj(a, b, g, d);
                }
                h = 0 !== (g & a.childLanes);
                if (dh || h) {
                    d = Q;
                    if (null !== d) {
                        switch (g & -g) {
                          case 4:
                            e = 2;
                            break;

                          case 16:
                            e = 8;
                            break;

                          case 64:
                          case 128:
                          case 256:
                          case 512:
                          case 1024:
                          case 2048:
                          case 4096:
                          case 8192:
                          case 16384:
                          case 32768:
                          case 65536:
                          case 131072:
                          case 262144:
                          case 524288:
                          case 1048576:
                          case 2097152:
                          case 4194304:
                          case 8388608:
                          case 16777216:
                          case 33554432:
                          case 67108864:
                            e = 32;
                            break;

                          case 536870912:
                            e = 268435456;
                            break;

                          default:
                            e = 0;
                        }
                        e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
                        0 !== e && e !== f.retryLane && (f.retryLane = e, ih(a, e), gi(d, a, e, -1));
                    }
                    tj();
                    d = Ki(Error(p(421)));
                    return sj(a, b, g, d);
                }
                if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = uj.bind(null, a), 
                e._reactRetry = b, null;
                a = f.treeContext;
                yg = Lf(e.nextSibling);
                xg = b;
                I = !0;
                zg = null;
                null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, 
                qg = b);
                b = qj(b, d.children);
                b.flags |= 4096;
                return b;
            }
            function vj(a, b, c) {
                a.lanes |= b;
                var d = a.alternate;
                null !== d && (d.lanes |= b);
                bh(a.return, b, c);
            }
            function wj(a, b, c, d, e) {
                var f = a.memoizedState;
                null === f ? a.memoizedState = {
                    isBackwards: b,
                    rendering: null,
                    renderingStartTime: 0,
                    last: d,
                    tail: c,
                    tailMode: e
                } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, 
                f.tail = c, f.tailMode = e);
            }
            function xj(a, b, c) {
                var d = b.pendingProps, e = d.revealOrder, f = d.tail;
                Xi(a, b, d.children, c);
                d = L.current;
                if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128; else {
                    if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a; ) {
                        if (13 === a.tag) null !== a.memoizedState && vj(a, c, b); else if (19 === a.tag) vj(a, c, b); else if (null !== a.child) {
                            a.child.return = a;
                            a = a.child;
                            continue;
                        }
                        if (a === b) break a;
                        for (;null === a.sibling; ) {
                            if (null === a.return || a.return === b) break a;
                            a = a.return;
                        }
                        a.sibling.return = a.return;
                        a = a.sibling;
                    }
                    d &= 1;
                }
                G(L, d);
                if (0 === (b.mode & 1)) b.memoizedState = null; else switch (e) {
                  case "forwards":
                    c = b.child;
                    for (e = null; null !== c; ) a = c.alternate, null !== a && null === Ch(a) && (e = c), 
                    c = c.sibling;
                    c = e;
                    null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
                    wj(b, !1, e, c, f);
                    break;

                  case "backwards":
                    c = null;
                    e = b.child;
                    for (b.child = null; null !== e; ) {
                        a = e.alternate;
                        if (null !== a && null === Ch(a)) {
                            b.child = e;
                            break;
                        }
                        a = e.sibling;
                        e.sibling = c;
                        c = e;
                        e = a;
                    }
                    wj(b, !0, c, null, f);
                    break;

                  case "together":
                    wj(b, !1, null, null, void 0);
                    break;

                  default:
                    b.memoizedState = null;
                }
                return b.child;
            }
            function ij(a, b) {
                0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
            }
            function Zi(a, b, c) {
                null !== a && (b.dependencies = a.dependencies);
                rh |= b.lanes;
                if (0 === (c & b.childLanes)) return null;
                if (null !== a && b.child !== a.child) throw Error(p(153));
                if (null !== b.child) {
                    a = b.child;
                    c = Pg(a, a.pendingProps);
                    b.child = c;
                    for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), 
                    c.return = b;
                    c.sibling = null;
                }
                return b.child;
            }
            function yj(a, b, c) {
                switch (b.tag) {
                  case 3:
                    kj(b);
                    Ig();
                    break;

                  case 5:
                    Ah(b);
                    break;

                  case 1:
                    Zf(b.type) && cg(b);
                    break;

                  case 4:
                    yh(b, b.stateNode.containerInfo);
                    break;

                  case 10:
                    var d = b.type._context, e = b.memoizedProps.value;
                    G(Wg, d._currentValue);
                    d._currentValue = e;
                    break;

                  case 13:
                    d = b.memoizedState;
                    if (null !== d) {
                        if (null !== d.dehydrated) return G(L, L.current & 1), b.flags |= 128, null;
                        if (0 !== (c & b.child.childLanes)) return oj(a, b, c);
                        G(L, L.current & 1);
                        a = Zi(a, b, c);
                        return null !== a ? a.sibling : null;
                    }
                    G(L, L.current & 1);
                    break;

                  case 19:
                    d = 0 !== (c & b.childLanes);
                    if (0 !== (a.flags & 128)) {
                        if (d) return xj(a, b, c);
                        b.flags |= 128;
                    }
                    e = b.memoizedState;
                    null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
                    G(L, L.current);
                    if (d) break; else return null;

                  case 22:
                  case 23:
                    return b.lanes = 0, dj(a, b, c);
                }
                return Zi(a, b, c);
            }
            var zj, Aj, Bj, Cj;
            zj = function(a, b) {
                for (var c = b.child; null !== c; ) {
                    if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode); else if (4 !== c.tag && null !== c.child) {
                        c.child.return = c;
                        c = c.child;
                        continue;
                    }
                    if (c === b) break;
                    for (;null === c.sibling; ) {
                        if (null === c.return || c.return === b) return;
                        c = c.return;
                    }
                    c.sibling.return = c.return;
                    c = c.sibling;
                }
            };
            Aj = function() {};
            Bj = function(a, b, c, d) {
                var e = a.memoizedProps;
                if (e !== d) {
                    a = b.stateNode;
                    xh(uh.current);
                    var f = null;
                    switch (c) {
                      case "input":
                        e = Ya(a, e);
                        d = Ya(a, d);
                        f = [];
                        break;

                      case "select":
                        e = A({}, e, {
                            value: void 0
                        });
                        d = A({}, d, {
                            value: void 0
                        });
                        f = [];
                        break;

                      case "textarea":
                        e = gb(a, e);
                        d = gb(a, d);
                        f = [];
                        break;

                      default:
                        "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
                    }
                    ub(c, d);
                    var g;
                    c = null;
                    for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
                        var h = e[l];
                        for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
                    } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
                    for (l in d) {
                        var k = d[l];
                        h = null != e ? e[l] : void 0;
                        if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) if (h) {
                            for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), 
                            c[g] = "");
                            for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
                        } else c || (f || (f = []), f.push(l, c)), c = k; else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, 
                        h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), 
                        f || h === k || (f = [])) : (f = f || []).push(l, k));
                    }
                    c && (f = f || []).push("style", c);
                    var l = f;
                    if (b.updateQueue = l) b.flags |= 4;
                }
            };
            Cj = function(a, b, c, d) {
                c !== d && (b.flags |= 4);
            };
            function Dj(a, b) {
                if (!I) switch (a.tailMode) {
                  case "hidden":
                    b = a.tail;
                    for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
                    null === c ? a.tail = null : c.sibling = null;
                    break;

                  case "collapsed":
                    c = a.tail;
                    for (var d = null; null !== c; ) null !== c.alternate && (d = c), c = c.sibling;
                    null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
                }
            }
            function S(a) {
                var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
                if (b) for (var e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, 
                d |= e.flags & 14680064, e.return = a, e = e.sibling; else for (e = a.child; null !== e; ) c |= e.lanes | e.childLanes, 
                d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
                a.subtreeFlags |= d;
                a.childLanes = c;
                return b;
            }
            function Ej(a, b, c) {
                var d = b.pendingProps;
                wg(b);
                switch (b.tag) {
                  case 2:
                  case 16:
                  case 15:
                  case 0:
                  case 11:
                  case 7:
                  case 8:
                  case 12:
                  case 9:
                  case 14:
                    return S(b), null;

                  case 1:
                    return Zf(b.type) && $f(), S(b), null;

                  case 3:
                    d = b.stateNode;
                    zh();
                    E(Wf);
                    E(H);
                    Eh();
                    d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
                    if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, 
                    null !== zg && (Fj(zg), zg = null));
                    Aj(a, b);
                    S(b);
                    return null;

                  case 5:
                    Bh(b);
                    var e = xh(wh.current);
                    c = b.type;
                    if (null !== a && null != b.stateNode) Bj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, 
                    b.flags |= 2097152); else {
                        if (!d) {
                            if (null === b.stateNode) throw Error(p(166));
                            S(b);
                            return null;
                        }
                        a = xh(uh.current);
                        if (Gg(b)) {
                            d = b.stateNode;
                            c = b.type;
                            var f = b.memoizedProps;
                            d[Of] = b;
                            d[Pf] = f;
                            a = 0 !== (b.mode & 1);
                            switch (c) {
                              case "dialog":
                                D("cancel", d);
                                D("close", d);
                                break;

                              case "iframe":
                              case "object":
                              case "embed":
                                D("load", d);
                                break;

                              case "video":
                              case "audio":
                                for (e = 0; e < lf.length; e++) D(lf[e], d);
                                break;

                              case "source":
                                D("error", d);
                                break;

                              case "img":
                              case "image":
                              case "link":
                                D("error", d);
                                D("load", d);
                                break;

                              case "details":
                                D("toggle", d);
                                break;

                              case "input":
                                Za(d, f);
                                D("invalid", d);
                                break;

                              case "select":
                                d._wrapperState = {
                                    wasMultiple: !!f.multiple
                                };
                                D("invalid", d);
                                break;

                              case "textarea":
                                hb(d, f), D("invalid", d);
                            }
                            ub(c, f);
                            e = null;
                            for (var g in f) if (f.hasOwnProperty(g)) {
                                var h = f[g];
                                "children" === g ? "string" === typeof h ? d.textContent !== h && (!0 !== f.suppressHydrationWarning && Af(d.textContent, h, a), 
                                e = [ "children", h ]) : "number" === typeof h && d.textContent !== "" + h && (!0 !== f.suppressHydrationWarning && Af(d.textContent, h, a), 
                                e = [ "children", "" + h ]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
                            }
                            switch (c) {
                              case "input":
                                Va(d);
                                db(d, f, !0);
                                break;

                              case "textarea":
                                Va(d);
                                jb(d);
                                break;

                              case "select":
                              case "option":
                                break;

                              default:
                                "function" === typeof f.onClick && (d.onclick = Bf);
                            }
                            d = e;
                            b.updateQueue = d;
                            null !== d && (b.flags |= 4);
                        } else {
                            g = 9 === e.nodeType ? e : e.ownerDocument;
                            "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
                            "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), 
                            a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, {
                                is: d.is
                            }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = !0 : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
                            a[Of] = b;
                            a[Pf] = d;
                            zj(a, b, !1, !1);
                            b.stateNode = a;
                            a: {
                                g = vb(c, d);
                                switch (c) {
                                  case "dialog":
                                    D("cancel", a);
                                    D("close", a);
                                    e = d;
                                    break;

                                  case "iframe":
                                  case "object":
                                  case "embed":
                                    D("load", a);
                                    e = d;
                                    break;

                                  case "video":
                                  case "audio":
                                    for (e = 0; e < lf.length; e++) D(lf[e], a);
                                    e = d;
                                    break;

                                  case "source":
                                    D("error", a);
                                    e = d;
                                    break;

                                  case "img":
                                  case "image":
                                  case "link":
                                    D("error", a);
                                    D("load", a);
                                    e = d;
                                    break;

                                  case "details":
                                    D("toggle", a);
                                    e = d;
                                    break;

                                  case "input":
                                    Za(a, d);
                                    e = Ya(a, d);
                                    D("invalid", a);
                                    break;

                                  case "option":
                                    e = d;
                                    break;

                                  case "select":
                                    a._wrapperState = {
                                        wasMultiple: !!d.multiple
                                    };
                                    e = A({}, d, {
                                        value: void 0
                                    });
                                    D("invalid", a);
                                    break;

                                  case "textarea":
                                    hb(a, d);
                                    e = gb(a, d);
                                    D("invalid", a);
                                    break;

                                  default:
                                    e = d;
                                }
                                ub(c, e);
                                h = e;
                                for (f in h) if (h.hasOwnProperty(f)) {
                                    var k = h[f];
                                    "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, 
                                    null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta(a, f, k, g));
                                }
                                switch (c) {
                                  case "input":
                                    Va(a);
                                    db(a, d, !1);
                                    break;

                                  case "textarea":
                                    Va(a);
                                    jb(a);
                                    break;

                                  case "option":
                                    null != d.value && a.setAttribute("value", "" + Sa(d.value));
                                    break;

                                  case "select":
                                    a.multiple = !!d.multiple;
                                    f = d.value;
                                    null != f ? fb(a, !!d.multiple, f, !1) : null != d.defaultValue && fb(a, !!d.multiple, d.defaultValue, !0);
                                    break;

                                  default:
                                    "function" === typeof e.onClick && (a.onclick = Bf);
                                }
                                switch (c) {
                                  case "button":
                                  case "input":
                                  case "select":
                                  case "textarea":
                                    d = !!d.autoFocus;
                                    break a;

                                  case "img":
                                    d = !0;
                                    break a;

                                  default:
                                    d = !1;
                                }
                            }
                            d && (b.flags |= 4);
                        }
                        null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
                    }
                    S(b);
                    return null;

                  case 6:
                    if (a && null != b.stateNode) Cj(a, b, a.memoizedProps, d); else {
                        if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
                        c = xh(wh.current);
                        xh(uh.current);
                        if (Gg(b)) {
                            d = b.stateNode;
                            c = b.memoizedProps;
                            d[Of] = b;
                            if (f = d.nodeValue !== c) if (a = xg, null !== a) switch (a.tag) {
                              case 3:
                                Af(d.nodeValue, c, 0 !== (a.mode & 1));
                                break;

                              case 5:
                                !0 !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
                            }
                            f && (b.flags |= 4);
                        } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, 
                        b.stateNode = d;
                    }
                    S(b);
                    return null;

                  case 13:
                    E(L);
                    d = b.memoizedState;
                    if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
                        if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), 
                        b.flags |= 98560, f = !1; else if (f = Gg(b), null !== d && null !== d.dehydrated) {
                            if (null === a) {
                                if (!f) throw Error(p(318));
                                f = b.memoizedState;
                                f = null !== f ? f.dehydrated : null;
                                if (!f) throw Error(p(317));
                                f[Of] = b;
                            } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
                            S(b);
                            f = !1;
                        } else null !== zg && (Fj(zg), zg = null), f = !0;
                        if (!f) return b.flags & 65536 ? b : null;
                    }
                    if (0 !== (b.flags & 128)) return b.lanes = c, b;
                    d = null !== d;
                    d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
                    null !== b.updateQueue && (b.flags |= 4);
                    S(b);
                    return null;

                  case 4:
                    return zh(), Aj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;

                  case 10:
                    return ah(b.type._context), S(b), null;

                  case 17:
                    return Zf(b.type) && $f(), S(b), null;

                  case 19:
                    E(L);
                    f = b.memoizedState;
                    if (null === f) return S(b), null;
                    d = 0 !== (b.flags & 128);
                    g = f.rendering;
                    if (null === g) if (d) Dj(f, !1); else {
                        if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a; ) {
                            g = Ch(a);
                            if (null !== g) {
                                b.flags |= 128;
                                Dj(f, !1);
                                d = g.updateQueue;
                                null !== d && (b.updateQueue = d, b.flags |= 4);
                                b.subtreeFlags = 0;
                                d = c;
                                for (c = b.child; null !== c; ) f = c, a = d, f.flags &= 14680066, g = f.alternate, 
                                null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, 
                                f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, 
                                f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, 
                                f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, 
                                f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : {
                                    lanes: a.lanes,
                                    firstContext: a.firstContext
                                }), c = c.sibling;
                                G(L, L.current & 1 | 2);
                                return b.child;
                            }
                            a = a.sibling;
                        }
                        null !== f.tail && B() > Gj && (b.flags |= 128, d = !0, Dj(f, !1), b.lanes = 4194304);
                    } else {
                        if (!d) if (a = Ch(g), null !== a) {
                            if (b.flags |= 128, d = !0, c = a.updateQueue, null !== c && (b.updateQueue = c, 
                            b.flags |= 4), Dj(f, !0), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), 
                            null;
                        } else 2 * B() - f.renderingStartTime > Gj && 1073741824 !== c && (b.flags |= 128, 
                        d = !0, Dj(f, !1), b.lanes = 4194304);
                        f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, 
                        f.last = g);
                    }
                    if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), 
                    b.sibling = null, c = L.current, G(L, d ? c & 1 | 2 : c & 1), b;
                    S(b);
                    return null;

                  case 22:
                  case 23:
                    return Hj(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), 
                    d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), 
                    null;

                  case 24:
                    return null;

                  case 25:
                    return null;
                }
                throw Error(p(156, b.tag));
            }
            function Ij(a, b) {
                wg(b);
                switch (b.tag) {
                  case 1:
                    return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, 
                    b) : null;

                  case 3:
                    return zh(), E(Wf), E(H), Eh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, 
                    b) : null;

                  case 5:
                    return Bh(b), null;

                  case 13:
                    E(L);
                    a = b.memoizedState;
                    if (null !== a && null !== a.dehydrated) {
                        if (null === b.alternate) throw Error(p(340));
                        Ig();
                    }
                    a = b.flags;
                    return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;

                  case 19:
                    return E(L), null;

                  case 4:
                    return zh(), null;

                  case 10:
                    return ah(b.type._context), null;

                  case 22:
                  case 23:
                    return Hj(), null;

                  case 24:
                    return null;

                  default:
                    return null;
                }
            }
            var Jj = !1, U = !1, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
            function Lj(a, b) {
                var c = a.ref;
                if (null !== c) if ("function" === typeof c) try {
                    c(null);
                } catch (d) {
                    W(a, b, d);
                } else c.current = null;
            }
            function Mj(a, b, c) {
                try {
                    c();
                } catch (d) {
                    W(a, b, d);
                }
            }
            var Nj = !1;
            function Oj(a, b) {
                Cf = dd;
                a = Me();
                if (Ne(a)) {
                    if ("selectionStart" in a) var c = {
                        start: a.selectionStart,
                        end: a.selectionEnd
                    }; else a: {
                        c = (c = a.ownerDocument) && c.defaultView || window;
                        var d = c.getSelection && c.getSelection();
                        if (d && 0 !== d.rangeCount) {
                            c = d.anchorNode;
                            var e = d.anchorOffset, f = d.focusNode;
                            d = d.focusOffset;
                            try {
                                c.nodeType, f.nodeType;
                            } catch (F) {
                                c = null;
                                break a;
                            }
                            var g = 0, h = -1, k = -1, l = 0, m = 0, q = a, r = null;
                            b: for (;;) {
                                for (var y; ;) {
                                    q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
                                    q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
                                    3 === q.nodeType && (g += q.nodeValue.length);
                                    if (null === (y = q.firstChild)) break;
                                    r = q;
                                    q = y;
                                }
                                for (;;) {
                                    if (q === a) break b;
                                    r === c && ++l === e && (h = g);
                                    r === f && ++m === d && (k = g);
                                    if (null !== (y = q.nextSibling)) break;
                                    q = r;
                                    r = q.parentNode;
                                }
                                q = y;
                            }
                            c = -1 === h || -1 === k ? null : {
                                start: h,
                                end: k
                            };
                        } else c = null;
                    }
                    c = c || {
                        start: 0,
                        end: 0
                    };
                } else c = null;
                Df = {
                    focusedElem: a,
                    selectionRange: c
                };
                dd = !1;
                for (V = b; null !== V; ) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, 
                V = a; else for (;null !== V; ) {
                    b = V;
                    try {
                        var n = b.alternate;
                        if (0 !== (b.flags & 1024)) switch (b.tag) {
                          case 0:
                          case 11:
                          case 15:
                            break;

                          case 1:
                            if (null !== n) {
                                var t = n.memoizedProps, J = n.memoizedState, x = b.stateNode, w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Ci(b.type, t), J);
                                x.__reactInternalSnapshotBeforeUpdate = w;
                            }
                            break;

                          case 3:
                            var u = b.stateNode.containerInfo;
                            1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
                            break;

                          case 5:
                          case 6:
                          case 4:
                          case 17:
                            break;

                          default:
                            throw Error(p(163));
                        }
                    } catch (F) {
                        W(b, b.return, F);
                    }
                    a = b.sibling;
                    if (null !== a) {
                        a.return = b.return;
                        V = a;
                        break;
                    }
                    V = b.return;
                }
                n = Nj;
                Nj = !1;
                return n;
            }
            function Pj(a, b, c) {
                var d = b.updateQueue;
                d = null !== d ? d.lastEffect : null;
                if (null !== d) {
                    var e = d = d.next;
                    do {
                        if ((e.tag & a) === a) {
                            var f = e.destroy;
                            e.destroy = void 0;
                            void 0 !== f && Mj(b, c, f);
                        }
                        e = e.next;
                    } while (e !== d);
                }
            }
            function Qj(a, b) {
                b = b.updateQueue;
                b = null !== b ? b.lastEffect : null;
                if (null !== b) {
                    var c = b = b.next;
                    do {
                        if ((c.tag & a) === a) {
                            var d = c.create;
                            c.destroy = d();
                        }
                        c = c.next;
                    } while (c !== b);
                }
            }
            function Rj(a) {
                var b = a.ref;
                if (null !== b) {
                    var c = a.stateNode;
                    switch (a.tag) {
                      case 5:
                        a = c;
                        break;

                      default:
                        a = c;
                    }
                    "function" === typeof b ? b(a) : b.current = a;
                }
            }
            function Sj(a) {
                var b = a.alternate;
                null !== b && (a.alternate = null, Sj(b));
                a.child = null;
                a.deletions = null;
                a.sibling = null;
                5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], 
                delete b[Qf], delete b[Rf]));
                a.stateNode = null;
                a.return = null;
                a.dependencies = null;
                a.memoizedProps = null;
                a.memoizedState = null;
                a.pendingProps = null;
                a.stateNode = null;
                a.updateQueue = null;
            }
            function Tj(a) {
                return 5 === a.tag || 3 === a.tag || 4 === a.tag;
            }
            function Uj(a) {
                a: for (;;) {
                    for (;null === a.sibling; ) {
                        if (null === a.return || Tj(a.return)) return null;
                        a = a.return;
                    }
                    a.sibling.return = a.return;
                    for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
                        if (a.flags & 2) continue a;
                        if (null === a.child || 4 === a.tag) continue a; else a.child.return = a, a = a.child;
                    }
                    if (!(a.flags & 2)) return a.stateNode;
                }
            }
            function Vj(a, b, c) {
                var d = a.tag;
                if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, 
                b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf)); else if (4 !== d && (a = a.child, 
                null !== a)) for (Vj(a, b, c), a = a.sibling; null !== a; ) Vj(a, b, c), a = a.sibling;
            }
            function Wj(a, b, c) {
                var d = a.tag;
                if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a); else if (4 !== d && (a = a.child, 
                null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a; ) Wj(a, b, c), a = a.sibling;
            }
            var X = null, Xj = !1;
            function Yj(a, b, c) {
                for (c = c.child; null !== c; ) Zj(a, b, c), c = c.sibling;
            }
            function Zj(a, b, c) {
                if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
                    lc.onCommitFiberUnmount(kc, c);
                } catch (h) {}
                switch (c.tag) {
                  case 5:
                    U || Lj(c, b);

                  case 6:
                    var d = X, e = Xj;
                    X = null;
                    Yj(a, b, c);
                    X = d;
                    Xj = e;
                    null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
                    break;

                  case 18:
                    null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), 
                    bd(a)) : Kf(X, c.stateNode));
                    break;

                  case 4:
                    d = X;
                    e = Xj;
                    X = c.stateNode.containerInfo;
                    Xj = !0;
                    Yj(a, b, c);
                    X = d;
                    Xj = e;
                    break;

                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
                        e = d = d.next;
                        do {
                            var f = e, g = f.destroy;
                            f = f.tag;
                            void 0 !== g && (0 !== (f & 2) ? Mj(c, b, g) : 0 !== (f & 4) && Mj(c, b, g));
                            e = e.next;
                        } while (e !== d);
                    }
                    Yj(a, b, c);
                    break;

                  case 1:
                    if (!U && (Lj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
                        d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
                    } catch (h) {
                        W(c, b, h);
                    }
                    Yj(a, b, c);
                    break;

                  case 21:
                    Yj(a, b, c);
                    break;

                  case 22:
                    c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Yj(a, b, c), U = d) : Yj(a, b, c);
                    break;

                  default:
                    Yj(a, b, c);
                }
            }
            function ak(a) {
                var b = a.updateQueue;
                if (null !== b) {
                    a.updateQueue = null;
                    var c = a.stateNode;
                    null === c && (c = a.stateNode = new Kj);
                    b.forEach(function(b) {
                        var d = bk.bind(null, a, b);
                        c.has(b) || (c.add(b), b.then(d, d));
                    });
                }
            }
            function ck(a, b) {
                var c = b.deletions;
                if (null !== c) for (var d = 0; d < c.length; d++) {
                    var e = c[d];
                    try {
                        var f = a, g = b, h = g;
                        a: for (;null !== h; ) {
                            switch (h.tag) {
                              case 5:
                                X = h.stateNode;
                                Xj = !1;
                                break a;

                              case 3:
                                X = h.stateNode.containerInfo;
                                Xj = !0;
                                break a;

                              case 4:
                                X = h.stateNode.containerInfo;
                                Xj = !0;
                                break a;
                            }
                            h = h.return;
                        }
                        if (null === X) throw Error(p(160));
                        Zj(f, g, e);
                        X = null;
                        Xj = !1;
                        var k = e.alternate;
                        null !== k && (k.return = null);
                        e.return = null;
                    } catch (l) {
                        W(e, b, l);
                    }
                }
                if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) dk(b, a), b = b.sibling;
            }
            function dk(a, b) {
                var c = a.alternate, d = a.flags;
                switch (a.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    ck(b, a);
                    ek(a);
                    if (d & 4) {
                        try {
                            Pj(3, a, a.return), Qj(3, a);
                        } catch (t) {
                            W(a, a.return, t);
                        }
                        try {
                            Pj(5, a, a.return);
                        } catch (t) {
                            W(a, a.return, t);
                        }
                    }
                    break;

                  case 1:
                    ck(b, a);
                    ek(a);
                    d & 512 && null !== c && Lj(c, c.return);
                    break;

                  case 5:
                    ck(b, a);
                    ek(a);
                    d & 512 && null !== c && Lj(c, c.return);
                    if (a.flags & 32) {
                        var e = a.stateNode;
                        try {
                            ob(e, "");
                        } catch (t) {
                            W(a, a.return, t);
                        }
                    }
                    if (d & 4 && (e = a.stateNode, null != e)) {
                        var f = a.memoizedProps, g = null !== c ? c.memoizedProps : f, h = a.type, k = a.updateQueue;
                        a.updateQueue = null;
                        if (null !== k) try {
                            "input" === h && "radio" === f.type && null != f.name && ab(e, f);
                            vb(h, g);
                            var l = vb(h, f);
                            for (g = 0; g < k.length; g += 2) {
                                var m = k[g], q = k[g + 1];
                                "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
                            }
                            switch (h) {
                              case "input":
                                bb(e, f);
                                break;

                              case "textarea":
                                ib(e, f);
                                break;

                              case "select":
                                var r = e._wrapperState.wasMultiple;
                                e._wrapperState.wasMultiple = !!f.multiple;
                                var y = f.value;
                                null != y ? fb(e, !!f.multiple, y, !1) : r !== !!f.multiple && (null != f.defaultValue ? fb(e, !!f.multiple, f.defaultValue, !0) : fb(e, !!f.multiple, f.multiple ? [] : "", !1));
                            }
                            e[Pf] = f;
                        } catch (t) {
                            W(a, a.return, t);
                        }
                    }
                    break;

                  case 6:
                    ck(b, a);
                    ek(a);
                    if (d & 4) {
                        if (null === a.stateNode) throw Error(p(162));
                        e = a.stateNode;
                        f = a.memoizedProps;
                        try {
                            e.nodeValue = f;
                        } catch (t) {
                            W(a, a.return, t);
                        }
                    }
                    break;

                  case 3:
                    ck(b, a);
                    ek(a);
                    if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
                        bd(b.containerInfo);
                    } catch (t) {
                        W(a, a.return, t);
                    }
                    break;

                  case 4:
                    ck(b, a);
                    ek(a);
                    break;

                  case 13:
                    ck(b, a);
                    ek(a);
                    e = a.child;
                    e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B()));
                    d & 4 && ak(a);
                    break;

                  case 22:
                    m = null !== c && null !== c.memoizedState;
                    a.mode & 1 ? (U = (l = U) || m, ck(b, a), U = l) : ck(b, a);
                    ek(a);
                    if (d & 8192) {
                        l = null !== a.memoizedState;
                        if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V = a, m = a.child; null !== m; ) {
                            for (q = V = m; null !== V; ) {
                                r = V;
                                y = r.child;
                                switch (r.tag) {
                                  case 0:
                                  case 11:
                                  case 14:
                                  case 15:
                                    Pj(4, r, r.return);
                                    break;

                                  case 1:
                                    Lj(r, r.return);
                                    var n = r.stateNode;
                                    if ("function" === typeof n.componentWillUnmount) {
                                        d = r;
                                        c = r.return;
                                        try {
                                            b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                                        } catch (t) {
                                            W(d, c, t);
                                        }
                                    }
                                    break;

                                  case 5:
                                    Lj(r, r.return);
                                    break;

                                  case 22:
                                    if (null !== r.memoizedState) {
                                        gk(q);
                                        continue;
                                    }
                                }
                                null !== y ? (y.return = r, V = y) : gk(q);
                            }
                            m = m.sibling;
                        }
                        a: for (m = null, q = a; ;) {
                            if (5 === q.tag) {
                                if (null === m) {
                                    m = q;
                                    try {
                                        e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, 
                                        k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, 
                                        h.style.display = rb("display", g));
                                    } catch (t) {
                                        W(a, a.return, t);
                                    }
                                }
                            } else if (6 === q.tag) {
                                if (null === m) try {
                                    q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                                } catch (t) {
                                    W(a, a.return, t);
                                }
                            } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
                                q.child.return = q;
                                q = q.child;
                                continue;
                            }
                            if (q === a) break a;
                            for (;null === q.sibling; ) {
                                if (null === q.return || q.return === a) break a;
                                m === q && (m = null);
                                q = q.return;
                            }
                            m === q && (m = null);
                            q.sibling.return = q.return;
                            q = q.sibling;
                        }
                    }
                    break;

                  case 19:
                    ck(b, a);
                    ek(a);
                    d & 4 && ak(a);
                    break;

                  case 21:
                    break;

                  default:
                    ck(b, a), ek(a);
                }
            }
            function ek(a) {
                var b = a.flags;
                if (b & 2) {
                    try {
                        a: {
                            for (var c = a.return; null !== c; ) {
                                if (Tj(c)) {
                                    var d = c;
                                    break a;
                                }
                                c = c.return;
                            }
                            throw Error(p(160));
                        }
                        switch (d.tag) {
                          case 5:
                            var e = d.stateNode;
                            d.flags & 32 && (ob(e, ""), d.flags &= -33);
                            var f = Uj(a);
                            Wj(a, f, e);
                            break;

                          case 3:
                          case 4:
                            var g = d.stateNode.containerInfo, h = Uj(a);
                            Vj(a, h, g);
                            break;

                          default:
                            throw Error(p(161));
                        }
                    } catch (k) {
                        W(a, a.return, k);
                    }
                    a.flags &= -3;
                }
                b & 4096 && (a.flags &= -4097);
            }
            function hk(a, b, c) {
                V = a;
                ik(a, b, c);
            }
            function ik(a, b, c) {
                for (var d = 0 !== (a.mode & 1); null !== V; ) {
                    var e = V, f = e.child;
                    if (22 === e.tag && d) {
                        var g = null !== e.memoizedState || Jj;
                        if (!g) {
                            var h = e.alternate, k = null !== h && null !== h.memoizedState || U;
                            h = Jj;
                            var l = U;
                            Jj = g;
                            if ((U = k) && !l) for (V = e; null !== V; ) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e) : null !== k ? (k.return = g, 
                            V = k) : jk(e);
                            for (;null !== f; ) V = f, ik(f, b, c), f = f.sibling;
                            V = e;
                            Jj = h;
                            U = l;
                        }
                        kk(a, b, c);
                    } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : kk(a, b, c);
                }
            }
            function kk(a) {
                for (;null !== V; ) {
                    var b = V;
                    if (0 !== (b.flags & 8772)) {
                        var c = b.alternate;
                        try {
                            if (0 !== (b.flags & 8772)) switch (b.tag) {
                              case 0:
                              case 11:
                              case 15:
                                U || Qj(5, b);
                                break;

                              case 1:
                                var d = b.stateNode;
                                if (b.flags & 4 && !U) if (null === c) d.componentDidMount(); else {
                                    var e = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
                                    d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                                }
                                var f = b.updateQueue;
                                null !== f && sh(b, f, d);
                                break;

                              case 3:
                                var g = b.updateQueue;
                                if (null !== g) {
                                    c = null;
                                    if (null !== b.child) switch (b.child.tag) {
                                      case 5:
                                        c = b.child.stateNode;
                                        break;

                                      case 1:
                                        c = b.child.stateNode;
                                    }
                                    sh(b, g, c);
                                }
                                break;

                              case 5:
                                var h = b.stateNode;
                                if (null === c && b.flags & 4) {
                                    c = h;
                                    var k = b.memoizedProps;
                                    switch (b.type) {
                                      case "button":
                                      case "input":
                                      case "select":
                                      case "textarea":
                                        k.autoFocus && c.focus();
                                        break;

                                      case "img":
                                        k.src && (c.src = k.src);
                                    }
                                }
                                break;

                              case 6:
                                break;

                              case 4:
                                break;

                              case 12:
                                break;

                              case 13:
                                if (null === b.memoizedState) {
                                    var l = b.alternate;
                                    if (null !== l) {
                                        var m = l.memoizedState;
                                        if (null !== m) {
                                            var q = m.dehydrated;
                                            null !== q && bd(q);
                                        }
                                    }
                                }
                                break;

                              case 19:
                              case 17:
                              case 21:
                              case 22:
                              case 23:
                              case 25:
                                break;

                              default:
                                throw Error(p(163));
                            }
                            U || b.flags & 512 && Rj(b);
                        } catch (r) {
                            W(b, b.return, r);
                        }
                    }
                    if (b === a) {
                        V = null;
                        break;
                    }
                    c = b.sibling;
                    if (null !== c) {
                        c.return = b.return;
                        V = c;
                        break;
                    }
                    V = b.return;
                }
            }
            function gk(a) {
                for (;null !== V; ) {
                    var b = V;
                    if (b === a) {
                        V = null;
                        break;
                    }
                    var c = b.sibling;
                    if (null !== c) {
                        c.return = b.return;
                        V = c;
                        break;
                    }
                    V = b.return;
                }
            }
            function jk(a) {
                for (;null !== V; ) {
                    var b = V;
                    try {
                        switch (b.tag) {
                          case 0:
                          case 11:
                          case 15:
                            var c = b.return;
                            try {
                                Qj(4, b);
                            } catch (k) {
                                W(b, c, k);
                            }
                            break;

                          case 1:
                            var d = b.stateNode;
                            if ("function" === typeof d.componentDidMount) {
                                var e = b.return;
                                try {
                                    d.componentDidMount();
                                } catch (k) {
                                    W(b, e, k);
                                }
                            }
                            var f = b.return;
                            try {
                                Rj(b);
                            } catch (k) {
                                W(b, f, k);
                            }
                            break;

                          case 5:
                            var g = b.return;
                            try {
                                Rj(b);
                            } catch (k) {
                                W(b, g, k);
                            }
                        }
                    } catch (k) {
                        W(b, b.return, k);
                    }
                    if (b === a) {
                        V = null;
                        break;
                    }
                    var h = b.sibling;
                    if (null !== h) {
                        h.return = b.return;
                        V = h;
                        break;
                    }
                    V = b.return;
                }
            }
            var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = 1 / 0, uk = null, Oi = !1, Pi = null, Ri = null, vk = !1, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
            function R() {
                return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
            }
            function yi(a) {
                if (0 === (a.mode & 1)) return 1;
                if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
                if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
                a = C;
                if (0 !== a) return a;
                a = window.event;
                a = void 0 === a ? 16 : jd(a.type);
                return a;
            }
            function gi(a, b, c, d) {
                if (50 < yk) throw yk = 0, zk = null, Error(p(185));
                Ac(a, c, d);
                if (0 === (K & 2) || a !== Q) a === Q && (0 === (K & 2) && (qk |= c), 4 === T && Ck(a, Z)), 
                Dk(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Gj = B() + 500, fg && jg());
            }
            function Dk(a, b) {
                var c = a.callbackNode;
                wc(a, b);
                var d = uc(a, a === Q ? Z : 0);
                if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0; else if (b = d & -d, 
                a.callbackPriority !== b) {
                    null != c && bc(c);
                    if (1 === b) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
                        0 === (K & 6) && jg();
                    }), c = null; else {
                        switch (Dc(d)) {
                          case 1:
                            c = fc;
                            break;

                          case 4:
                            c = gc;
                            break;

                          case 16:
                            c = hc;
                            break;

                          case 536870912:
                            c = jc;
                            break;

                          default:
                            c = hc;
                        }
                        c = Fk(c, Gk.bind(null, a));
                    }
                    a.callbackPriority = b;
                    a.callbackNode = c;
                }
            }
            function Gk(a, b) {
                Ak = -1;
                Bk = 0;
                if (0 !== (K & 6)) throw Error(p(327));
                var c = a.callbackNode;
                if (Hk() && a.callbackNode !== c) return null;
                var d = uc(a, a === Q ? Z : 0);
                if (0 === d) return null;
                if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Ik(a, d); else {
                    b = d;
                    var e = K;
                    K |= 2;
                    var f = Jk();
                    if (Q !== a || Z !== b) uk = null, Gj = B() + 500, Kk(a, b);
                    do {
                        try {
                            Lk();
                            break;
                        } catch (h) {
                            Mk(a, h);
                        }
                    } while (1);
                    $g();
                    mk.current = f;
                    K = e;
                    null !== Y ? b = 0 : (Q = null, Z = 0, b = T);
                }
                if (0 !== b) {
                    2 === b && (e = xc(a), 0 !== e && (d = e, b = Nk(a, e)));
                    if (1 === b) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
                    if (6 === b) Ck(a, d); else {
                        e = a.current.alternate;
                        if (0 === (d & 30) && !Ok(e) && (b = Ik(a, d), 2 === b && (f = xc(a), 0 !== f && (d = f, 
                        b = Nk(a, f))), 1 === b)) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
                        a.finishedWork = e;
                        a.finishedLanes = d;
                        switch (b) {
                          case 0:
                          case 1:
                            throw Error(p(345));

                          case 2:
                            Pk(a, tk, uk);
                            break;

                          case 3:
                            Ck(a, d);
                            if ((d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
                                if (0 !== uc(a, 0)) break;
                                e = a.suspendedLanes;
                                if ((e & d) !== d) {
                                    R();
                                    a.pingedLanes |= a.suspendedLanes & e;
                                    break;
                                }
                                a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
                                break;
                            }
                            Pk(a, tk, uk);
                            break;

                          case 4:
                            Ck(a, d);
                            if ((d & 4194240) === d) break;
                            b = a.eventTimes;
                            for (e = -1; 0 < d; ) {
                                var g = 31 - oc(d);
                                f = 1 << g;
                                g = b[g];
                                g > e && (e = g);
                                d &= ~f;
                            }
                            d = e;
                            d = B() - d;
                            d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
                            if (10 < d) {
                                a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
                                break;
                            }
                            Pk(a, tk, uk);
                            break;

                          case 5:
                            Pk(a, tk, uk);
                            break;

                          default:
                            throw Error(p(329));
                        }
                    }
                }
                Dk(a, B());
                return a.callbackNode === c ? Gk.bind(null, a) : null;
            }
            function Nk(a, b) {
                var c = sk;
                a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256);
                a = Ik(a, b);
                2 !== a && (b = tk, tk = c, null !== b && Fj(b));
                return a;
            }
            function Fj(a) {
                null === tk ? tk = a : tk.push.apply(tk, a);
            }
            function Ok(a) {
                for (var b = a; ;) {
                    if (b.flags & 16384) {
                        var c = b.updateQueue;
                        if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
                            var e = c[d], f = e.getSnapshot;
                            e = e.value;
                            try {
                                if (!He(f(), e)) return !1;
                            } catch (g) {
                                return !1;
                            }
                        }
                    }
                    c = b.child;
                    if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c; else {
                        if (b === a) break;
                        for (;null === b.sibling; ) {
                            if (null === b.return || b.return === a) return !0;
                            b = b.return;
                        }
                        b.sibling.return = b.return;
                        b = b.sibling;
                    }
                }
                return !0;
            }
            function Ck(a, b) {
                b &= ~rk;
                b &= ~qk;
                a.suspendedLanes |= b;
                a.pingedLanes &= ~b;
                for (a = a.expirationTimes; 0 < b; ) {
                    var c = 31 - oc(b), d = 1 << c;
                    a[c] = -1;
                    b &= ~d;
                }
            }
            function Ek(a) {
                if (0 !== (K & 6)) throw Error(p(327));
                Hk();
                var b = uc(a, 0);
                if (0 === (b & 1)) return Dk(a, B()), null;
                var c = Ik(a, b);
                if (0 !== a.tag && 2 === c) {
                    var d = xc(a);
                    0 !== d && (b = d, c = Nk(a, d));
                }
                if (1 === c) throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B()), c;
                if (6 === c) throw Error(p(345));
                a.finishedWork = a.current.alternate;
                a.finishedLanes = b;
                Pk(a, tk, uk);
                Dk(a, B());
                return null;
            }
            function Qk(a, b) {
                var c = K;
                K |= 1;
                try {
                    return a(b);
                } finally {
                    K = c, 0 === K && (Gj = B() + 500, fg && jg());
                }
            }
            function Rk(a) {
                null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
                var b = K;
                K |= 1;
                var c = ok.transition, d = C;
                try {
                    if (ok.transition = null, C = 1, a) return a();
                } finally {
                    C = d, ok.transition = c, K = b, 0 === (K & 6) && jg();
                }
            }
            function Hj() {
                fj = ej.current;
                E(ej);
            }
            function Kk(a, b) {
                a.finishedWork = null;
                a.finishedLanes = 0;
                var c = a.timeoutHandle;
                -1 !== c && (a.timeoutHandle = -1, Gf(c));
                if (null !== Y) for (c = Y.return; null !== c; ) {
                    var d = c;
                    wg(d);
                    switch (d.tag) {
                      case 1:
                        d = d.type.childContextTypes;
                        null !== d && void 0 !== d && $f();
                        break;

                      case 3:
                        zh();
                        E(Wf);
                        E(H);
                        Eh();
                        break;

                      case 5:
                        Bh(d);
                        break;

                      case 4:
                        zh();
                        break;

                      case 13:
                        E(L);
                        break;

                      case 19:
                        E(L);
                        break;

                      case 10:
                        ah(d.type._context);
                        break;

                      case 22:
                      case 23:
                        Hj();
                    }
                    c = c.return;
                }
                Q = a;
                Y = a = Pg(a.current, null);
                Z = fj = b;
                T = 0;
                pk = null;
                rk = qk = rh = 0;
                tk = sk = null;
                if (null !== fh) {
                    for (b = 0; b < fh.length; b++) if (c = fh[b], d = c.interleaved, null !== d) {
                        c.interleaved = null;
                        var e = d.next, f = c.pending;
                        if (null !== f) {
                            var g = f.next;
                            f.next = e;
                            d.next = g;
                        }
                        c.pending = d;
                    }
                    fh = null;
                }
                return a;
            }
            function Mk(a, b) {
                do {
                    var c = Y;
                    try {
                        $g();
                        Fh.current = Rh;
                        if (Ih) {
                            for (var d = M.memoizedState; null !== d; ) {
                                var e = d.queue;
                                null !== e && (e.pending = null);
                                d = d.next;
                            }
                            Ih = !1;
                        }
                        Hh = 0;
                        O = N = M = null;
                        Jh = !1;
                        Kh = 0;
                        nk.current = null;
                        if (null === c || null === c.return) {
                            T = 1;
                            pk = b;
                            Y = null;
                            break;
                        }
                        a: {
                            var f = a, g = c.return, h = c, k = b;
                            b = Z;
                            h.flags |= 32768;
                            if (null !== k && "object" === typeof k && "function" === typeof k.then) {
                                var l = k, m = h, q = m.tag;
                                if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
                                    var r = m.alternate;
                                    r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, 
                                    m.memoizedState = null);
                                }
                                var y = Ui(g);
                                if (null !== y) {
                                    y.flags &= -257;
                                    Vi(y, g, h, f, b);
                                    y.mode & 1 && Si(f, l, b);
                                    b = y;
                                    k = l;
                                    var n = b.updateQueue;
                                    if (null === n) {
                                        var t = new Set;
                                        t.add(k);
                                        b.updateQueue = t;
                                    } else n.add(k);
                                    break a;
                                } else {
                                    if (0 === (b & 1)) {
                                        Si(f, l, b);
                                        tj();
                                        break a;
                                    }
                                    k = Error(p(426));
                                }
                            } else if (I && h.mode & 1) {
                                var J = Ui(g);
                                if (null !== J) {
                                    0 === (J.flags & 65536) && (J.flags |= 256);
                                    Vi(J, g, h, f, b);
                                    Jg(Ji(k, h));
                                    break a;
                                }
                            }
                            f = k = Ji(k, h);
                            4 !== T && (T = 2);
                            null === sk ? sk = [ f ] : sk.push(f);
                            f = g;
                            do {
                                switch (f.tag) {
                                  case 3:
                                    f.flags |= 65536;
                                    b &= -b;
                                    f.lanes |= b;
                                    var x = Ni(f, k, b);
                                    ph(f, x);
                                    break a;

                                  case 1:
                                    h = k;
                                    var w = f.type, u = f.stateNode;
                                    if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Ri || !Ri.has(u)))) {
                                        f.flags |= 65536;
                                        b &= -b;
                                        f.lanes |= b;
                                        var F = Qi(f, h, b);
                                        ph(f, F);
                                        break a;
                                    }
                                }
                                f = f.return;
                            } while (null !== f);
                        }
                        Sk(c);
                    } catch (na) {
                        b = na;
                        Y === c && null !== c && (Y = c = c.return);
                        continue;
                    }
                    break;
                } while (1);
            }
            function Jk() {
                var a = mk.current;
                mk.current = Rh;
                return null === a ? Rh : a;
            }
            function tj() {
                if (0 === T || 3 === T || 2 === T) T = 4;
                null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
            }
            function Ik(a, b) {
                var c = K;
                K |= 2;
                var d = Jk();
                if (Q !== a || Z !== b) uk = null, Kk(a, b);
                do {
                    try {
                        Tk();
                        break;
                    } catch (e) {
                        Mk(a, e);
                    }
                } while (1);
                $g();
                K = c;
                mk.current = d;
                if (null !== Y) throw Error(p(261));
                Q = null;
                Z = 0;
                return T;
            }
            function Tk() {
                for (;null !== Y; ) Uk(Y);
            }
            function Lk() {
                for (;null !== Y && !cc(); ) Uk(Y);
            }
            function Uk(a) {
                var b = Vk(a.alternate, a, fj);
                a.memoizedProps = a.pendingProps;
                null === b ? Sk(a) : Y = b;
                nk.current = null;
            }
            function Sk(a) {
                var b = a;
                do {
                    var c = b.alternate;
                    a = b.return;
                    if (0 === (b.flags & 32768)) {
                        if (c = Ej(c, b, fj), null !== c) {
                            Y = c;
                            return;
                        }
                    } else {
                        c = Ij(c, b);
                        if (null !== c) {
                            c.flags &= 32767;
                            Y = c;
                            return;
                        }
                        if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null; else {
                            T = 6;
                            Y = null;
                            return;
                        }
                    }
                    b = b.sibling;
                    if (null !== b) {
                        Y = b;
                        return;
                    }
                    Y = b = a;
                } while (null !== b);
                0 === T && (T = 5);
            }
            function Pk(a, b, c) {
                var d = C, e = ok.transition;
                try {
                    ok.transition = null, C = 1, Wk(a, b, c, d);
                } finally {
                    ok.transition = e, C = d;
                }
                return null;
            }
            function Wk(a, b, c, d) {
                do {
                    Hk();
                } while (null !== wk);
                if (0 !== (K & 6)) throw Error(p(327));
                c = a.finishedWork;
                var e = a.finishedLanes;
                if (null === c) return null;
                a.finishedWork = null;
                a.finishedLanes = 0;
                if (c === a.current) throw Error(p(177));
                a.callbackNode = null;
                a.callbackPriority = 0;
                var f = c.lanes | c.childLanes;
                Bc(a, f);
                a === Q && (Y = Q = null, Z = 0);
                0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = !0, Fk(hc, function() {
                    Hk();
                    return null;
                }));
                f = 0 !== (c.flags & 15990);
                if (0 !== (c.subtreeFlags & 15990) || f) {
                    f = ok.transition;
                    ok.transition = null;
                    var g = C;
                    C = 1;
                    var h = K;
                    K |= 4;
                    nk.current = null;
                    Oj(a, c);
                    dk(c, a);
                    Oe(Df);
                    dd = !!Cf;
                    Df = Cf = null;
                    a.current = c;
                    hk(c, a, e);
                    dc();
                    K = h;
                    C = g;
                    ok.transition = f;
                } else a.current = c;
                vk && (vk = !1, wk = a, xk = e);
                f = a.pendingLanes;
                0 === f && (Ri = null);
                mc(c.stateNode, d);
                Dk(a, B());
                if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], 
                d(e.value, {
                    componentStack: e.stack,
                    digest: e.digest
                });
                if (Oi) throw Oi = !1, a = Pi, Pi = null, a;
                0 !== (xk & 1) && 0 !== a.tag && Hk();
                f = a.pendingLanes;
                0 !== (f & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
                jg();
                return null;
            }
            function Hk() {
                if (null !== wk) {
                    var a = Dc(xk), b = ok.transition, c = C;
                    try {
                        ok.transition = null;
                        C = 16 > a ? 16 : a;
                        if (null === wk) var d = !1; else {
                            a = wk;
                            wk = null;
                            xk = 0;
                            if (0 !== (K & 6)) throw Error(p(331));
                            var e = K;
                            K |= 4;
                            for (V = a.current; null !== V; ) {
                                var f = V, g = f.child;
                                if (0 !== (V.flags & 16)) {
                                    var h = f.deletions;
                                    if (null !== h) {
                                        for (var k = 0; k < h.length; k++) {
                                            var l = h[k];
                                            for (V = l; null !== V; ) {
                                                var m = V;
                                                switch (m.tag) {
                                                  case 0:
                                                  case 11:
                                                  case 15:
                                                    Pj(8, m, f);
                                                }
                                                var q = m.child;
                                                if (null !== q) q.return = m, V = q; else for (;null !== V; ) {
                                                    m = V;
                                                    var r = m.sibling, y = m.return;
                                                    Sj(m);
                                                    if (m === l) {
                                                        V = null;
                                                        break;
                                                    }
                                                    if (null !== r) {
                                                        r.return = y;
                                                        V = r;
                                                        break;
                                                    }
                                                    V = y;
                                                }
                                            }
                                        }
                                        var n = f.alternate;
                                        if (null !== n) {
                                            var t = n.child;
                                            if (null !== t) {
                                                n.child = null;
                                                do {
                                                    var J = t.sibling;
                                                    t.sibling = null;
                                                    t = J;
                                                } while (null !== t);
                                            }
                                        }
                                        V = f;
                                    }
                                }
                                if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g; else b: for (;null !== V; ) {
                                    f = V;
                                    if (0 !== (f.flags & 2048)) switch (f.tag) {
                                      case 0:
                                      case 11:
                                      case 15:
                                        Pj(9, f, f.return);
                                    }
                                    var x = f.sibling;
                                    if (null !== x) {
                                        x.return = f.return;
                                        V = x;
                                        break b;
                                    }
                                    V = f.return;
                                }
                            }
                            var w = a.current;
                            for (V = w; null !== V; ) {
                                g = V;
                                var u = g.child;
                                if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u; else b: for (g = w; null !== V; ) {
                                    h = V;
                                    if (0 !== (h.flags & 2048)) try {
                                        switch (h.tag) {
                                          case 0:
                                          case 11:
                                          case 15:
                                            Qj(9, h);
                                        }
                                    } catch (na) {
                                        W(h, h.return, na);
                                    }
                                    if (h === g) {
                                        V = null;
                                        break b;
                                    }
                                    var F = h.sibling;
                                    if (null !== F) {
                                        F.return = h.return;
                                        V = F;
                                        break b;
                                    }
                                    V = h.return;
                                }
                            }
                            K = e;
                            jg();
                            if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
                                lc.onPostCommitFiberRoot(kc, a);
                            } catch (na) {}
                            d = !0;
                        }
                        return d;
                    } finally {
                        C = c, ok.transition = b;
                    }
                }
                return !1;
            }
            function Xk(a, b, c) {
                b = Ji(c, b);
                b = Ni(a, b, 1);
                a = nh(a, b, 1);
                b = R();
                null !== a && (Ac(a, 1, b), Dk(a, b));
            }
            function W(a, b, c) {
                if (3 === a.tag) Xk(a, a, c); else for (;null !== b; ) {
                    if (3 === b.tag) {
                        Xk(b, a, c);
                        break;
                    } else if (1 === b.tag) {
                        var d = b.stateNode;
                        if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
                            a = Ji(c, a);
                            a = Qi(b, a, 1);
                            b = nh(b, a, 1);
                            a = R();
                            null !== b && (Ac(b, 1, a), Dk(b, a));
                            break;
                        }
                    }
                    b = b.return;
                }
            }
            function Ti(a, b, c) {
                var d = a.pingCache;
                null !== d && d.delete(b);
                b = R();
                a.pingedLanes |= a.suspendedLanes & c;
                Q === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c);
                Dk(a, b);
            }
            function Yk(a, b) {
                0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
                var c = R();
                a = ih(a, b);
                null !== a && (Ac(a, b, c), Dk(a, c));
            }
            function uj(a) {
                var b = a.memoizedState, c = 0;
                null !== b && (c = b.retryLane);
                Yk(a, c);
            }
            function bk(a, b) {
                var c = 0;
                switch (a.tag) {
                  case 13:
                    var d = a.stateNode;
                    var e = a.memoizedState;
                    null !== e && (c = e.retryLane);
                    break;

                  case 19:
                    d = a.stateNode;
                    break;

                  default:
                    throw Error(p(314));
                }
                null !== d && d.delete(b);
                Yk(a, c);
            }
            var Vk;
            Vk = function(a, b, c) {
                if (null !== a) if (a.memoizedProps !== b.pendingProps || Wf.current) dh = !0; else {
                    if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return dh = !1, yj(a, b, c);
                    dh = 0 !== (a.flags & 131072) ? !0 : !1;
                } else dh = !1, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
                b.lanes = 0;
                switch (b.tag) {
                  case 2:
                    var d = b.type;
                    ij(a, b);
                    a = b.pendingProps;
                    var e = Yf(b, H.current);
                    ch(b, c);
                    e = Nh(null, b, d, a, e, c);
                    var f = Sh();
                    b.flags |= 1;
                    "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, 
                    b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = !0, cg(b)) : f = !1, 
                    b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b), 
                    e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a, c), b = jj(null, b, d, !0, f, c)) : (b.tag = 0, 
                    I && f && vg(b), Xi(null, b, e, c), b = b.child);
                    return b;

                  case 16:
                    d = b.elementType;
                    a: {
                        ij(a, b);
                        a = b.pendingProps;
                        e = d._init;
                        d = e(d._payload);
                        b.type = d;
                        e = b.tag = Zk(d);
                        a = Ci(d, a);
                        switch (e) {
                          case 0:
                            b = cj(null, b, d, a, c);
                            break a;

                          case 1:
                            b = hj(null, b, d, a, c);
                            break a;

                          case 11:
                            b = Yi(null, b, d, a, c);
                            break a;

                          case 14:
                            b = $i(null, b, d, Ci(d.type, a), c);
                            break a;
                        }
                        throw Error(p(306, d, ""));
                    }
                    return b;

                  case 0:
                    return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a, b, d, e, c);

                  case 1:
                    return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a, b, d, e, c);

                  case 3:
                    a: {
                        kj(b);
                        if (null === a) throw Error(p(387));
                        d = b.pendingProps;
                        f = b.memoizedState;
                        e = f.element;
                        lh(a, b);
                        qh(b, d, null, c);
                        var g = b.memoizedState;
                        d = g.element;
                        if (f.isDehydrated) if (f = {
                            element: d,
                            isDehydrated: !1,
                            cache: g.cache,
                            pendingSuspenseBoundaries: g.pendingSuspenseBoundaries,
                            transitions: g.transitions
                        }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
                            e = Ji(Error(p(423)), b);
                            b = lj(a, b, d, c, e);
                            break a;
                        } else if (d !== e) {
                            e = Ji(Error(p(424)), b);
                            b = lj(a, b, d, c, e);
                            break a;
                        } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = !0, zg = null, 
                        c = Vg(b, null, d, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling; else {
                            Ig();
                            if (d === e) {
                                b = Zi(a, b, c);
                                break a;
                            }
                            Xi(a, b, d, c);
                        }
                        b = b.child;
                    }
                    return b;

                  case 5:
                    return Ah(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, 
                    g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), 
                    gj(a, b), Xi(a, b, g, c), b.child;

                  case 6:
                    return null === a && Eg(b), null;

                  case 13:
                    return oj(a, b, c);

                  case 4:
                    return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Ug(b, null, d, c) : Xi(a, b, d, c), 
                    b.child;

                  case 11:
                    return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a, b, d, e, c);

                  case 7:
                    return Xi(a, b, b.pendingProps, c), b.child;

                  case 8:
                    return Xi(a, b, b.pendingProps.children, c), b.child;

                  case 12:
                    return Xi(a, b, b.pendingProps.children, c), b.child;

                  case 10:
                    a: {
                        d = b.type._context;
                        e = b.pendingProps;
                        f = b.memoizedProps;
                        g = e.value;
                        G(Wg, d._currentValue);
                        d._currentValue = g;
                        if (null !== f) if (He(f.value, g)) {
                            if (f.children === e.children && !Wf.current) {
                                b = Zi(a, b, c);
                                break a;
                            }
                        } else for (f = b.child, null !== f && (f.return = b); null !== f; ) {
                            var h = f.dependencies;
                            if (null !== h) {
                                g = f.child;
                                for (var k = h.firstContext; null !== k; ) {
                                    if (k.context === d) {
                                        if (1 === f.tag) {
                                            k = mh(-1, c & -c);
                                            k.tag = 2;
                                            var l = f.updateQueue;
                                            if (null !== l) {
                                                l = l.shared;
                                                var m = l.pending;
                                                null === m ? k.next = k : (k.next = m.next, m.next = k);
                                                l.pending = k;
                                            }
                                        }
                                        f.lanes |= c;
                                        k = f.alternate;
                                        null !== k && (k.lanes |= c);
                                        bh(f.return, c, b);
                                        h.lanes |= c;
                                        break;
                                    }
                                    k = k.next;
                                }
                            } else if (10 === f.tag) g = f.type === b.type ? null : f.child; else if (18 === f.tag) {
                                g = f.return;
                                if (null === g) throw Error(p(341));
                                g.lanes |= c;
                                h = g.alternate;
                                null !== h && (h.lanes |= c);
                                bh(g, c, b);
                                g = f.sibling;
                            } else g = f.child;
                            if (null !== g) g.return = f; else for (g = f; null !== g; ) {
                                if (g === b) {
                                    g = null;
                                    break;
                                }
                                f = g.sibling;
                                if (null !== f) {
                                    f.return = g.return;
                                    g = f;
                                    break;
                                }
                                g = g.return;
                            }
                            f = g;
                        }
                        Xi(a, b, e.children, c);
                        b = b.child;
                    }
                    return b;

                  case 9:
                    return e = b.type, d = b.pendingProps.children, ch(b, c), e = eh(e), d = d(e), b.flags |= 1, 
                    Xi(a, b, d, c), b.child;

                  case 14:
                    return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a, b, d, e, c);

                  case 15:
                    return bj(a, b, b.type, b.pendingProps, c);

                  case 17:
                    return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a, b), 
                    b.tag = 1, Zf(d) ? (a = !0, cg(b)) : a = !1, ch(b, c), Gi(b, d, e), Ii(b, d, e, c), 
                    jj(null, b, d, !0, a, c);

                  case 19:
                    return xj(a, b, c);

                  case 22:
                    return dj(a, b, c);
                }
                throw Error(p(156, b.tag));
            };
            function Fk(a, b) {
                return ac(a, b);
            }
            function $k(a, b, c, d) {
                this.tag = a;
                this.key = c;
                this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
                this.index = 0;
                this.ref = null;
                this.pendingProps = b;
                this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
                this.mode = d;
                this.subtreeFlags = this.flags = 0;
                this.deletions = null;
                this.childLanes = this.lanes = 0;
                this.alternate = null;
            }
            function Bg(a, b, c, d) {
                return new $k(a, b, c, d);
            }
            function aj(a) {
                a = a.prototype;
                return !(!a || !a.isReactComponent);
            }
            function Zk(a) {
                if ("function" === typeof a) return aj(a) ? 1 : 0;
                if (void 0 !== a && null !== a) {
                    a = a.$$typeof;
                    if (a === Da) return 11;
                    if (a === Ga) return 14;
                }
                return 2;
            }
            function Pg(a, b) {
                var c = a.alternate;
                null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, 
                c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, 
                c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
                c.flags = a.flags & 14680064;
                c.childLanes = a.childLanes;
                c.lanes = a.lanes;
                c.child = a.child;
                c.memoizedProps = a.memoizedProps;
                c.memoizedState = a.memoizedState;
                c.updateQueue = a.updateQueue;
                b = a.dependencies;
                c.dependencies = null === b ? null : {
                    lanes: b.lanes,
                    firstContext: b.firstContext
                };
                c.sibling = a.sibling;
                c.index = a.index;
                c.ref = a.ref;
                return c;
            }
            function Rg(a, b, c, d, e, f) {
                var g = 2;
                d = a;
                if ("function" === typeof a) aj(a) && (g = 1); else if ("string" === typeof a) g = 5; else a: switch (a) {
                  case ya:
                    return Tg(c.children, e, f, b);

                  case za:
                    g = 8;
                    e |= 8;
                    break;

                  case Aa:
                    return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;

                  case Ea:
                    return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;

                  case Fa:
                    return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;

                  case Ia:
                    return pj(c, e, f, b);

                  default:
                    if ("object" === typeof a && null !== a) switch (a.$$typeof) {
                      case Ba:
                        g = 10;
                        break a;

                      case Ca:
                        g = 9;
                        break a;

                      case Da:
                        g = 11;
                        break a;

                      case Ga:
                        g = 14;
                        break a;

                      case Ha:
                        g = 16;
                        d = null;
                        break a;
                    }
                    throw Error(p(130, null == a ? a : typeof a, ""));
                }
                b = Bg(g, c, b, e);
                b.elementType = a;
                b.type = d;
                b.lanes = f;
                return b;
            }
            function Tg(a, b, c, d) {
                a = Bg(7, a, d, b);
                a.lanes = c;
                return a;
            }
            function pj(a, b, c, d) {
                a = Bg(22, a, d, b);
                a.elementType = Ia;
                a.lanes = c;
                a.stateNode = {
                    isHidden: !1
                };
                return a;
            }
            function Qg(a, b, c) {
                a = Bg(6, a, null, b);
                a.lanes = c;
                return a;
            }
            function Sg(a, b, c) {
                b = Bg(4, null !== a.children ? a.children : [], a.key, b);
                b.lanes = c;
                b.stateNode = {
                    containerInfo: a.containerInfo,
                    pendingChildren: null,
                    implementation: a.implementation
                };
                return b;
            }
            function al(a, b, c, d, e) {
                this.tag = b;
                this.containerInfo = a;
                this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
                this.timeoutHandle = -1;
                this.callbackNode = this.pendingContext = this.context = null;
                this.callbackPriority = 0;
                this.eventTimes = zc(0);
                this.expirationTimes = zc(-1);
                this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
                this.entanglements = zc(0);
                this.identifierPrefix = d;
                this.onRecoverableError = e;
                this.mutableSourceEagerHydrationData = null;
            }
            function bl(a, b, c, d, e, f, g, h, k) {
                a = new al(a, b, c, h, k);
                1 === b ? (b = 1, !0 === f && (b |= 8)) : b = 0;
                f = Bg(3, null, null, b);
                a.current = f;
                f.stateNode = a;
                f.memoizedState = {
                    element: d,
                    isDehydrated: c,
                    cache: null,
                    transitions: null,
                    pendingSuspenseBoundaries: null
                };
                kh(f);
                return a;
            }
            function cl(a, b, c) {
                var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
                return {
                    $$typeof: wa,
                    key: null == d ? null : "" + d,
                    children: a,
                    containerInfo: b,
                    implementation: c
                };
            }
            function dl(a) {
                if (!a) return Vf;
                a = a._reactInternals;
                a: {
                    if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
                    var b = a;
                    do {
                        switch (b.tag) {
                          case 3:
                            b = b.stateNode.context;
                            break a;

                          case 1:
                            if (Zf(b.type)) {
                                b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                                break a;
                            }
                        }
                        b = b.return;
                    } while (null !== b);
                    throw Error(p(171));
                }
                if (1 === a.tag) {
                    var c = a.type;
                    if (Zf(c)) return bg(a, c, b);
                }
                return b;
            }
            function el(a, b, c, d, e, f, g, h, k) {
                a = bl(c, d, !0, a, e, f, g, h, k);
                a.context = dl(null);
                c = a.current;
                d = R();
                e = yi(c);
                f = mh(d, e);
                f.callback = void 0 !== b && null !== b ? b : null;
                nh(c, f, e);
                a.current.lanes = e;
                Ac(a, e, d);
                Dk(a, d);
                return a;
            }
            function fl(a, b, c, d) {
                var e = b.current, f = R(), g = yi(e);
                c = dl(c);
                null === b.context ? b.context = c : b.pendingContext = c;
                b = mh(f, g);
                b.payload = {
                    element: a
                };
                d = void 0 === d ? null : d;
                null !== d && (b.callback = d);
                a = nh(e, b, g);
                null !== a && (gi(a, e, g, f), oh(a, e, g));
                return g;
            }
            function gl(a) {
                a = a.current;
                if (!a.child) return null;
                switch (a.child.tag) {
                  case 5:
                    return a.child.stateNode;

                  default:
                    return a.child.stateNode;
                }
            }
            function hl(a, b) {
                a = a.memoizedState;
                if (null !== a && null !== a.dehydrated) {
                    var c = a.retryLane;
                    a.retryLane = 0 !== c && c < b ? c : b;
                }
            }
            function il(a, b) {
                hl(a, b);
                (a = a.alternate) && hl(a, b);
            }
            function jl() {
                return null;
            }
            var kl = "function" === typeof reportError ? reportError : function(a) {
                console.error(a);
            };
            function ll(a) {
                this._internalRoot = a;
            }
            ml.prototype.render = ll.prototype.render = function(a) {
                var b = this._internalRoot;
                if (null === b) throw Error(p(409));
                fl(a, b, null, null);
            };
            ml.prototype.unmount = ll.prototype.unmount = function() {
                var a = this._internalRoot;
                if (null !== a) {
                    this._internalRoot = null;
                    var b = a.containerInfo;
                    Rk(function() {
                        fl(null, a, null, null);
                    });
                    b[uf] = null;
                }
            };
            function ml(a) {
                this._internalRoot = a;
            }
            ml.prototype.unstable_scheduleHydration = function(a) {
                if (a) {
                    var b = Hc();
                    a = {
                        blockedOn: null,
                        target: a,
                        priority: b
                    };
                    for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++) ;
                    Qc.splice(c, 0, a);
                    0 === c && Vc(a);
                }
            };
            function nl(a) {
                return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
            }
            function ol(a) {
                return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
            }
            function pl() {}
            function ql(a, b, c, d, e) {
                if (e) {
                    if ("function" === typeof d) {
                        var f = d;
                        d = function() {
                            var a = gl(g);
                            f.call(a);
                        };
                    }
                    var g = el(b, d, a, 0, null, !1, !1, "", pl);
                    a._reactRootContainer = g;
                    a[uf] = g.current;
                    sf(8 === a.nodeType ? a.parentNode : a);
                    Rk();
                    return g;
                }
                for (;e = a.lastChild; ) a.removeChild(e);
                if ("function" === typeof d) {
                    var h = d;
                    d = function() {
                        var a = gl(k);
                        h.call(a);
                    };
                }
                var k = bl(a, 0, !1, null, null, !1, !1, "", pl);
                a._reactRootContainer = k;
                a[uf] = k.current;
                sf(8 === a.nodeType ? a.parentNode : a);
                Rk(function() {
                    fl(b, k, c, d);
                });
                return k;
            }
            function rl(a, b, c, d, e) {
                var f = c._reactRootContainer;
                if (f) {
                    var g = f;
                    if ("function" === typeof e) {
                        var h = e;
                        e = function() {
                            var a = gl(g);
                            h.call(a);
                        };
                    }
                    fl(b, g, a, e);
                } else g = ql(c, b, a, e, d);
                return gl(g);
            }
            Ec = function(a) {
                switch (a.tag) {
                  case 3:
                    var b = a.stateNode;
                    if (b.current.memoizedState.isDehydrated) {
                        var c = tc(b.pendingLanes);
                        0 !== c && (Cc(b, c | 1), Dk(b, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
                    }
                    break;

                  case 13:
                    Rk(function() {
                        var b = ih(a, 1);
                        if (null !== b) {
                            var c = R();
                            gi(b, a, 1, c);
                        }
                    }), il(a, 1);
                }
            };
            Fc = function(a) {
                if (13 === a.tag) {
                    var b = ih(a, 134217728);
                    if (null !== b) {
                        var c = R();
                        gi(b, a, 134217728, c);
                    }
                    il(a, 134217728);
                }
            };
            Gc = function(a) {
                if (13 === a.tag) {
                    var b = yi(a), c = ih(a, b);
                    if (null !== c) {
                        var d = R();
                        gi(c, a, b, d);
                    }
                    il(a, b);
                }
            };
            Hc = function() {
                return C;
            };
            Ic = function(a, b) {
                var c = C;
                try {
                    return C = a, b();
                } finally {
                    C = c;
                }
            };
            yb = function(a, b, c) {
                switch (b) {
                  case "input":
                    bb(a, c);
                    b = c.name;
                    if ("radio" === c.type && null != b) {
                        for (c = a; c.parentNode; ) c = c.parentNode;
                        c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
                        for (b = 0; b < c.length; b++) {
                            var d = c[b];
                            if (d !== a && d.form === a.form) {
                                var e = Db(d);
                                if (!e) throw Error(p(90));
                                Wa(d);
                                bb(d, e);
                            }
                        }
                    }
                    break;

                  case "textarea":
                    ib(a, c);
                    break;

                  case "select":
                    b = c.value, null != b && fb(a, !!c.multiple, b, !1);
                }
            };
            Gb = Qk;
            Hb = Rk;
            var sl = {
                usingClientEntryPoint: !1,
                Events: [ Cb, ue, Db, Eb, Fb, Qk ]
            }, tl = {
                findFiberByHostInstance: Wc,
                bundleType: 0,
                version: "18.3.1",
                rendererPackageName: "react-dom"
            };
            var ul = {
                bundleType: tl.bundleType,
                version: tl.version,
                rendererPackageName: tl.rendererPackageName,
                rendererConfig: tl.rendererConfig,
                overrideHookState: null,
                overrideHookStateDeletePath: null,
                overrideHookStateRenamePath: null,
                overrideProps: null,
                overridePropsDeletePath: null,
                overridePropsRenamePath: null,
                setErrorHandler: null,
                setSuspenseHandler: null,
                scheduleUpdate: null,
                currentDispatcherRef: ua.ReactCurrentDispatcher,
                findHostInstanceByFiber: function(a) {
                    a = Zb(a);
                    return null === a ? null : a.stateNode;
                },
                findFiberByHostInstance: tl.findFiberByHostInstance || jl,
                findHostInstancesForRefresh: null,
                scheduleRefresh: null,
                scheduleRoot: null,
                setRefreshHandler: null,
                getCurrentFiber: null,
                reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
            };
            if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
                var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                if (!vl.isDisabled && vl.supportsFiber) try {
                    kc = vl.inject(ul), lc = vl;
                } catch (a) {}
            }
            exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
            exports.createPortal = function(a, b) {
                var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
                if (!nl(b)) throw Error(p(200));
                return cl(a, b, null, c);
            };
            exports.createRoot = function(a, b) {
                if (!nl(a)) throw Error(p(299));
                var c = !1, d = "", e = kl;
                null !== b && void 0 !== b && (!0 === b.unstable_strictMode && (c = !0), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), 
                void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
                b = bl(a, 1, !1, null, null, c, !1, d, e);
                a[uf] = b.current;
                sf(8 === a.nodeType ? a.parentNode : a);
                return new ll(b);
            };
            exports.findDOMNode = function(a) {
                if (null == a) return null;
                if (1 === a.nodeType) return a;
                var b = a._reactInternals;
                if (void 0 === b) {
                    if ("function" === typeof a.render) throw Error(p(188));
                    a = Object.keys(a).join(",");
                    throw Error(p(268, a));
                }
                a = Zb(b);
                a = null === a ? null : a.stateNode;
                return a;
            };
            exports.flushSync = function(a) {
                return Rk(a);
            };
            exports.hydrate = function(a, b, c) {
                if (!ol(b)) throw Error(p(200));
                return rl(null, a, b, !0, c);
            };
            exports.hydrateRoot = function(a, b, c) {
                if (!nl(a)) throw Error(p(405));
                var d = null != c && c.hydratedSources || null, e = !1, f = "", g = kl;
                null !== c && void 0 !== c && (!0 === c.unstable_strictMode && (e = !0), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), 
                void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
                b = el(b, null, a, 1, null != c ? c : null, e, !1, f, g);
                a[uf] = b.current;
                sf(a);
                if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), 
                null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [ c, e ] : b.mutableSourceEagerHydrationData.push(c, e);
                return new ml(b);
            };
            exports.render = function(a, b, c) {
                if (!ol(b)) throw Error(p(200));
                return rl(null, a, b, !1, c);
            };
            exports.unmountComponentAtNode = function(a) {
                if (!ol(a)) throw Error(p(40));
                return a._reactRootContainer ? (Rk(function() {
                    rl(null, null, a, !1, function() {
                        a._reactRootContainer = null;
                        a[uf] = null;
                    });
                }), !0) : !1;
            };
            exports.unstable_batchedUpdates = Qk;
            exports.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
                if (!ol(c)) throw Error(p(200));
                if (null == a || void 0 === a._reactInternals) throw Error(p(38));
                return rl(a, b, c, !1, d);
            };
            exports.version = "18.3.1-next-f1338f8080-20240426";
        },
        556: (module, __unused_webpack_exports, __webpack_require__) => {
            if (false) ; else module.exports = __webpack_require__(694)();
        },
        694: (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var ReactPropTypesSecret = __webpack_require__(925);
            function emptyFunction() {}
            function emptyFunctionWithReset() {}
            emptyFunctionWithReset.resetWarningCache = emptyFunction;
            module.exports = function() {
                function shim(props, propName, componentName, location, propFullName, secret) {
                    if (secret === ReactPropTypesSecret) return;
                    var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. " + "Use PropTypes.checkPropTypes() to call them. " + "Read more at http://fb.me/use-check-prop-types");
                    err.name = "Invariant Violation";
                    throw err;
                }
                shim.isRequired = shim;
                function getShim() {
                    return shim;
                }
                var ReactPropTypes = {
                    array: shim,
                    bigint: shim,
                    bool: shim,
                    func: shim,
                    number: shim,
                    object: shim,
                    string: shim,
                    symbol: shim,
                    any: shim,
                    arrayOf: getShim,
                    element: shim,
                    elementType: shim,
                    instanceOf: getShim,
                    node: shim,
                    objectOf: getShim,
                    oneOf: getShim,
                    oneOfType: getShim,
                    shape: getShim,
                    exact: getShim,
                    checkPropTypes: emptyFunctionWithReset,
                    resetWarningCache: emptyFunction
                };
                ReactPropTypes.PropTypes = ReactPropTypes;
                return ReactPropTypes;
            };
        },
        848: (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            if (true) module.exports = __webpack_require__(20);
        },
        925: module => {
            "use strict";
            var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
            module.exports = ReactPropTypesSecret;
        },
        961: (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            function checkDCE() {
                if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") return;
                if (false) ;
                try {
                    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
                } catch (err) {
                    console.error(err);
                }
            }
            if (true) {
                checkDCE();
                module.exports = __webpack_require__(551);
            }
        },
        982: (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            if (true) module.exports = __webpack_require__(463);
        }
    };
    var __webpack_module_cache__ = {};
    function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0) return cachedModule.exports;
        var module = __webpack_module_cache__[moduleId] = {
            exports: {}
        };
        __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
        return module.exports;
    }
    (() => {
        __webpack_require__.n = module => {
            var getter = module && module.__esModule ? () => module["default"] : () => module;
            __webpack_require__.d(getter, {
                a: getter
            });
            return getter;
        };
    })();
    (() => {
        __webpack_require__.d = (exports, definition) => {
            for (var key in definition) if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) Object.defineProperty(exports, key, {
                enumerable: true,
                get: definition[key]
            });
        };
    })();
    (() => {
        __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
    })();
    (() => {
        "use strict";
        var react = __webpack_require__(540);
        var client = __webpack_require__(338);
        __webpack_require__(69);
        var Action = (Action2 => {
            Action2["Pop"] = "POP";
            Action2["Push"] = "PUSH";
            Action2["Replace"] = "REPLACE";
            return Action2;
        })(Action || {});
        var PopStateEventType = "popstate";
        function createHashHistory(options = {}) {
            function createHashLocation(window2, globalHistory) {
                let {pathname = "/", search = "", hash = ""} = parsePath(window2.location.hash.substring(1));
                if (!pathname.startsWith("/") && !pathname.startsWith(".")) pathname = "/" + pathname;
                return createLocation("", {
                    pathname,
                    search,
                    hash
                }, globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
            }
            function createHashHref(window2, to) {
                let base = window2.document.querySelector("base");
                let href2 = "";
                if (base && base.getAttribute("href")) {
                    let url = window2.location.href;
                    let hashIndex = url.indexOf("#");
                    href2 = hashIndex === -1 ? url : url.slice(0, hashIndex);
                }
                return href2 + "#" + (typeof to === "string" ? to : createPath(to));
            }
            function validateHashLocation(location, to) {
                warning(location.pathname.charAt(0) === "/", `relative pathnames are not supported in hash history.push(${JSON.stringify(to)})`);
            }
            return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
        }
        function invariant(value, message) {
            if (value === false || value === null || typeof value === "undefined") throw new Error(message);
        }
        function warning(cond, message) {
            if (!cond) {
                if (typeof console !== "undefined") console.warn(message);
                try {
                    throw new Error(message);
                } catch (e) {}
            }
        }
        function createKey() {
            return Math.random().toString(36).substring(2, 10);
        }
        function getHistoryState(location, index) {
            return {
                usr: location.state,
                key: location.key,
                idx: index
            };
        }
        function createLocation(current, to, state = null, key) {
            let location = {
                pathname: typeof current === "string" ? current : current.pathname,
                search: "",
                hash: "",
                ...typeof to === "string" ? parsePath(to) : to,
                state,
                key: to && to.key || key || createKey()
            };
            return location;
        }
        function createPath({pathname = "/", search = "", hash = ""}) {
            if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
            if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
            return pathname;
        }
        function parsePath(path) {
            let parsedPath = {};
            if (path) {
                let hashIndex = path.indexOf("#");
                if (hashIndex >= 0) {
                    parsedPath.hash = path.substring(hashIndex);
                    path = path.substring(0, hashIndex);
                }
                let searchIndex = path.indexOf("?");
                if (searchIndex >= 0) {
                    parsedPath.search = path.substring(searchIndex);
                    path = path.substring(0, searchIndex);
                }
                if (path) parsedPath.pathname = path;
            }
            return parsedPath;
        }
        function getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {
            let {window: window2 = document.defaultView, v5Compat = false} = options;
            let globalHistory = window2.history;
            let action = "POP";
            let listener = null;
            let index = getIndex();
            if (index == null) {
                index = 0;
                globalHistory.replaceState({
                    ...globalHistory.state,
                    idx: index
                }, "");
            }
            function getIndex() {
                let state = globalHistory.state || {
                    idx: null
                };
                return state.idx;
            }
            function handlePop() {
                action = "POP";
                let nextIndex = getIndex();
                let delta = nextIndex == null ? null : nextIndex - index;
                index = nextIndex;
                if (listener) listener({
                    action,
                    location: history.location,
                    delta
                });
            }
            function push(to, state) {
                action = "PUSH";
                let location = createLocation(history.location, to, state);
                if (validateLocation) validateLocation(location, to);
                index = getIndex() + 1;
                let historyState = getHistoryState(location, index);
                let url = history.createHref(location);
                try {
                    globalHistory.pushState(historyState, "", url);
                } catch (error) {
                    if (error instanceof DOMException && error.name === "DataCloneError") throw error;
                    window2.location.assign(url);
                }
                if (v5Compat && listener) listener({
                    action,
                    location: history.location,
                    delta: 1
                });
            }
            function replace2(to, state) {
                action = "REPLACE";
                let location = createLocation(history.location, to, state);
                if (validateLocation) validateLocation(location, to);
                index = getIndex();
                let historyState = getHistoryState(location, index);
                let url = history.createHref(location);
                globalHistory.replaceState(historyState, "", url);
                if (v5Compat && listener) listener({
                    action,
                    location: history.location,
                    delta: 0
                });
            }
            function createURL(to) {
                return createBrowserURLImpl(to);
            }
            let history = {
                get action() {
                    return action;
                },
                get location() {
                    return getLocation(window2, globalHistory);
                },
                listen(fn) {
                    if (listener) throw new Error("A history only accepts one active listener");
                    window2.addEventListener(PopStateEventType, handlePop);
                    listener = fn;
                    return () => {
                        window2.removeEventListener(PopStateEventType, handlePop);
                        listener = null;
                    };
                },
                createHref(to) {
                    return createHref2(window2, to);
                },
                createURL,
                encodeLocation(to) {
                    let url = createURL(to);
                    return {
                        pathname: url.pathname,
                        search: url.search,
                        hash: url.hash
                    };
                },
                push,
                replace: replace2,
                go(n) {
                    return globalHistory.go(n);
                }
            };
            return history;
        }
        function createBrowserURLImpl(to, isAbsolute = false) {
            let base = "http://localhost";
            if (typeof window !== "undefined") base = window.location.origin !== "null" ? window.location.origin : window.location.href;
            invariant(base, "No window.location.(origin|href) available to create URL");
            let href2 = typeof to === "string" ? to : createPath(to);
            href2 = href2.replace(/ $/, "%20");
            if (!isAbsolute && href2.startsWith("//")) href2 = base + href2;
            return new URL(href2, base);
        }
        new WeakMap;
        new Set([ "lazy", "caseSensitive", "path", "id", "index", "children" ]);
        new Set([ "lazy", "caseSensitive", "path", "id", "index", "unstable_middleware", "children" ]);
        function matchRoutes(routes, locationArg, basename = "/") {
            return matchRoutesImpl(routes, locationArg, basename, false);
        }
        function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
            let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
            let pathname = stripBasename(location.pathname || "/", basename);
            if (pathname == null) return null;
            let branches = flattenRoutes(routes);
            rankRouteBranches(branches);
            let matches = null;
            for (let i = 0; matches == null && i < branches.length; ++i) {
                let decoded = decodePath(pathname);
                matches = matchRouteBranch(branches[i], decoded, allowPartial);
            }
            return matches;
        }
        function convertRouteMatchToUiMatch(match, loaderData) {
            let {route, pathname, params} = match;
            return {
                id: route.id,
                pathname,
                params,
                data: loaderData[route.id],
                handle: route.handle
            };
        }
        function flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = "") {
            let flattenRoute = (route, index, relativePath) => {
                let meta = {
                    relativePath: relativePath === void 0 ? route.path || "" : relativePath,
                    caseSensitive: route.caseSensitive === true,
                    childrenIndex: index,
                    route
                };
                if (meta.relativePath.startsWith("/")) {
                    invariant(meta.relativePath.startsWith(parentPath), `Absolute route path "${meta.relativePath}" nested under path "${parentPath}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`);
                    meta.relativePath = meta.relativePath.slice(parentPath.length);
                }
                let path = joinPaths([ parentPath, meta.relativePath ]);
                let routesMeta = parentsMeta.concat(meta);
                if (route.children && route.children.length > 0) {
                    invariant(route.index !== true, `Index routes must not have child routes. Please remove all child routes from route path "${path}".`);
                    flattenRoutes(route.children, branches, routesMeta, path);
                }
                if (route.path == null && !route.index) return;
                branches.push({
                    path,
                    score: computeScore(path, route.index),
                    routesMeta
                });
            };
            routes.forEach((route, index) => {
                if (route.path === "" || !route.path?.includes("?")) flattenRoute(route, index); else for (let exploded of explodeOptionalSegments(route.path)) flattenRoute(route, index, exploded);
            });
            return branches;
        }
        function explodeOptionalSegments(path) {
            let segments = path.split("/");
            if (segments.length === 0) return [];
            let [first, ...rest] = segments;
            let isOptional = first.endsWith("?");
            let required = first.replace(/\?$/, "");
            if (rest.length === 0) return isOptional ? [ required, "" ] : [ required ];
            let restExploded = explodeOptionalSegments(rest.join("/"));
            let result = [];
            result.push(...restExploded.map(subpath => subpath === "" ? required : [ required, subpath ].join("/")));
            if (isOptional) result.push(...restExploded);
            return result.map(exploded => path.startsWith("/") && exploded === "" ? "/" : exploded);
        }
        function rankRouteBranches(branches) {
            branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));
        }
        var paramRe = /^:[\w-]+$/;
        var dynamicSegmentValue = 3;
        var indexRouteValue = 2;
        var emptySegmentValue = 1;
        var staticSegmentValue = 10;
        var splatPenalty = -2;
        var isSplat = s => s === "*";
        function computeScore(path, index) {
            let segments = path.split("/");
            let initialScore = segments.length;
            if (segments.some(isSplat)) initialScore += splatPenalty;
            if (index) initialScore += indexRouteValue;
            return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
        }
        function compareIndexes(a, b) {
            let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
            return siblings ? a[a.length - 1] - b[b.length - 1] : 0;
        }
        function matchRouteBranch(branch, pathname, allowPartial = false) {
            let {routesMeta} = branch;
            let matchedParams = {};
            let matchedPathname = "/";
            let matches = [];
            for (let i = 0; i < routesMeta.length; ++i) {
                let meta = routesMeta[i];
                let end = i === routesMeta.length - 1;
                let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
                let match = matchPath({
                    path: meta.relativePath,
                    caseSensitive: meta.caseSensitive,
                    end
                }, remainingPathname);
                let route = meta.route;
                if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) match = matchPath({
                    path: meta.relativePath,
                    caseSensitive: meta.caseSensitive,
                    end: false
                }, remainingPathname);
                if (!match) return null;
                Object.assign(matchedParams, match.params);
                matches.push({
                    params: matchedParams,
                    pathname: joinPaths([ matchedPathname, match.pathname ]),
                    pathnameBase: normalizePathname(joinPaths([ matchedPathname, match.pathnameBase ])),
                    route
                });
                if (match.pathnameBase !== "/") matchedPathname = joinPaths([ matchedPathname, match.pathnameBase ]);
            }
            return matches;
        }
        function matchPath(pattern, pathname) {
            if (typeof pattern === "string") pattern = {
                path: pattern,
                caseSensitive: false,
                end: true
            };
            let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
            let match = pathname.match(matcher);
            if (!match) return null;
            let matchedPathname = match[0];
            let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
            let captureGroups = match.slice(1);
            let params = compiledParams.reduce((memo2, {paramName, isOptional}, index) => {
                if (paramName === "*") {
                    let splatValue = captureGroups[index] || "";
                    pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
                }
                const value = captureGroups[index];
                if (isOptional && !value) memo2[paramName] = void 0; else memo2[paramName] = (value || "").replace(/%2F/g, "/");
                return memo2;
            }, {});
            return {
                params,
                pathname: matchedPathname,
                pathnameBase,
                pattern
            };
        }
        function compilePath(path, caseSensitive = false, end = true) {
            warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), `Route path "${path}" will be treated as if it were "${path.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path.replace(/\*$/, "/*")}".`);
            let params = [];
            let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (_, paramName, isOptional) => {
                params.push({
                    paramName,
                    isOptional: isOptional != null
                });
                return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
            });
            if (path.endsWith("*")) {
                params.push({
                    paramName: "*"
                });
                regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
            } else if (end) regexpSource += "\\/*$"; else if (path !== "" && path !== "/") regexpSource += "(?:(?=\\/|$))";
            let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
            return [ matcher, params ];
        }
        function decodePath(value) {
            try {
                return value.split("/").map(v => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
            } catch (error) {
                warning(false, `The URL path "${value}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`);
                return value;
            }
        }
        function stripBasename(pathname, basename) {
            if (basename === "/") return pathname;
            if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) return null;
            let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
            let nextChar = pathname.charAt(startIndex);
            if (nextChar && nextChar !== "/") return null;
            return pathname.slice(startIndex) || "/";
        }
        function resolvePath(to, fromPathname = "/") {
            let {pathname: toPathname, search = "", hash = ""} = typeof to === "string" ? parsePath(to) : to;
            let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
            return {
                pathname,
                search: normalizeSearch(search),
                hash: normalizeHash(hash)
            };
        }
        function resolvePathname(relativePath, fromPathname) {
            let segments = fromPathname.replace(/\/+$/, "").split("/");
            let relativeSegments = relativePath.split("/");
            relativeSegments.forEach(segment => {
                if (segment === "..") {
                    if (segments.length > 1) segments.pop();
                } else if (segment !== ".") segments.push(segment);
            });
            return segments.length > 1 ? segments.join("/") : "/";
        }
        function getInvalidPathError(char, field, dest, path) {
            return `Cannot include a '${char}' character in a manually specified \`to.${field}\` field [${JSON.stringify(path)}].  Please separate it out to the \`to.${dest}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
        }
        function getPathContributingMatches(matches) {
            return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
        }
        function getResolveToMatches(matches) {
            let pathMatches = getPathContributingMatches(matches);
            return pathMatches.map((match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase);
        }
        function resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {
            let to;
            if (typeof toArg === "string") to = parsePath(toArg); else {
                to = {
                    ...toArg
                };
                invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
                invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
                invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
            }
            let isEmptyPath = toArg === "" || to.pathname === "";
            let toPathname = isEmptyPath ? "/" : to.pathname;
            let from;
            if (toPathname == null) from = locationPathname; else {
                let routePathnameIndex = routePathnames.length - 1;
                if (!isPathRelative && toPathname.startsWith("..")) {
                    let toSegments = toPathname.split("/");
                    while (toSegments[0] === "..") {
                        toSegments.shift();
                        routePathnameIndex -= 1;
                    }
                    to.pathname = toSegments.join("/");
                }
                from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
            }
            let path = resolvePath(to, from);
            let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
            let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
            if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) path.pathname += "/";
            return path;
        }
        var joinPaths = paths => paths.join("/").replace(/\/\/+/g, "/");
        var normalizePathname = pathname => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
        var normalizeSearch = search => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
        var normalizeHash = hash => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
        function isRouteErrorResponse(error) {
            return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
        }
        var validMutationMethodsArr = [ "POST", "PUT", "PATCH", "DELETE" ];
        new Set(validMutationMethodsArr);
        var validRequestMethodsArr = [ "GET", ...validMutationMethodsArr ];
        new Set(validRequestMethodsArr);
        new Set([ 301, 302, 303, 307, 308 ]);
        new Set([ 307, 308 ]);
        Symbol("ResetLoaderData");
        new WeakMap;
        new WeakMap;
        var DataRouterContext = react.createContext(null);
        DataRouterContext.displayName = "DataRouter";
        var DataRouterStateContext = react.createContext(null);
        DataRouterStateContext.displayName = "DataRouterState";
        var ViewTransitionContext = react.createContext({
            isTransitioning: false
        });
        ViewTransitionContext.displayName = "ViewTransition";
        var FetchersContext = react.createContext(new Map);
        FetchersContext.displayName = "Fetchers";
        var AwaitContext = react.createContext(null);
        AwaitContext.displayName = "Await";
        var NavigationContext = react.createContext(null);
        NavigationContext.displayName = "Navigation";
        var LocationContext = react.createContext(null);
        LocationContext.displayName = "Location";
        var RouteContext = react.createContext({
            outlet: null,
            matches: [],
            isDataRoute: false
        });
        RouteContext.displayName = "Route";
        var RouteErrorContext = react.createContext(null);
        RouteErrorContext.displayName = "RouteError";
        var ENABLE_DEV_WARNINGS = true;
        function useHref(to, {relative} = {}) {
            invariant(useInRouterContext(), `useHref() may be used only in the context of a <Router> component.`);
            let {basename, navigator} = react.useContext(NavigationContext);
            let {hash, pathname, search} = useResolvedPath(to, {
                relative
            });
            let joinedPathname = pathname;
            if (basename !== "/") joinedPathname = pathname === "/" ? basename : joinPaths([ basename, pathname ]);
            return navigator.createHref({
                pathname: joinedPathname,
                search,
                hash
            });
        }
        function useInRouterContext() {
            return react.useContext(LocationContext) != null;
        }
        function useLocation() {
            invariant(useInRouterContext(), `useLocation() may be used only in the context of a <Router> component.`);
            return react.useContext(LocationContext).location;
        }
        var navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;
        function useIsomorphicLayoutEffect(cb) {
            let isStatic = react.useContext(NavigationContext).static;
            if (!isStatic) react.useLayoutEffect(cb);
        }
        function useNavigate() {
            let {isDataRoute} = react.useContext(RouteContext);
            return isDataRoute ? useNavigateStable() : useNavigateUnstable();
        }
        function useNavigateUnstable() {
            invariant(useInRouterContext(), `useNavigate() may be used only in the context of a <Router> component.`);
            let dataRouterContext = react.useContext(DataRouterContext);
            let {basename, navigator} = react.useContext(NavigationContext);
            let {matches} = react.useContext(RouteContext);
            let {pathname: locationPathname} = useLocation();
            let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
            let activeRef = react.useRef(false);
            useIsomorphicLayoutEffect(() => {
                activeRef.current = true;
            });
            let navigate = react.useCallback((to, options = {}) => {
                warning(activeRef.current, navigateEffectWarning);
                if (!activeRef.current) return;
                if (typeof to === "number") {
                    navigator.go(to);
                    return;
                }
                let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
                if (dataRouterContext == null && basename !== "/") path.pathname = path.pathname === "/" ? basename : joinPaths([ basename, path.pathname ]);
                (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);
            }, [ basename, navigator, routePathnamesJson, locationPathname, dataRouterContext ]);
            return navigate;
        }
        react.createContext(null);
        function useResolvedPath(to, {relative} = {}) {
            let {matches} = react.useContext(RouteContext);
            let {pathname: locationPathname} = useLocation();
            let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
            return react.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [ to, routePathnamesJson, locationPathname, relative ]);
        }
        function useRoutes(routes, locationArg) {
            return useRoutesImpl(routes, locationArg);
        }
        function useRoutesImpl(routes, locationArg, dataRouterState, future) {
            invariant(useInRouterContext(), `useRoutes() may be used only in the context of a <Router> component.`);
            let {navigator} = react.useContext(NavigationContext);
            let {matches: parentMatches} = react.useContext(RouteContext);
            let routeMatch = parentMatches[parentMatches.length - 1];
            let parentParams = routeMatch ? routeMatch.params : {};
            let parentPathname = routeMatch ? routeMatch.pathname : "/";
            let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
            let parentRoute = routeMatch && routeMatch.route;
            if (ENABLE_DEV_WARNINGS) {
                let parentPath = parentRoute && parentRoute.path || "";
                warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*") || parentPath.endsWith("*?"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${parentPathname}" (under <Route path="${parentPath}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.\n\nPlease change the parent <Route path="${parentPath}"> to <Route path="${parentPath === "/" ? "*" : `${parentPath}/*`}">.`);
            }
            let locationFromContext = useLocation();
            let location;
            if (locationArg) {
                let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
                invariant(parentPathnameBase === "/" || parsedLocationArg.pathname?.startsWith(parentPathnameBase), `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${parentPathnameBase}" but pathname "${parsedLocationArg.pathname}" was given in the \`location\` prop.`);
                location = parsedLocationArg;
            } else location = locationFromContext;
            let pathname = location.pathname || "/";
            let remainingPathname = pathname;
            if (parentPathnameBase !== "/") {
                let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
                let segments = pathname.replace(/^\//, "").split("/");
                remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
            }
            let matches = matchRoutes(routes, {
                pathname: remainingPathname
            });
            if (ENABLE_DEV_WARNINGS) {
                warning(parentRoute || matches != null, `No routes matched location "${location.pathname}${location.search}${location.hash}" `);
                warning(matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0, `Matched leaf route at location "${location.pathname}${location.search}${location.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);
            }
            let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign({}, match, {
                params: Object.assign({}, parentParams, match.params),
                pathname: joinPaths([ parentPathnameBase, navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname ]),
                pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([ parentPathnameBase, navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase ])
            })), parentMatches, dataRouterState, future);
            if (locationArg && renderedMatches) return react.createElement(LocationContext.Provider, {
                value: {
                    location: {
                        pathname: "/",
                        search: "",
                        hash: "",
                        state: null,
                        key: "default",
                        ...location
                    },
                    navigationType: "POP"
                }
            }, renderedMatches);
            return renderedMatches;
        }
        function DefaultErrorComponent() {
            let error = useRouteError();
            let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);
            let stack = error instanceof Error ? error.stack : null;
            let lightgrey = "rgba(200,200,200, 0.5)";
            let preStyles = {
                padding: "0.5rem",
                backgroundColor: lightgrey
            };
            let codeStyles = {
                padding: "2px 4px",
                backgroundColor: lightgrey
            };
            let devInfo = null;
            if (ENABLE_DEV_WARNINGS) {
                console.error("Error handled by React Router default ErrorBoundary:", error);
                devInfo = react.createElement(react.Fragment, null, react.createElement("p", null, " Hey developer "), react.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", react.createElement("code", {
                    style: codeStyles
                }, "ErrorBoundary"), " or", " ", react.createElement("code", {
                    style: codeStyles
                }, "errorElement"), " prop on your route."));
            }
            return react.createElement(react.Fragment, null, react.createElement("h2", null, "Unexpected Application Error!"), react.createElement("h3", {
                style: {
                    fontStyle: "italic"
                }
            }, message), stack ? react.createElement("pre", {
                style: preStyles
            }, stack) : null, devInfo);
        }
        var defaultErrorElement = react.createElement(DefaultErrorComponent, null);
        var RenderErrorBoundary = class extends react.Component {
            constructor(props) {
                super(props);
                this.state = {
                    location: props.location,
                    revalidation: props.revalidation,
                    error: props.error
                };
            }
            static getDerivedStateFromError(error) {
                return {
                    error
                };
            }
            static getDerivedStateFromProps(props, state) {
                if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") return {
                    error: props.error,
                    location: props.location,
                    revalidation: props.revalidation
                };
                return {
                    error: props.error !== void 0 ? props.error : state.error,
                    location: state.location,
                    revalidation: props.revalidation || state.revalidation
                };
            }
            componentDidCatch(error, errorInfo) {
                console.error("React Router caught the following error during render", error, errorInfo);
            }
            render() {
                return this.state.error !== void 0 ? react.createElement(RouteContext.Provider, {
                    value: this.props.routeContext
                }, react.createElement(RouteErrorContext.Provider, {
                    value: this.state.error,
                    children: this.props.component
                })) : this.props.children;
            }
        };
        function RenderedRoute({routeContext, match, children}) {
            let dataRouterContext = react.useContext(DataRouterContext);
            if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
            return react.createElement(RouteContext.Provider, {
                value: routeContext
            }, children);
        }
        function _renderMatches(matches, parentMatches = [], dataRouterState = null, future = null) {
            if (matches == null) {
                if (!dataRouterState) return null;
                if (dataRouterState.errors) matches = dataRouterState.matches; else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) matches = dataRouterState.matches; else return null;
            }
            let renderedMatches = matches;
            let errors = dataRouterState?.errors;
            if (errors != null) {
                let errorIndex = renderedMatches.findIndex(m => m.route.id && errors?.[m.route.id] !== void 0);
                invariant(errorIndex >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(errors).join(",")}`);
                renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
            }
            let renderFallback = false;
            let fallbackIndex = -1;
            if (dataRouterState) for (let i = 0; i < renderedMatches.length; i++) {
                let match = renderedMatches[i];
                if (match.route.HydrateFallback || match.route.hydrateFallbackElement) fallbackIndex = i;
                if (match.route.id) {
                    let {loaderData, errors: errors2} = dataRouterState;
                    let needsToRunLoader = match.route.loader && !loaderData.hasOwnProperty(match.route.id) && (!errors2 || errors2[match.route.id] === void 0);
                    if (match.route.lazy || needsToRunLoader) {
                        renderFallback = true;
                        if (fallbackIndex >= 0) renderedMatches = renderedMatches.slice(0, fallbackIndex + 1); else renderedMatches = [ renderedMatches[0] ];
                        break;
                    }
                }
            }
            return renderedMatches.reduceRight((outlet, match, index) => {
                let error;
                let shouldRenderHydrateFallback = false;
                let errorElement = null;
                let hydrateFallbackElement = null;
                if (dataRouterState) {
                    error = errors && match.route.id ? errors[match.route.id] : void 0;
                    errorElement = match.route.errorElement || defaultErrorElement;
                    if (renderFallback) if (fallbackIndex < 0 && index === 0) {
                        warningOnce("route-fallback", false, "No `HydrateFallback` element provided to render during initial hydration");
                        shouldRenderHydrateFallback = true;
                        hydrateFallbackElement = null;
                    } else if (fallbackIndex === index) {
                        shouldRenderHydrateFallback = true;
                        hydrateFallbackElement = match.route.hydrateFallbackElement || null;
                    }
                }
                let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));
                let getChildren = () => {
                    let children;
                    if (error) children = errorElement; else if (shouldRenderHydrateFallback) children = hydrateFallbackElement; else if (match.route.Component) children = react.createElement(match.route.Component, null); else if (match.route.element) children = match.route.element; else children = outlet;
                    return react.createElement(RenderedRoute, {
                        match,
                        routeContext: {
                            outlet,
                            matches: matches2,
                            isDataRoute: dataRouterState != null
                        },
                        children
                    });
                };
                return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? react.createElement(RenderErrorBoundary, {
                    location: dataRouterState.location,
                    revalidation: dataRouterState.revalidation,
                    component: errorElement,
                    error,
                    children: getChildren(),
                    routeContext: {
                        outlet: null,
                        matches: matches2,
                        isDataRoute: true
                    }
                }) : getChildren();
            }, null);
        }
        function getDataRouterConsoleError(hookName) {
            return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
        }
        function useDataRouterContext(hookName) {
            let ctx = react.useContext(DataRouterContext);
            invariant(ctx, getDataRouterConsoleError(hookName));
            return ctx;
        }
        function useDataRouterState(hookName) {
            let state = react.useContext(DataRouterStateContext);
            invariant(state, getDataRouterConsoleError(hookName));
            return state;
        }
        function useRouteContext(hookName) {
            let route = react.useContext(RouteContext);
            invariant(route, getDataRouterConsoleError(hookName));
            return route;
        }
        function useCurrentRouteId(hookName) {
            let route = useRouteContext(hookName);
            let thisRoute = route.matches[route.matches.length - 1];
            invariant(thisRoute.route.id, `${hookName} can only be used on routes that contain a unique "id"`);
            return thisRoute.route.id;
        }
        function useRouteId() {
            return useCurrentRouteId("useRouteId");
        }
        function useNavigation() {
            let state = useDataRouterState("useNavigation");
            return state.navigation;
        }
        function useMatches() {
            let {matches, loaderData} = useDataRouterState("useMatches");
            return react.useMemo(() => matches.map(m => convertRouteMatchToUiMatch(m, loaderData)), [ matches, loaderData ]);
        }
        function useRouteError() {
            let error = react.useContext(RouteErrorContext);
            let state = useDataRouterState("useRouteError");
            let routeId = useCurrentRouteId("useRouteError");
            if (error !== void 0) return error;
            return state.errors?.[routeId];
        }
        function useNavigateStable() {
            let {router} = useDataRouterContext("useNavigate");
            let id = useCurrentRouteId("useNavigate");
            let activeRef = react.useRef(false);
            useIsomorphicLayoutEffect(() => {
                activeRef.current = true;
            });
            let navigate = react.useCallback(async (to, options = {}) => {
                warning(activeRef.current, navigateEffectWarning);
                if (!activeRef.current) return;
                if (typeof to === "number") router.navigate(to); else await router.navigate(to, {
                    fromRouteId: id,
                    ...options
                });
            }, [ router, id ]);
            return navigate;
        }
        var alreadyWarned = {};
        function warningOnce(key, cond, message) {
            if (!cond && !alreadyWarned[key]) {
                alreadyWarned[key] = true;
                warning(false, message);
            }
        }
        react.memo(DataRoutes);
        function DataRoutes({routes, future, state}) {
            return useRoutesImpl(routes, void 0, state, future);
        }
        function Route(_props) {
            invariant(false, `A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.`);
        }
        function Router({basename: basenameProp = "/", children = null, location: locationProp, navigationType = "POP", navigator, static: staticProp = false}) {
            invariant(!useInRouterContext(), `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`);
            let basename = basenameProp.replace(/^\/*/, "/");
            let navigationContext = react.useMemo(() => ({
                basename,
                navigator,
                static: staticProp,
                future: {}
            }), [ basename, navigator, staticProp ]);
            if (typeof locationProp === "string") locationProp = parsePath(locationProp);
            let {pathname = "/", search = "", hash = "", state = null, key = "default"} = locationProp;
            let locationContext = react.useMemo(() => {
                let trailingPathname = stripBasename(pathname, basename);
                if (trailingPathname == null) return null;
                return {
                    location: {
                        pathname: trailingPathname,
                        search,
                        hash,
                        state,
                        key
                    },
                    navigationType
                };
            }, [ basename, pathname, search, hash, state, key, navigationType ]);
            warning(locationContext != null, `<Router basename="${basename}"> is not able to match the URL "${pathname}${search}${hash}" because it does not start with the basename, so the <Router> won't render anything.`);
            if (locationContext == null) return null;
            return react.createElement(NavigationContext.Provider, {
                value: navigationContext
            }, react.createElement(LocationContext.Provider, {
                children,
                value: locationContext
            }));
        }
        function Routes({children, location}) {
            return useRoutes(createRoutesFromChildren(children), location);
        }
        react.Component;
        function createRoutesFromChildren(children, parentPath = []) {
            let routes = [];
            react.Children.forEach(children, (element, index) => {
                if (!react.isValidElement(element)) return;
                let treePath = [ ...parentPath, index ];
                if (element.type === react.Fragment) {
                    routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
                    return;
                }
                invariant(element.type === Route, `[${typeof element.type === "string" ? element.type : element.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`);
                invariant(!element.props.index || !element.props.children, "An index route cannot have child routes.");
                let route = {
                    id: element.props.id || treePath.join("-"),
                    caseSensitive: element.props.caseSensitive,
                    element: element.props.element,
                    Component: element.props.Component,
                    index: element.props.index,
                    path: element.props.path,
                    loader: element.props.loader,
                    action: element.props.action,
                    hydrateFallbackElement: element.props.hydrateFallbackElement,
                    HydrateFallback: element.props.HydrateFallback,
                    errorElement: element.props.errorElement,
                    ErrorBoundary: element.props.ErrorBoundary,
                    hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,
                    shouldRevalidate: element.props.shouldRevalidate,
                    handle: element.props.handle,
                    lazy: element.props.lazy
                };
                if (element.props.children) route.children = createRoutesFromChildren(element.props.children, treePath);
                routes.push(route);
            });
            return routes;
        }
        var defaultMethod = "get";
        var defaultEncType = "application/x-www-form-urlencoded";
        function isHtmlElement(object) {
            return object != null && typeof object.tagName === "string";
        }
        function isButtonElement(object) {
            return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
        }
        function isFormElement(object) {
            return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
        }
        function isInputElement(object) {
            return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
        }
        function isModifiedEvent(event) {
            return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
        }
        function shouldProcessLinkClick(event, target) {
            return event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event);
        }
        var _formDataSupportsSubmitter = null;
        function isFormDataSubmitterSupported() {
            if (_formDataSupportsSubmitter === null) try {
                new FormData(document.createElement("form"), 0);
                _formDataSupportsSubmitter = false;
            } catch (e) {
                _formDataSupportsSubmitter = true;
            }
            return _formDataSupportsSubmitter;
        }
        var supportedFormEncTypes = new Set([ "application/x-www-form-urlencoded", "multipart/form-data", "text/plain" ]);
        function getFormEncType(encType) {
            if (encType != null && !supportedFormEncTypes.has(encType)) {
                warning(false, `"${encType}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`);
                return null;
            }
            return encType;
        }
        function getFormSubmissionInfo(target, basename) {
            let method;
            let action;
            let encType;
            let formData;
            let body;
            if (isFormElement(target)) {
                let attr = target.getAttribute("action");
                action = attr ? stripBasename(attr, basename) : null;
                method = target.getAttribute("method") || defaultMethod;
                encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
                formData = new FormData(target);
            } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
                let form = target.form;
                if (form == null) throw new Error(`Cannot submit a <button> or <input type="submit"> without a <form>`);
                let attr = target.getAttribute("formaction") || form.getAttribute("action");
                action = attr ? stripBasename(attr, basename) : null;
                method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
                encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
                formData = new FormData(form, target);
                if (!isFormDataSubmitterSupported()) {
                    let {name, type, value} = target;
                    if (type === "image") {
                        let prefix = name ? `${name}.` : "";
                        formData.append(`${prefix}x`, "0");
                        formData.append(`${prefix}y`, "0");
                    } else if (name) formData.append(name, value);
                }
            } else if (isHtmlElement(target)) throw new Error(`Cannot submit element that is not <form>, <button>, or <input type="submit|image">`); else {
                method = defaultMethod;
                action = null;
                encType = defaultEncType;
                body = target;
            }
            if (formData && encType === "text/plain") {
                body = formData;
                formData = void 0;
            }
            return {
                action,
                method: method.toLowerCase(),
                encType,
                formData,
                body
            };
        }
        function invariant2(value, message) {
            if (value === false || value === null || typeof value === "undefined") throw new Error(message);
        }
        async function loadRouteModule(route, routeModulesCache) {
            if (route.id in routeModulesCache) return routeModulesCache[route.id];
            try {
                let routeModule = await import(route.module);
                routeModulesCache[route.id] = routeModule;
                return routeModule;
            } catch (error) {
                console.error(`Error loading route module \`${route.module}\`, reloading page...`);
                console.error(error);
                if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && void 0) ;
                window.location.reload();
                return new Promise(() => {});
            }
        }
        function isPageLinkDescriptor(object) {
            return object != null && typeof object.page === "string";
        }
        function isHtmlLinkDescriptor(object) {
            if (object == null) return false;
            if (object.href == null) return object.rel === "preload" && typeof object.imageSrcSet === "string" && typeof object.imageSizes === "string";
            return typeof object.rel === "string" && typeof object.href === "string";
        }
        async function getKeyedPrefetchLinks(matches, manifest, routeModules) {
            let links = await Promise.all(matches.map(async match => {
                let route = manifest.routes[match.route.id];
                if (route) {
                    let mod = await loadRouteModule(route, routeModules);
                    return mod.links ? mod.links() : [];
                }
                return [];
            }));
            return dedupeLinkDescriptors(links.flat(1).filter(isHtmlLinkDescriptor).filter(link => link.rel === "stylesheet" || link.rel === "preload").map(link => link.rel === "stylesheet" ? {
                ...link,
                rel: "prefetch",
                as: "style"
            } : {
                ...link,
                rel: "prefetch"
            }));
        }
        function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
            let isNew = (match, index) => {
                if (!currentMatches[index]) return true;
                return match.route.id !== currentMatches[index].route.id;
            };
            let matchPathChanged = (match, index) => currentMatches[index].pathname !== match.pathname || currentMatches[index].route.path?.endsWith("*") && currentMatches[index].params["*"] !== match.params["*"];
            if (mode === "assets") return nextMatches.filter((match, index) => isNew(match, index) || matchPathChanged(match, index));
            if (mode === "data") return nextMatches.filter((match, index) => {
                let manifestRoute = manifest.routes[match.route.id];
                if (!manifestRoute || !manifestRoute.hasLoader) return false;
                if (isNew(match, index) || matchPathChanged(match, index)) return true;
                if (match.route.shouldRevalidate) {
                    let routeChoice = match.route.shouldRevalidate({
                        currentUrl: new URL(location.pathname + location.search + location.hash, window.origin),
                        currentParams: currentMatches[0]?.params || {},
                        nextUrl: new URL(page, window.origin),
                        nextParams: match.params,
                        defaultShouldRevalidate: true
                    });
                    if (typeof routeChoice === "boolean") return routeChoice;
                }
                return true;
            });
            return [];
        }
        function getModuleLinkHrefs(matches, manifest, {includeHydrateFallback} = {}) {
            return dedupeHrefs(matches.map(match => {
                let route = manifest.routes[match.route.id];
                if (!route) return [];
                let hrefs = [ route.module ];
                if (route.clientActionModule) hrefs = hrefs.concat(route.clientActionModule);
                if (route.clientLoaderModule) hrefs = hrefs.concat(route.clientLoaderModule);
                if (includeHydrateFallback && route.hydrateFallbackModule) hrefs = hrefs.concat(route.hydrateFallbackModule);
                if (route.imports) hrefs = hrefs.concat(route.imports);
                return hrefs;
            }).flat(1));
        }
        function dedupeHrefs(hrefs) {
            return [ ...new Set(hrefs) ];
        }
        function sortKeys(obj) {
            let sorted = {};
            let keys = Object.keys(obj).sort();
            for (let key of keys) sorted[key] = obj[key];
            return sorted;
        }
        function dedupeLinkDescriptors(descriptors, preloads) {
            let set = new Set;
            let preloadsSet = new Set(preloads);
            return descriptors.reduce((deduped, descriptor) => {
                let alreadyModulePreload = preloads && !isPageLinkDescriptor(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href);
                if (alreadyModulePreload) return deduped;
                let key = JSON.stringify(sortKeys(descriptor));
                if (!set.has(key)) {
                    set.add(key);
                    deduped.push({
                        key,
                        link: descriptor
                    });
                }
                return deduped;
            }, []);
        }
        function createHtml(html) {
            return {
                __html: html
            };
        }
        Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
        typeof window !== "undefined" ? window : typeof globalThis !== "undefined" && globalThis;
        Symbol("SingleFetchRedirect");
        null && Error;
        var NO_BODY_STATUS_CODES = new Set([ 100, 101, 204, 205 ]);
        function singleFetchUrl(reqUrl, basename) {
            let url = typeof reqUrl === "string" ? new URL(reqUrl, typeof window === "undefined" ? "server://singlefetch/" : window.location.origin) : reqUrl;
            if (url.pathname === "/") url.pathname = "_root.data"; else if (basename && stripBasename(url.pathname, basename) === "/") url.pathname = `${basename.replace(/\/$/, "")}/_root.data`; else url.pathname = `${url.pathname.replace(/\/$/, "")}.data`;
            return url;
        }
        react.Component;
        function RemixRootDefaultErrorBoundary({error, isOutsideRemixApp}) {
            console.error(error);
            let heyDeveloper = react.createElement("script", {
                dangerouslySetInnerHTML: {
                    __html: `\n        console.log(\n          " Hey developer . You can provide a way better UX than this when your app throws errors. Check out https://reactrouter.com/how-to/error-boundary for more information."\n        );\n      `
                }
            });
            if (isRouteErrorResponse(error)) return react.createElement(BoundaryShell, {
                title: "Unhandled Thrown Response!"
            }, react.createElement("h1", {
                style: {
                    fontSize: "24px"
                }
            }, error.status, " ", error.statusText), ENABLE_DEV_WARNINGS ? heyDeveloper : null);
            let errorInstance;
            if (error instanceof Error) 0; else {
                let errorString = error == null ? "Unknown Error" : typeof error === "object" && "toString" in error ? error.toString() : JSON.stringify(error);
                new Error(errorString);
            }
            return react.createElement(BoundaryShell, {
                title: "Application Error!",
                isOutsideRemixApp
            }, react.createElement("h1", {
                style: {
                    fontSize: "24px"
                }
            }, "Application Error"), react.createElement("pre", {
                style: {
                    padding: "2rem",
                    background: "hsla(10, 50%, 50%, 0.1)",
                    color: "red",
                    overflow: "auto"
                }
            }, errorInstance.stack), heyDeveloper);
        }
        function BoundaryShell({title, renderScripts, isOutsideRemixApp, children}) {
            let {routeModules} = useFrameworkContext();
            if (routeModules.root?.Layout && !isOutsideRemixApp) return children;
            return react.createElement("html", {
                lang: "en"
            }, react.createElement("head", null, react.createElement("meta", {
                charSet: "utf-8"
            }), react.createElement("meta", {
                name: "viewport",
                content: "width=device-width,initial-scale=1,viewport-fit=cover"
            }), react.createElement("title", null, title)), react.createElement("body", null, react.createElement("main", {
                style: {
                    fontFamily: "system-ui, sans-serif",
                    padding: "2rem"
                }
            }, children, renderScripts ? react.createElement(Scripts, null) : null)));
        }
        new Set;
        new Set;
        function isFogOfWarEnabled(routeDiscovery, ssr) {
            return routeDiscovery.mode === "lazy" && ssr === true;
        }
        function getPartialManifest({sri, ...manifest}, router) {
            let routeIds = new Set(router.state.matches.map(m => m.route.id));
            let segments = router.state.location.pathname.split("/").filter(Boolean);
            let paths = [ "/" ];
            segments.pop();
            while (segments.length > 0) {
                paths.push(`/${segments.join("/")}`);
                segments.pop();
            }
            paths.forEach(path => {
                let matches = matchRoutes(router.routes, path, router.basename);
                if (matches) matches.forEach(m => routeIds.add(m.route.id));
            });
            let initialRoutes = [ ...routeIds ].reduce((acc, id) => Object.assign(acc, {
                [id]: manifest.routes[id]
            }), {});
            return {
                ...manifest,
                routes: initialRoutes,
                sri: sri ? true : void 0
            };
        }
        function useDataRouterContext2() {
            let context = react.useContext(DataRouterContext);
            invariant2(context, "You must render this element inside a <DataRouterContext.Provider> element");
            return context;
        }
        function useDataRouterStateContext() {
            let context = react.useContext(DataRouterStateContext);
            invariant2(context, "You must render this element inside a <DataRouterStateContext.Provider> element");
            return context;
        }
        var FrameworkContext = react.createContext(void 0);
        FrameworkContext.displayName = "FrameworkContext";
        function useFrameworkContext() {
            let context = react.useContext(FrameworkContext);
            invariant2(context, "You must render this element inside a <HydratedRouter> element");
            return context;
        }
        function usePrefetchBehavior(prefetch, theirElementProps) {
            let frameworkContext = react.useContext(FrameworkContext);
            let [maybePrefetch, setMaybePrefetch] = react.useState(false);
            let [shouldPrefetch, setShouldPrefetch] = react.useState(false);
            let {onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart} = theirElementProps;
            let ref = react.useRef(null);
            react.useEffect(() => {
                if (prefetch === "render") setShouldPrefetch(true);
                if (prefetch === "viewport") {
                    let callback = entries => {
                        entries.forEach(entry => {
                            setShouldPrefetch(entry.isIntersecting);
                        });
                    };
                    let observer = new IntersectionObserver(callback, {
                        threshold: .5
                    });
                    if (ref.current) observer.observe(ref.current);
                    return () => {
                        observer.disconnect();
                    };
                }
            }, [ prefetch ]);
            react.useEffect(() => {
                if (maybePrefetch) {
                    let id = setTimeout(() => {
                        setShouldPrefetch(true);
                    }, 100);
                    return () => {
                        clearTimeout(id);
                    };
                }
            }, [ maybePrefetch ]);
            let setIntent = () => {
                setMaybePrefetch(true);
            };
            let cancelIntent = () => {
                setMaybePrefetch(false);
                setShouldPrefetch(false);
            };
            if (!frameworkContext) return [ false, ref, {} ];
            if (prefetch !== "intent") return [ shouldPrefetch, ref, {} ];
            return [ shouldPrefetch, ref, {
                onFocus: composeEventHandlers(onFocus, setIntent),
                onBlur: composeEventHandlers(onBlur, cancelIntent),
                onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
                onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
                onTouchStart: composeEventHandlers(onTouchStart, setIntent)
            } ];
        }
        function composeEventHandlers(theirHandler, ourHandler) {
            return event => {
                theirHandler && theirHandler(event);
                if (!event.defaultPrevented) ourHandler(event);
            };
        }
        function getActiveMatches(matches, errors, isSpaMode) {
            if (isSpaMode && !isHydrated) return [ matches[0] ];
            if (errors) {
                let errorIdx = matches.findIndex(m => errors[m.route.id] !== void 0);
                return matches.slice(0, errorIdx + 1);
            }
            return matches;
        }
        function PrefetchPageLinks({page, ...dataLinkProps}) {
            let {router} = useDataRouterContext2();
            let matches = react.useMemo(() => matchRoutes(router.routes, page, router.basename), [ router.routes, page, router.basename ]);
            if (!matches) return null;
            return react.createElement(PrefetchPageLinksImpl, {
                page,
                matches,
                ...dataLinkProps
            });
        }
        function useKeyedPrefetchLinks(matches) {
            let {manifest, routeModules} = useFrameworkContext();
            let [keyedPrefetchLinks, setKeyedPrefetchLinks] = react.useState([]);
            react.useEffect(() => {
                let interrupted = false;
                void getKeyedPrefetchLinks(matches, manifest, routeModules).then(links => {
                    if (!interrupted) setKeyedPrefetchLinks(links);
                });
                return () => {
                    interrupted = true;
                };
            }, [ matches, manifest, routeModules ]);
            return keyedPrefetchLinks;
        }
        function PrefetchPageLinksImpl({page, matches: nextMatches, ...linkProps}) {
            let location = useLocation();
            let {manifest, routeModules} = useFrameworkContext();
            let {basename} = useDataRouterContext2();
            let {loaderData, matches} = useDataRouterStateContext();
            let newMatchesForData = react.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, manifest, location, "data"), [ page, nextMatches, matches, manifest, location ]);
            let newMatchesForAssets = react.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, manifest, location, "assets"), [ page, nextMatches, matches, manifest, location ]);
            let dataHrefs = react.useMemo(() => {
                if (page === location.pathname + location.search + location.hash) return [];
                let routesParams = new Set;
                let foundOptOutRoute = false;
                nextMatches.forEach(m => {
                    let manifestRoute = manifest.routes[m.route.id];
                    if (!manifestRoute || !manifestRoute.hasLoader) return;
                    if (!newMatchesForData.some(m2 => m2.route.id === m.route.id) && m.route.id in loaderData && routeModules[m.route.id]?.shouldRevalidate) foundOptOutRoute = true; else if (manifestRoute.hasClientLoader) foundOptOutRoute = true; else routesParams.add(m.route.id);
                });
                if (routesParams.size === 0) return [];
                let url = singleFetchUrl(page, basename);
                if (foundOptOutRoute && routesParams.size > 0) url.searchParams.set("_routes", nextMatches.filter(m => routesParams.has(m.route.id)).map(m => m.route.id).join(","));
                return [ url.pathname + url.search ];
            }, [ basename, loaderData, location, manifest, newMatchesForData, nextMatches, page, routeModules ]);
            let moduleHrefs = react.useMemo(() => getModuleLinkHrefs(newMatchesForAssets, manifest), [ newMatchesForAssets, manifest ]);
            let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);
            return react.createElement(react.Fragment, null, dataHrefs.map(href2 => react.createElement("link", {
                key: href2,
                rel: "prefetch",
                as: "fetch",
                href: href2,
                ...linkProps
            })), moduleHrefs.map(href2 => react.createElement("link", {
                key: href2,
                rel: "modulepreload",
                href: href2,
                ...linkProps
            })), keyedPrefetchLinks.map(({key, link}) => react.createElement("link", {
                key,
                ...link
            })));
        }
        var isHydrated = false;
        function Scripts(props) {
            let {manifest, serverHandoffString, isSpaMode, renderMeta, routeDiscovery, ssr} = useFrameworkContext();
            let {router, static: isStatic, staticContext} = useDataRouterContext2();
            let {matches: routerMatches} = useDataRouterStateContext();
            let enableFogOfWar = isFogOfWarEnabled(routeDiscovery, ssr);
            if (renderMeta) renderMeta.didRenderScripts = true;
            let matches = getActiveMatches(routerMatches, null, isSpaMode);
            react.useEffect(() => {
                0;
            }, []);
            let initialScripts = react.useMemo(() => {
                let streamScript = "window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());";
                let contextScript = staticContext ? `window.__reactRouterContext = ${serverHandoffString};${streamScript}` : " ";
                let routeModulesScript = !isStatic ? " " : `${manifest.hmr?.runtime ? `import ${JSON.stringify(manifest.hmr.runtime)};` : ""}${!enableFogOfWar ? `import ${JSON.stringify(manifest.url)}` : ""};\n${matches.map((match, routeIndex) => {
                    let routeVarName = `route${routeIndex}`;
                    let manifestEntry = manifest.routes[match.route.id];
                    invariant2(manifestEntry, `Route ${match.route.id} not found in manifest`);
                    let {clientActionModule, clientLoaderModule, clientMiddlewareModule, hydrateFallbackModule, module} = manifestEntry;
                    let chunks = [ ...clientActionModule ? [ {
                        module: clientActionModule,
                        varName: `${routeVarName}_clientAction`
                    } ] : [], ...clientLoaderModule ? [ {
                        module: clientLoaderModule,
                        varName: `${routeVarName}_clientLoader`
                    } ] : [], ...clientMiddlewareModule ? [ {
                        module: clientMiddlewareModule,
                        varName: `${routeVarName}_clientMiddleware`
                    } ] : [], ...hydrateFallbackModule ? [ {
                        module: hydrateFallbackModule,
                        varName: `${routeVarName}_HydrateFallback`
                    } ] : [], {
                        module,
                        varName: `${routeVarName}_main`
                    } ];
                    if (chunks.length === 1) return `import * as ${routeVarName} from ${JSON.stringify(module)};`;
                    let chunkImportsSnippet = chunks.map(chunk => `import * as ${chunk.varName} from "${chunk.module}";`).join("\n");
                    let mergedChunksSnippet = `const ${routeVarName} = {${chunks.map(chunk => `...${chunk.varName}`).join(",")}};`;
                    return [ chunkImportsSnippet, mergedChunksSnippet ].join("\n");
                }).join("\n")}\n  ${enableFogOfWar ? `window.__reactRouterManifest = ${JSON.stringify(getPartialManifest(manifest, router), null, 2)};` : ""}\n  window.__reactRouterRouteModules = {${matches.map((match, index) => `${JSON.stringify(match.route.id)}:route${index}`).join(",")}};\n\nimport(${JSON.stringify(manifest.entry.module)});`;
                return react.createElement(react.Fragment, null, react.createElement("script", {
                    ...props,
                    suppressHydrationWarning: true,
                    dangerouslySetInnerHTML: createHtml(contextScript),
                    type: void 0
                }), react.createElement("script", {
                    ...props,
                    suppressHydrationWarning: true,
                    dangerouslySetInnerHTML: createHtml(routeModulesScript),
                    type: "module",
                    async: true
                }));
            }, []);
            let preloads = isHydrated ? [] : dedupe(manifest.entry.imports.concat(getModuleLinkHrefs(matches, manifest, {
                includeHydrateFallback: true
            })));
            let sri = typeof manifest.sri === "object" ? manifest.sri : {};
            return isHydrated ? null : react.createElement(react.Fragment, null, typeof manifest.sri === "object" ? react.createElement("script", {
                "rr-importmap": "",
                type: "importmap",
                suppressHydrationWarning: true,
                dangerouslySetInnerHTML: {
                    __html: JSON.stringify({
                        integrity: sri
                    })
                }
            }) : null, !enableFogOfWar ? react.createElement("link", {
                rel: "modulepreload",
                href: manifest.url,
                crossOrigin: props.crossOrigin,
                integrity: sri[manifest.url],
                suppressHydrationWarning: true
            }) : null, react.createElement("link", {
                rel: "modulepreload",
                href: manifest.entry.module,
                crossOrigin: props.crossOrigin,
                integrity: sri[manifest.entry.module],
                suppressHydrationWarning: true
            }), preloads.map(path => react.createElement("link", {
                key: path,
                rel: "modulepreload",
                href: path,
                crossOrigin: props.crossOrigin,
                integrity: sri[path],
                suppressHydrationWarning: true
            })), initialScripts);
        }
        function dedupe(array) {
            return [ ...new Set(array) ];
        }
        function mergeRefs(...refs) {
            return value => {
                refs.forEach(ref => {
                    if (typeof ref === "function") ref(value); else if (ref != null) ref.current = value;
                });
            };
        }
        var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
        try {
            if (isBrowser) window.__reactRouterVersion = "7.6.3";
        } catch (e) {}
        function HashRouter({basename, children, window: window2}) {
            let historyRef = react.useRef();
            if (historyRef.current == null) historyRef.current = createHashHistory({
                window: window2,
                v5Compat: true
            });
            let history = historyRef.current;
            let [state, setStateImpl] = react.useState({
                action: history.action,
                location: history.location
            });
            let setState = react.useCallback(newState => {
                react.startTransition(() => setStateImpl(newState));
            }, [ setStateImpl ]);
            react.useLayoutEffect(() => history.listen(setState), [ history, setState ]);
            return react.createElement(Router, {
                basename,
                children,
                location: state.location,
                navigationType: state.action,
                navigator: history
            });
        }
        function HistoryRouter({basename, children, history}) {
            let [state, setStateImpl] = react.useState({
                action: history.action,
                location: history.location
            });
            let setState = react.useCallback(newState => {
                react.startTransition(() => setStateImpl(newState));
            }, [ setStateImpl ]);
            react.useLayoutEffect(() => history.listen(setState), [ history, setState ]);
            return react.createElement(Router, {
                basename,
                children,
                location: state.location,
                navigationType: state.action,
                navigator: history
            });
        }
        HistoryRouter.displayName = "unstable_HistoryRouter";
        var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
        var Link = react.forwardRef(function LinkWithRef({onClick, discover = "render", prefetch = "none", relative, reloadDocument, replace: replace2, state, target, to, preventScrollReset, viewTransition, ...rest}, forwardedRef) {
            let {basename} = react.useContext(NavigationContext);
            let isAbsolute = typeof to === "string" && ABSOLUTE_URL_REGEX2.test(to);
            let absoluteHref;
            let isExternal = false;
            if (typeof to === "string" && isAbsolute) {
                absoluteHref = to;
                if (isBrowser) try {
                    let currentUrl = new URL(window.location.href);
                    let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
                    let path = stripBasename(targetUrl.pathname, basename);
                    if (targetUrl.origin === currentUrl.origin && path != null) to = path + targetUrl.search + targetUrl.hash; else isExternal = true;
                } catch (e) {
                    warning(false, `<Link to="${to}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`);
                }
            }
            let href2 = useHref(to, {
                relative
            });
            let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(prefetch, rest);
            let internalOnClick = useLinkClickHandler(to, {
                replace: replace2,
                state,
                target,
                preventScrollReset,
                relative,
                viewTransition
            });
            function handleClick(event) {
                if (onClick) onClick(event);
                if (!event.defaultPrevented) internalOnClick(event);
            }
            let link = react.createElement("a", {
                ...rest,
                ...prefetchHandlers,
                href: absoluteHref || href2,
                onClick: isExternal || reloadDocument ? onClick : handleClick,
                ref: mergeRefs(forwardedRef, prefetchRef),
                target,
                "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
            });
            return shouldPrefetch && !isAbsolute ? react.createElement(react.Fragment, null, link, react.createElement(PrefetchPageLinks, {
                page: href2
            })) : link;
        });
        Link.displayName = "Link";
        var NavLink = react.forwardRef(function NavLinkWithRef({"aria-current": ariaCurrentProp = "page", caseSensitive = false, className: classNameProp = "", end = false, style: styleProp, to, viewTransition, children, ...rest}, ref) {
            let path = useResolvedPath(to, {
                relative: rest.relative
            });
            let location = useLocation();
            let routerState = react.useContext(DataRouterStateContext);
            let {navigator, basename} = react.useContext(NavigationContext);
            let isTransitioning = routerState != null && useViewTransitionState(path) && viewTransition === true;
            let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;
            let locationPathname = location.pathname;
            let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
            if (!caseSensitive) {
                locationPathname = locationPathname.toLowerCase();
                nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
                toPathname = toPathname.toLowerCase();
            }
            if (nextLocationPathname && basename) nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
            const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
            let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
            let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
            let renderProps = {
                isActive,
                isPending,
                isTransitioning
            };
            let ariaCurrent = isActive ? ariaCurrentProp : void 0;
            let className;
            if (typeof classNameProp === "function") className = classNameProp(renderProps); else className = [ classNameProp, isActive ? "active" : null, isPending ? "pending" : null, isTransitioning ? "transitioning" : null ].filter(Boolean).join(" ");
            let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
            return react.createElement(Link, {
                ...rest,
                "aria-current": ariaCurrent,
                className,
                ref,
                style,
                to,
                viewTransition
            }, typeof children === "function" ? children(renderProps) : children);
        });
        NavLink.displayName = "NavLink";
        var Form = react.forwardRef(({discover = "render", fetcherKey, navigate, reloadDocument, replace: replace2, state, method = defaultMethod, action, onSubmit, relative, preventScrollReset, viewTransition, ...props}, forwardedRef) => {
            let submit = useSubmit();
            let formAction = useFormAction(action, {
                relative
            });
            let formMethod = method.toLowerCase() === "get" ? "get" : "post";
            let isAbsolute = typeof action === "string" && ABSOLUTE_URL_REGEX2.test(action);
            let submitHandler = event => {
                onSubmit && onSubmit(event);
                if (event.defaultPrevented) return;
                event.preventDefault();
                let submitter = event.nativeEvent.submitter;
                let submitMethod = submitter?.getAttribute("formmethod") || method;
                submit(submitter || event.currentTarget, {
                    fetcherKey,
                    method: submitMethod,
                    navigate,
                    replace: replace2,
                    state,
                    relative,
                    preventScrollReset,
                    viewTransition
                });
            };
            return react.createElement("form", {
                ref: forwardedRef,
                method: formMethod,
                action: formAction,
                onSubmit: reloadDocument ? onSubmit : submitHandler,
                ...props,
                "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
            });
        });
        Form.displayName = "Form";
        function ScrollRestoration({getKey, storageKey, ...props}) {
            let remixContext = react.useContext(FrameworkContext);
            let {basename} = react.useContext(NavigationContext);
            let location = useLocation();
            let matches = useMatches();
            useScrollRestoration({
                getKey,
                storageKey
            });
            let ssrKey = react.useMemo(() => {
                if (!remixContext || !getKey) return null;
                let userKey = getScrollRestorationKey(location, matches, basename, getKey);
                return userKey !== location.key ? userKey : null;
            }, []);
            if (!remixContext || remixContext.isSpaMode) return null;
            let restoreScroll = ((storageKey2, restoreKey) => {
                if (!window.history.state || !window.history.state.key) {
                    let key = Math.random().toString(32).slice(2);
                    window.history.replaceState({
                        key
                    }, "");
                }
                try {
                    let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
                    let storedY = positions[restoreKey || window.history.state.key];
                    if (typeof storedY === "number") window.scrollTo(0, storedY);
                } catch (error) {
                    console.error(error);
                    sessionStorage.removeItem(storageKey2);
                }
            }).toString();
            return react.createElement("script", {
                ...props,
                suppressHydrationWarning: true,
                dangerouslySetInnerHTML: {
                    __html: `(${restoreScroll})(${JSON.stringify(storageKey || SCROLL_RESTORATION_STORAGE_KEY)}, ${JSON.stringify(ssrKey)})`
                }
            });
        }
        ScrollRestoration.displayName = "ScrollRestoration";
        function getDataRouterConsoleError2(hookName) {
            return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
        }
        function useDataRouterContext3(hookName) {
            let ctx = react.useContext(DataRouterContext);
            invariant(ctx, getDataRouterConsoleError2(hookName));
            return ctx;
        }
        function useDataRouterState2(hookName) {
            let state = react.useContext(DataRouterStateContext);
            invariant(state, getDataRouterConsoleError2(hookName));
            return state;
        }
        function useLinkClickHandler(to, {target, replace: replaceProp, state, preventScrollReset, relative, viewTransition} = {}) {
            let navigate = useNavigate();
            let location = useLocation();
            let path = useResolvedPath(to, {
                relative
            });
            return react.useCallback(event => {
                if (shouldProcessLinkClick(event, target)) {
                    event.preventDefault();
                    let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
                    navigate(to, {
                        replace: replace2,
                        state,
                        preventScrollReset,
                        relative,
                        viewTransition
                    });
                }
            }, [ location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, viewTransition ]);
        }
        var fetcherId = 0;
        var getUniqueFetcherId = () => `__${String(++fetcherId)}__`;
        function useSubmit() {
            let {router} = useDataRouterContext3("useSubmit");
            let {basename} = react.useContext(NavigationContext);
            let currentRouteId = useRouteId();
            return react.useCallback(async (target, options = {}) => {
                let {action, method, encType, formData, body} = getFormSubmissionInfo(target, basename);
                if (options.navigate === false) {
                    let key = options.fetcherKey || getUniqueFetcherId();
                    await router.fetch(key, currentRouteId, options.action || action, {
                        preventScrollReset: options.preventScrollReset,
                        formData,
                        body,
                        formMethod: options.method || method,
                        formEncType: options.encType || encType,
                        flushSync: options.flushSync
                    });
                } else await router.navigate(options.action || action, {
                    preventScrollReset: options.preventScrollReset,
                    formData,
                    body,
                    formMethod: options.method || method,
                    formEncType: options.encType || encType,
                    replace: options.replace,
                    state: options.state,
                    fromRouteId: currentRouteId,
                    flushSync: options.flushSync,
                    viewTransition: options.viewTransition
                });
            }, [ router, basename, currentRouteId ]);
        }
        function useFormAction(action, {relative} = {}) {
            let {basename} = react.useContext(NavigationContext);
            let routeContext = react.useContext(RouteContext);
            invariant(routeContext, "useFormAction must be used inside a RouteContext");
            let [match] = routeContext.matches.slice(-1);
            let path = {
                ...useResolvedPath(action ? action : ".", {
                    relative
                })
            };
            let location = useLocation();
            if (action == null) {
                path.search = location.search;
                let params = new URLSearchParams(path.search);
                let indexValues = params.getAll("index");
                let hasNakedIndexParam = indexValues.some(v => v === "");
                if (hasNakedIndexParam) {
                    params.delete("index");
                    indexValues.filter(v => v).forEach(v => params.append("index", v));
                    let qs = params.toString();
                    path.search = qs ? `?${qs}` : "";
                }
            }
            if ((!action || action === ".") && match.route.index) path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
            if (basename !== "/") path.pathname = path.pathname === "/" ? basename : joinPaths([ basename, path.pathname ]);
            return createPath(path);
        }
        var SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
        var savedScrollPositions = {};
        function getScrollRestorationKey(location, matches, basename, getKey) {
            let key = null;
            if (getKey) if (basename !== "/") key = getKey({
                ...location,
                pathname: stripBasename(location.pathname, basename) || location.pathname
            }, matches); else key = getKey(location, matches);
            if (key == null) key = location.key;
            return key;
        }
        function useScrollRestoration({getKey, storageKey} = {}) {
            let {router} = useDataRouterContext3("useScrollRestoration");
            let {restoreScrollPosition, preventScrollReset} = useDataRouterState2("useScrollRestoration");
            let {basename} = react.useContext(NavigationContext);
            let location = useLocation();
            let matches = useMatches();
            let navigation = useNavigation();
            react.useEffect(() => {
                window.history.scrollRestoration = "manual";
                return () => {
                    window.history.scrollRestoration = "auto";
                };
            }, []);
            usePageHide(react.useCallback(() => {
                if (navigation.state === "idle") {
                    let key = getScrollRestorationKey(location, matches, basename, getKey);
                    savedScrollPositions[key] = window.scrollY;
                }
                try {
                    sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));
                } catch (error) {
                    warning(false, `Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (${error}).`);
                }
                window.history.scrollRestoration = "auto";
            }, [ navigation.state, getKey, basename, location, matches, storageKey ]));
            if (typeof document !== "undefined") {
                react.useLayoutEffect(() => {
                    try {
                        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);
                        if (sessionPositions) savedScrollPositions = JSON.parse(sessionPositions);
                    } catch (e) {}
                }, [ storageKey ]);
                react.useLayoutEffect(() => {
                    let disableScrollRestoration = router?.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKey ? (location2, matches2) => getScrollRestorationKey(location2, matches2, basename, getKey) : void 0);
                    return () => disableScrollRestoration && disableScrollRestoration();
                }, [ router, basename, getKey ]);
                react.useLayoutEffect(() => {
                    if (restoreScrollPosition === false) return;
                    if (typeof restoreScrollPosition === "number") {
                        window.scrollTo(0, restoreScrollPosition);
                        return;
                    }
                    if (location.hash) {
                        let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));
                        if (el) {
                            el.scrollIntoView();
                            return;
                        }
                    }
                    if (preventScrollReset === true) return;
                    window.scrollTo(0, 0);
                }, [ location, restoreScrollPosition, preventScrollReset ]);
            }
        }
        function usePageHide(callback, options) {
            let {capture} = options || {};
            react.useEffect(() => {
                let opts = capture != null ? {
                    capture
                } : void 0;
                window.addEventListener("pagehide", callback, opts);
                return () => {
                    window.removeEventListener("pagehide", callback, opts);
                };
            }, [ callback, capture ]);
        }
        function useViewTransitionState(to, opts = {}) {
            let vtContext = react.useContext(ViewTransitionContext);
            invariant(vtContext != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");
            let {basename} = useDataRouterContext3("useViewTransitionState");
            let path = useResolvedPath(to, {
                relative: opts.relative
            });
            if (!vtContext.isTransitioning) return false;
            let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
            let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
            return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
        }
        new TextEncoder;
        var ServerMode = (ServerMode2 => {
            ServerMode2["Development"] = "development";
            ServerMode2["Production"] = "production";
            ServerMode2["Test"] = "test";
            return ServerMode2;
        })(ServerMode || {});
        new Set([ ...NO_BODY_STATUS_CODES, 304 ]);
        var jsx_runtime = __webpack_require__(848);
        "use client";
        const LayoutGroupContext = (0, react.createContext)({});
        function useConstant(init) {
            const ref = (0, react.useRef)(null);
            if (ref.current === null) ref.current = init();
            return ref.current;
        }
        const is_browser_isBrowser = typeof window !== "undefined";
        const use_isomorphic_effect_useIsomorphicLayoutEffect = is_browser_isBrowser ? react.useLayoutEffect : react.useEffect;
        "use client";
        const PresenceContext_PresenceContext = (0, react.createContext)(null);
        function is_object_isObject(value) {
            return typeof value === "object" && value !== null;
        }
        function isHTMLElement(element) {
            return is_object_isObject(element) && "offsetHeight" in element;
        }
        "use client";
        const MotionConfigContext = (0, react.createContext)({
            transformPagePoint: p => p,
            isStatic: false,
            reducedMotion: "never"
        });
        "use client";
        class PopChildMeasure extends react.Component {
            getSnapshotBeforeUpdate(prevProps) {
                const element = this.props.childRef.current;
                if (element && prevProps.isPresent && !this.props.isPresent) {
                    const parent = element.offsetParent;
                    const parentWidth = isHTMLElement(parent) ? parent.offsetWidth || 0 : 0;
                    const size = this.props.sizeRef.current;
                    size.height = element.offsetHeight || 0;
                    size.width = element.offsetWidth || 0;
                    size.top = element.offsetTop;
                    size.left = element.offsetLeft;
                    size.right = parentWidth - size.width - size.left;
                }
                return null;
            }
            componentDidUpdate() {}
            render() {
                return this.props.children;
            }
        }
        function PopChild({children, isPresent, anchorX, root}) {
            const id = (0, react.useId)();
            const ref = (0, react.useRef)(null);
            const size = (0, react.useRef)({
                width: 0,
                height: 0,
                top: 0,
                left: 0,
                right: 0
            });
            const {nonce} = (0, react.useContext)(MotionConfigContext);
            (0, react.useInsertionEffect)(() => {
                const {width, height, top, left, right} = size.current;
                if (isPresent || !ref.current || !width || !height) return;
                const x = anchorX === "left" ? `left: ${left}` : `right: ${right}`;
                ref.current.dataset.motionPopId = id;
                const style = document.createElement("style");
                if (nonce) style.nonce = nonce;
                const parent = root ?? document.head;
                parent.appendChild(style);
                if (style.sheet) style.sheet.insertRule(`\n          [data-motion-pop-id="${id}"] {\n            position: absolute !important;\n            width: ${width}px !important;\n            height: ${height}px !important;\n            ${x}px !important;\n            top: ${top}px !important;\n          }\n        `);
                return () => {
                    parent.removeChild(style);
                    if (parent.contains(style)) parent.removeChild(style);
                };
            }, [ isPresent ]);
            return (0, jsx_runtime.jsx)(PopChildMeasure, {
                isPresent,
                childRef: ref,
                sizeRef: size,
                children: react.cloneElement(children, {
                    ref
                })
            });
        }
        "use client";
        const PresenceChild = ({children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX, root}) => {
            const presenceChildren = useConstant(newChildrenMap);
            const id = (0, react.useId)();
            let isReusedContext = true;
            let context = (0, react.useMemo)(() => {
                isReusedContext = false;
                return {
                    id,
                    initial,
                    isPresent,
                    custom,
                    onExitComplete: childId => {
                        presenceChildren.set(childId, true);
                        for (const isComplete of presenceChildren.values()) if (!isComplete) return;
                        onExitComplete && onExitComplete();
                    },
                    register: childId => {
                        presenceChildren.set(childId, false);
                        return () => presenceChildren.delete(childId);
                    }
                };
            }, [ isPresent, presenceChildren, onExitComplete ]);
            if (presenceAffectsLayout && isReusedContext) context = {
                ...context
            };
            (0, react.useMemo)(() => {
                presenceChildren.forEach((_, key) => presenceChildren.set(key, false));
            }, [ isPresent ]);
            react.useEffect(() => {
                !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
            }, [ isPresent ]);
            if (mode === "popLayout") children = (0, jsx_runtime.jsx)(PopChild, {
                isPresent,
                anchorX,
                root,
                children
            });
            return (0, jsx_runtime.jsx)(PresenceContext_PresenceContext.Provider, {
                value: context,
                children
            });
        };
        function newChildrenMap() {
            return new Map;
        }
        function usePresence(subscribe = true) {
            const context = (0, react.useContext)(PresenceContext_PresenceContext);
            if (context === null) return [ true, null ];
            const {isPresent, onExitComplete, register} = context;
            const id = (0, react.useId)();
            (0, react.useEffect)(() => {
                if (subscribe) return register(id);
            }, [ subscribe ]);
            const safeToRemove = (0, react.useCallback)(() => subscribe && onExitComplete && onExitComplete(id), [ id, onExitComplete, subscribe ]);
            return !isPresent && onExitComplete ? [ false, safeToRemove ] : [ true ];
        }
        const getChildKey = child => child.key || "";
        function onlyElements(children) {
            const filtered = [];
            react.Children.forEach(children, child => {
                if ((0, react.isValidElement)(child)) filtered.push(child);
            });
            return filtered;
        }
        "use client";
        const AnimatePresence = ({children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", propagate = false, anchorX = "left", root}) => {
            const [isParentPresent, safeToRemove] = usePresence(propagate);
            const presentChildren = (0, react.useMemo)(() => onlyElements(children), [ children ]);
            const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);
            const isInitialRender = (0, react.useRef)(true);
            const pendingPresentChildren = (0, react.useRef)(presentChildren);
            const exitComplete = useConstant(() => new Map);
            const [diffedChildren, setDiffedChildren] = (0, react.useState)(presentChildren);
            const [renderedChildren, setRenderedChildren] = (0, react.useState)(presentChildren);
            use_isomorphic_effect_useIsomorphicLayoutEffect(() => {
                isInitialRender.current = false;
                pendingPresentChildren.current = presentChildren;
                for (let i = 0; i < renderedChildren.length; i++) {
                    const key = getChildKey(renderedChildren[i]);
                    if (!presentKeys.includes(key)) {
                        if (exitComplete.get(key) !== true) exitComplete.set(key, false);
                    } else exitComplete.delete(key);
                }
            }, [ renderedChildren, presentKeys.length, presentKeys.join("-") ]);
            const exitingChildren = [];
            if (presentChildren !== diffedChildren) {
                let nextChildren = [ ...presentChildren ];
                for (let i = 0; i < renderedChildren.length; i++) {
                    const child = renderedChildren[i];
                    const key = getChildKey(child);
                    if (!presentKeys.includes(key)) {
                        nextChildren.splice(i, 0, child);
                        exitingChildren.push(child);
                    }
                }
                if (mode === "wait" && exitingChildren.length) nextChildren = exitingChildren;
                setRenderedChildren(onlyElements(nextChildren));
                setDiffedChildren(presentChildren);
                return null;
            }
            if (false) ;
            const {forceRender} = (0, react.useContext)(LayoutGroupContext);
            return (0, jsx_runtime.jsx)(jsx_runtime.Fragment, {
                children: renderedChildren.map(child => {
                    const key = getChildKey(child);
                    const isPresent = propagate && !isParentPresent ? false : presentChildren === renderedChildren || presentKeys.includes(key);
                    const onExit = () => {
                        if (exitComplete.has(key)) exitComplete.set(key, true); else return;
                        let isEveryExitComplete = true;
                        exitComplete.forEach(isExitComplete => {
                            if (!isExitComplete) isEveryExitComplete = false;
                        });
                        if (isEveryExitComplete) {
                            forceRender?.();
                            setRenderedChildren(pendingPresentChildren.current);
                            propagate && safeToRemove?.();
                            onExitComplete && onExitComplete();
                        }
                    };
                    return (0, jsx_runtime.jsx)(PresenceChild, {
                        isPresent,
                        initial: !isInitialRender.current || initial ? void 0 : false,
                        custom,
                        presenceAffectsLayout,
                        mode,
                        root,
                        onExitComplete: isPresent ? void 0 : onExit,
                        anchorX,
                        children: child
                    }, key);
                })
            });
        };
        var prop_types = __webpack_require__(556);
        var prop_types_default = __webpack_require__.n(prop_types);
        function useAnchorNavigate() {
            const navigate = useNavigate();
            const location = useLocation();
            const goToAnchor = (e, href) => {
                e.preventDefault();
                if (!href.startsWith("#")) {
                    navigate(href);
                    return;
                }
                const targetId = href.slice(1);
                if (location.pathname !== "/") {
                    navigate("/");
                    setTimeout(() => {
                        const target = document.getElementById(targetId);
                        if (target) target.scrollIntoView({
                            behavior: "smooth"
                        });
                    }, 300);
                } else {
                    const target = document.getElementById(targetId);
                    if (target) target.scrollIntoView({
                        behavior: "smooth"
                    });
                }
            };
            return goToAnchor;
        }
        const Menu = ({items, onItemClick}) => {
            const goToAnchor = useAnchorNavigate();
            return react.createElement("nav", {
                className: "header__nav"
            }, react.createElement("ul", {
                className: "header__list text-s"
            }, items.map(({label, href}, idx) => react.createElement("li", {
                key: `${href}-${idx}`,
                className: "header__item"
            }, react.createElement("a", {
                href,
                className: "header__link",
                onClick: e => {
                    goToAnchor(e, href);
                    if (onItemClick) onItemClick();
                }
            }, label)))));
        };
        Menu.propTypes = {
            items: prop_types_default().arrayOf(prop_types_default().shape({
                label: prop_types_default().string.isRequired,
                href: prop_types_default().string
            })).isRequired,
            onItemClick: prop_types_default().func
        };
        const common_Menu = Menu;
        const menuItems = [ {
            label: "About us",
            href: "#about-us"
        }, {
            label: "Solutions+",
            href: "/solutions"
        }, {
            label: "Benefits",
            href: "#benefits"
        }, {
            label: "News & events",
            href: "#news"
        }, {
            label: "Contacts",
            href: "#contacts"
        } ];
        function Header() {
            const [menuOpen, setMenuOpen] = (0, react.useState)(false);
            const buttonRef = (0, react.useRef)(null);
            const headerInnerRef = (0, react.useRef)(null);
            const actionsRef = (0, react.useRef)(null);
            const toggleMenu = () => {
                setMenuOpen(!menuOpen);
                if (!menuOpen) {
                    document.documentElement.classList.add("menu-open");
                    window.bodyLock();
                } else {
                    document.documentElement.classList.remove("menu-open");
                    window.bodyUnlock();
                }
            };
            const closeMenu = () => {
                setMenuOpen(false);
                document.documentElement.classList.remove("menu-open");
                window.bodyUnlock();
            };
            (0, react.useEffect)(() => {
                const button = document.querySelector(".header__button");
                const headerInner = document.querySelector(".header__inner");
                const headerActions = document.querySelector(".header__actions");
                const moveButton = () => {
                    if (!button || !headerInner || !headerActions) return;
                    if (window.innerWidth <= 767.98) {
                        if (headerInner.contains(button)) return;
                        headerInner.insertBefore(button, headerInner.children[1]);
                    } else {
                        if (headerActions.contains(button)) return;
                        headerActions.insertBefore(button, headerActions.firstChild);
                    }
                };
                moveButton();
                window.addEventListener("resize", moveButton);
                return () => {
                    window.removeEventListener("resize", moveButton);
                };
            }, []);
            const location = useLocation();
            const isHomePage = location.pathname === "/";
            return react.createElement("header", {
                "data-scroll": "40",
                "data-scroll-show": true,
                className: "header"
            }, react.createElement("div", {
                className: "header__container"
            }, react.createElement("div", {
                className: "header__wrapper"
            }, isHomePage ? react.createElement("div", {
                className: "header__logo"
            }, react.createElement("img", {
                src: "img/main/logo.svg",
                alt: "logo"
            })) : react.createElement(Link, {
                to: "/",
                className: "header__logo",
                onClick: closeMenu
            }, react.createElement("img", {
                src: "img/main/logo.svg",
                alt: "logo"
            })), react.createElement("div", {
                className: "header__box"
            }, react.createElement("div", {
                className: "header__main"
            }, react.createElement("div", {
                className: "header__inner",
                ref: headerInnerRef
            }, react.createElement(common_Menu, {
                items: menuItems,
                onItemClick: () => {
                    setMenuOpen(false);
                    document.documentElement.classList.remove("menu-open");
                    window.bodyUnlock();
                }
            }))), react.createElement("div", {
                className: "header__actions",
                ref: actionsRef
            }, react.createElement("a", {
                href: "https://t.me/sales_spinree",
                className: "header__button _icon-arrow",
                ref: buttonRef
            }, "JOIN US"), react.createElement("button", {
                type: "button",
                className: `header__menu icon-menu ${menuOpen ? "active" : ""}`,
                onClick: toggleMenu
            }, react.createElement("div", {
                className: "header__icon"
            }, react.createElement("span", null))))))));
        }
        const FooterNav_menuItems = [ {
            label: "About us",
            href: "#about-us"
        }, {
            label: "Solutions+",
            href: "/solutions"
        }, {
            label: "Benefits",
            href: "#benefits"
        }, {
            label: "News & events",
            href: "#news"
        }, {
            label: "Contacts",
            href: "#contacts"
        } ];
        function FooterNav() {
            const goToAnchor = useAnchorNavigate();
            return react.createElement("nav", {
                className: "footer__nav"
            }, react.createElement("ul", {
                className: "footer__list text-s"
            }, FooterNav_menuItems.map((item, i) => react.createElement("li", {
                key: i,
                className: "footer__item"
            }, react.createElement("a", {
                href: item.href,
                className: "footer__link",
                onClick: e => goToAnchor(e, item.href)
            }, item.label)))));
        }
        const socials = [ {
            href: "#",
            icon: "_icon-facebook"
        }, {
            href: "#",
            icon: "_icon-instagram"
        }, {
            href: "https://t.me/sales_spinree",
            icon: "_icon-telegram"
        }, {
            href: "#",
            icon: "_icon-linkedin"
        }, {
            href: "mailto:general@techflick.ltd",
            icon: "_icon-mail"
        } ];
        function FooterSocials() {
            return react.createElement("div", {
                className: "footer__socials socials"
            }, socials.map((social, i) => react.createElement("a", {
                key: i,
                href: social.href,
                className: `socials__link ${social.icon}`
            })));
        }
        function Footer() {
            return react.createElement("footer", {
                className: "footer"
            }, react.createElement("div", {
                className: "footer__container"
            }, react.createElement("div", {
                className: "footer__wrapper"
            }, react.createElement(FooterNav, null), react.createElement(FooterSocials, null)), react.createElement("div", {
                className: "footer__copyright text-xs"
            }, "Copyright ", " ", react.createElement("span", {
                className: "footer__year"
            }, (new Date).getFullYear()), " ", "Spinree.com")));
        }
        const MainSection = () => {
            const goToAnchor = useAnchorNavigate();
            return react.createElement("section", {
                className: "main"
            }, react.createElement("div", {
                className: "main__container blur-1 blur-2"
            }, react.createElement("div", {
                className: "main__content"
            }, react.createElement("h1", {
                className: "main__title"
            }, "Tech that performs, ", react.createElement("span", null, "partnerships"), " that win!"), react.createElement("div", {
                className: "main__text"
            }, "All-in-one and white-label online casino solutions  partnering for success!"), react.createElement("a", {
                href: "#contacts",
                className: "main__button btn",
                onClick: e => goToAnchor(e, "#contacts")
            }, react.createElement("div", {
                className: "btn__icon _icon-arrow-down"
            }), react.createElement("div", {
                className: "btn__text"
            }, "send a request"))), react.createElement("div", {
                className: "main__backgrounds"
            }, react.createElement("div", {
                className: "main__background main__background-1"
            }, react.createElement("picture", null, react.createElement("source", {
                media: "(max-width: 767.98px)",
                srcSet: "img/main/main_image-01_mob.webp"
            }), react.createElement("source", {
                media: "(min-width: 767.98px)",
                srcSet: "img/main/main_image-01_pc.webp"
            }), react.createElement("img", {
                src: "img/main/main_image-01_pc.webp",
                alt: ""
            }))), react.createElement("div", {
                className: "main__background main__background-2"
            }, react.createElement("picture", null, react.createElement("source", {
                media: "(max-width: 767.98px)",
                srcSet: "img/main/main_image-02_mob.webp"
            }), react.createElement("source", {
                media: "(min-width: 767.98px)",
                srcSet: "img/main/main_image-02_pc.webp"
            }), react.createElement("img", {
                src: "img/main/main_image-02_pc.webp",
                alt: ""
            }))))));
        };
        const homepage_MainSection = MainSection;
        const PromoSection = () => {
            const goToAnchor = useAnchorNavigate();
            return react.createElement("section", {
                id: "about-us",
                className: "about-us"
            }, react.createElement("div", {
                className: "about-us__container"
            }, react.createElement("div", {
                className: "about-us__main"
            }, react.createElement("div", {
                className: "about-us__icon _icon-switch"
            }, react.createElement("span", null)), react.createElement("div", {
                className: "about-us__top"
            }, react.createElement("div", {
                className: "about-us__title title-l"
            }, "Get your Online Casino, Live in ", react.createElement("span", null, "3-5 Weeks!")), react.createElement("div", {
                className: "about-us__text text-mob"
            }, "SpinRee is more than just a platform  it's a comprehensive solution tailored to meet the full spectrum of iGaming business needs.")), react.createElement("div", {
                className: "about-us__info info-about"
            }, react.createElement("div", {
                className: "info-about__item"
            }, react.createElement("div", {
                className: "info-about__title h2"
            }, "YOUR GO-TO IGAMING TEAM"), react.createElement("div", {
                className: "info-about__text text-mob"
            }, "From start to finish, we handle absolutely EVERYTHING.")), react.createElement("a", {
                href: "#about-us",
                className: "info-about__link btn-secondary",
                onClick: e => goToAnchor(e, "#about-us")
            }, "about us"))), react.createElement("div", {
                className: "about-us__bg"
            })));
        };
        const AboutSection = PromoSection;
        const ServicesSection = () => react.createElement("section", {
            className: "services"
        }, react.createElement("div", {
            className: "services__main"
        }, react.createElement("div", {
            className: "services__container blur-1 blur-2"
        }, react.createElement("div", {
            className: "services__top"
        }, react.createElement("h2", {
            className: "services__title"
        }, "Creating an inviting ", react.createElement("span", null, "interface")), react.createElement("div", {
            className: "services__text-top text-mob"
        }, "Games and Games Aggregation, Payments, CRM, Whitelabel and Turnkey Solutions, Blockchain & Web 3.0 Development.")), react.createElement("div", {
            className: "services__bg"
        }))), react.createElement("div", {
            className: "services__container services__container--mod"
        }, react.createElement("div", {
            className: "services__wrapper"
        }, react.createElement("div", {
            className: "services__column"
        }, react.createElement("div", {
            className: "services__item"
        }, react.createElement("div", {
            className: "services__subtitle"
        }, "Payments"), react.createElement("div", {
            className: "services__content"
        }, react.createElement("div", {
            className: "services__wrap"
        }, react.createElement("div", {
            className: "services__image services__image-1"
        }, react.createElement("img", {
            src: "img/main/mastercard.webp",
            alt: ""
        })), react.createElement("div", {
            className: "services__image services__image-2"
        }, react.createElement("img", {
            src: "img/main/visa.webp",
            alt: ""
        })), react.createElement("div", {
            className: "services__image services__image-3"
        }, react.createElement("img", {
            src: "img/main/upi.webp",
            alt: ""
        })), react.createElement("div", {
            className: "services__image services__image-4"
        }, react.createElement("img", {
            src: "img/main/pix.webp",
            alt: ""
        }))), react.createElement("div", {
            className: "services__more text-m"
        }, "and more"))), react.createElement("div", {
            className: "services__item"
        }, react.createElement("div", {
            className: "services__subtitle"
        }, "Games"), react.createElement("div", {
            className: "services__content"
        }, react.createElement("div", {
            className: "services__list"
        }, react.createElement("div", {
            className: "services__text services__text--mod text-l"
        }, "+10,000 games"), react.createElement("div", {
            className: "services__text services__text--mod text-l"
        }, "Sportsbook & Virtual Sports")), react.createElement("div", {
            className: "services__wrap"
        }, react.createElement("div", {
            className: "services__image services__image-5"
        }, react.createElement("img", {
            src: "img/main/evolution.webp",
            alt: ""
        })), react.createElement("div", {
            className: "services__image services__image-6"
        }, react.createElement("img", {
            src: "img/main/playtech.webp",
            alt: ""
        })), react.createElement("div", {
            className: "services__image services__image-7"
        }, react.createElement("img", {
            src: "img/main/pragmatikplay.webp",
            alt: ""
        })), react.createElement("div", {
            className: "services__image services__image-8"
        }, react.createElement("img", {
            src: "img/main/playngo.webp",
            alt: ""
        })))))), react.createElement("div", {
            className: "services__column segmentation"
        }, react.createElement("div", {
            className: "segmentation__wrap"
        }, react.createElement("div", {
            className: "segmentation__title"
        }, "Spinree"), react.createElement("div", {
            className: "segmentation__text"
        }, "core"), react.createElement("div", {
            className: "segmentation__bg"
        }, react.createElement("img", {
            src: "img/main/services_image-01_pc.webp",
            alt: ""
        }))), react.createElement("div", {
            className: "segmentation__bottom"
        }, react.createElement("div", {
            className: "segmentation__inner"
        }, react.createElement("div", {
            className: "segmentation__image"
        }, react.createElement("img", {
            src: "img/main/diagram.webp",
            alt: ""
        })), react.createElement("div", {
            className: "segmentation__bottom-title"
        }, "Segmentation"), react.createElement("div", {
            className: "segmentation__bottom-text text-m"
        }, "Real-time")))), react.createElement("div", {
            className: "services__column"
        }, react.createElement("div", {
            className: "services__item"
        }, react.createElement("div", {
            className: "services__subtitle"
        }, "CRM"), react.createElement("div", {
            className: "services__content"
        }, react.createElement("div", {
            className: "services__list"
        }, react.createElement("div", {
            className: "services__text text-l"
        }, "Bonuses"), react.createElement("div", {
            className: "services__text text-l"
        }, "Tournaments"), react.createElement("div", {
            className: "services__text text-l"
        }, "Communication")))), react.createElement("div", {
            className: "services__item"
        }, react.createElement("div", {
            className: "services__subtitle"
        }, "Backoffice"), react.createElement("div", {
            className: "services__content"
        }, react.createElement("div", {
            className: "services__list"
        }, react.createElement("div", {
            className: "services__text text-l"
        }, "Configuration"), react.createElement("div", {
            className: "services__text text-l"
        }, "Analytics"), react.createElement("div", {
            className: "services__text text-l"
        }, "Managment"))))))));
        const homepage_ServicesSection = ServicesSection;
        const BenefitsSection = () => react.createElement("section", {
            id: "benefits",
            className: "benefits"
        }, react.createElement("div", {
            className: "benefits__container"
        }, react.createElement("div", {
            className: "benefits__title h2"
        }, "Why choose us?"), react.createElement("div", {
            className: "benefits__wrapper"
        }, react.createElement("div", {
            className: "benefits__item"
        }, react.createElement("span", null, "INNOVATION")), react.createElement("div", {
            className: "benefits__item"
        }, react.createElement("span", null, "RELIABILITY")), react.createElement("div", {
            className: "benefits__item"
        }, react.createElement("span", null, "SCAPABILITY")), react.createElement("div", {
            className: "benefits__item"
        }, react.createElement("span", null, "HIGH PERFORMANCE")))));
        const homepage_BenefitsSection = BenefitsSection;
        const NewsSlide = ({image, title, date}) => {
            const goToAnchor = useAnchorNavigate();
            return react.createElement("div", {
                className: "news__slide"
            }, react.createElement("div", {
                className: "news__image"
            }, react.createElement("img", {
                src: image,
                alt: title
            })), react.createElement("div", {
                className: "news__content"
            }, react.createElement("div", {
                className: "news__main"
            }, react.createElement("div", {
                className: "news__subtitle"
            }, title), react.createElement("div", {
                className: "news__date"
            }, date)), react.createElement("a", {
                href: "https://t.me/sales_spinree",
                className: "news__button",
                onClick: e => goToAnchor(e, "#contacts")
            }, "book the meeting")));
        };
        const homepage_NewsSlide = NewsSlide;
        function ssr_window_esm_isObject(obj) {
            return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
        }
        function extend(target, src) {
            if (target === void 0) target = {};
            if (src === void 0) src = {};
            const noExtend = [ "__proto__", "constructor", "prototype" ];
            Object.keys(src).filter(key => noExtend.indexOf(key) < 0).forEach(key => {
                if (typeof target[key] === "undefined") target[key] = src[key]; else if (ssr_window_esm_isObject(src[key]) && ssr_window_esm_isObject(target[key]) && Object.keys(src[key]).length > 0) extend(target[key], src[key]);
            });
        }
        const ssrDocument = {
            body: {},
            addEventListener() {},
            removeEventListener() {},
            activeElement: {
                blur() {},
                nodeName: ""
            },
            querySelector() {
                return null;
            },
            querySelectorAll() {
                return [];
            },
            getElementById() {
                return null;
            },
            createEvent() {
                return {
                    initEvent() {}
                };
            },
            createElement() {
                return {
                    children: [],
                    childNodes: [],
                    style: {},
                    setAttribute() {},
                    getElementsByTagName() {
                        return [];
                    }
                };
            },
            createElementNS() {
                return {};
            },
            importNode() {
                return null;
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            }
        };
        function ssr_window_esm_getDocument() {
            const doc = typeof document !== "undefined" ? document : {};
            extend(doc, ssrDocument);
            return doc;
        }
        const ssrWindow = {
            document: ssrDocument,
            navigator: {
                userAgent: ""
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            },
            history: {
                replaceState() {},
                pushState() {},
                go() {},
                back() {}
            },
            CustomEvent: function CustomEvent() {
                return this;
            },
            addEventListener() {},
            removeEventListener() {},
            getComputedStyle() {
                return {
                    getPropertyValue() {
                        return "";
                    }
                };
            },
            Image() {},
            Date() {},
            screen: {},
            setTimeout() {},
            clearTimeout() {},
            matchMedia() {
                return {};
            },
            requestAnimationFrame(callback) {
                if (typeof setTimeout === "undefined") {
                    callback();
                    return null;
                }
                return setTimeout(callback, 0);
            },
            cancelAnimationFrame(id) {
                if (typeof setTimeout === "undefined") return;
                clearTimeout(id);
            }
        };
        function ssr_window_esm_getWindow() {
            const win = typeof window !== "undefined" ? window : {};
            extend(win, ssrWindow);
            return win;
        }
        function utils_classesToTokens(classes) {
            if (classes === void 0) classes = "";
            return classes.trim().split(" ").filter(c => !!c.trim());
        }
        function deleteProps(obj) {
            const object = obj;
            Object.keys(object).forEach(key => {
                try {
                    object[key] = null;
                } catch (e) {}
                try {
                    delete object[key];
                } catch (e) {}
            });
        }
        function utils_nextTick(callback, delay) {
            if (delay === void 0) delay = 0;
            return setTimeout(callback, delay);
        }
        function now() {
            return Date.now();
        }
        function utils_getComputedStyle(el) {
            const window = ssr_window_esm_getWindow();
            let style;
            if (window.getComputedStyle) style = window.getComputedStyle(el, null);
            if (!style && el.currentStyle) style = el.currentStyle;
            if (!style) style = el.style;
            return style;
        }
        function utils_getTranslate(el, axis) {
            if (axis === void 0) axis = "x";
            const window = ssr_window_esm_getWindow();
            let matrix;
            let curTransform;
            let transformMatrix;
            const curStyle = utils_getComputedStyle(el);
            if (window.WebKitCSSMatrix) {
                curTransform = curStyle.transform || curStyle.webkitTransform;
                if (curTransform.split(",").length > 6) curTransform = curTransform.split(", ").map(a => a.replace(",", ".")).join(", ");
                transformMatrix = new window.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
            } else {
                transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
                matrix = transformMatrix.toString().split(",");
            }
            if (axis === "x") if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); else curTransform = parseFloat(matrix[4]);
            if (axis === "y") if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); else curTransform = parseFloat(matrix[5]);
            return curTransform || 0;
        }
        function utils_isObject(o) {
            return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object";
        }
        function isNode(node) {
            if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") return node instanceof HTMLElement;
            return node && (node.nodeType === 1 || node.nodeType === 11);
        }
        function utils_extend() {
            const to = Object(arguments.length <= 0 ? void 0 : arguments[0]);
            const noExtend = [ "__proto__", "constructor", "prototype" ];
            for (let i = 1; i < arguments.length; i += 1) {
                const nextSource = i < 0 || arguments.length <= i ? void 0 : arguments[i];
                if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
                    const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);
                    for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
                        const nextKey = keysArray[nextIndex];
                        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                        if (desc !== void 0 && desc.enumerable) if (utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else utils_extend(to[nextKey], nextSource[nextKey]); else if (!utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) {
                            to[nextKey] = {};
                            if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else utils_extend(to[nextKey], nextSource[nextKey]);
                        } else to[nextKey] = nextSource[nextKey];
                    }
                }
            }
            return to;
        }
        function utils_setCSSProperty(el, varName, varValue) {
            el.style.setProperty(varName, varValue);
        }
        function animateCSSModeScroll(_ref) {
            let {swiper, targetPosition, side} = _ref;
            const window = ssr_window_esm_getWindow();
            const startPosition = -swiper.translate;
            let startTime = null;
            let time;
            const duration = swiper.params.speed;
            swiper.wrapperEl.style.scrollSnapType = "none";
            window.cancelAnimationFrame(swiper.cssModeFrameID);
            const dir = targetPosition > startPosition ? "next" : "prev";
            const isOutOfBound = (current, target) => dir === "next" && current >= target || dir === "prev" && current <= target;
            const animate = () => {
                time = (new Date).getTime();
                if (startTime === null) startTime = time;
                const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
                const easeProgress = .5 - Math.cos(progress * Math.PI) / 2;
                let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
                if (isOutOfBound(currentPosition, targetPosition)) currentPosition = targetPosition;
                swiper.wrapperEl.scrollTo({
                    [side]: currentPosition
                });
                if (isOutOfBound(currentPosition, targetPosition)) {
                    swiper.wrapperEl.style.overflow = "hidden";
                    swiper.wrapperEl.style.scrollSnapType = "";
                    setTimeout(() => {
                        swiper.wrapperEl.style.overflow = "";
                        swiper.wrapperEl.scrollTo({
                            [side]: currentPosition
                        });
                    });
                    window.cancelAnimationFrame(swiper.cssModeFrameID);
                    return;
                }
                swiper.cssModeFrameID = window.requestAnimationFrame(animate);
            };
            animate();
        }
        function utils_getSlideTransformEl(slideEl) {
            return slideEl.querySelector(".swiper-slide-transform") || slideEl.shadowRoot && slideEl.shadowRoot.querySelector(".swiper-slide-transform") || slideEl;
        }
        function utils_elementChildren(element, selector) {
            if (selector === void 0) selector = "";
            const window = ssr_window_esm_getWindow();
            const children = [ ...element.children ];
            if (window.HTMLSlotElement && element instanceof HTMLSlotElement) children.push(...element.assignedElements());
            if (!selector) return children;
            return children.filter(el => el.matches(selector));
        }
        function elementIsChildOfSlot(el, slot) {
            const elementsQueue = [ slot ];
            while (elementsQueue.length > 0) {
                const elementToCheck = elementsQueue.shift();
                if (el === elementToCheck) return true;
                elementsQueue.push(...elementToCheck.children, ...elementToCheck.shadowRoot ? elementToCheck.shadowRoot.children : [], ...elementToCheck.assignedElements ? elementToCheck.assignedElements() : []);
            }
        }
        function elementIsChildOf(el, parent) {
            const window = ssr_window_esm_getWindow();
            let isChild = parent.contains(el);
            if (!isChild && window.HTMLSlotElement && parent instanceof HTMLSlotElement) {
                const children = [ ...parent.assignedElements() ];
                isChild = children.includes(el);
                if (!isChild) isChild = elementIsChildOfSlot(el, parent);
            }
            return isChild;
        }
        function showWarning(text) {
            try {
                console.warn(text);
                return;
            } catch (err) {}
        }
        function utils_createElement(tag, classes) {
            if (classes === void 0) classes = [];
            const el = document.createElement(tag);
            el.classList.add(...Array.isArray(classes) ? classes : utils_classesToTokens(classes));
            return el;
        }
        function elementPrevAll(el, selector) {
            const prevEls = [];
            while (el.previousElementSibling) {
                const prev = el.previousElementSibling;
                if (selector) {
                    if (prev.matches(selector)) prevEls.push(prev);
                } else prevEls.push(prev);
                el = prev;
            }
            return prevEls;
        }
        function elementNextAll(el, selector) {
            const nextEls = [];
            while (el.nextElementSibling) {
                const next = el.nextElementSibling;
                if (selector) {
                    if (next.matches(selector)) nextEls.push(next);
                } else nextEls.push(next);
                el = next;
            }
            return nextEls;
        }
        function elementStyle(el, prop) {
            const window = ssr_window_esm_getWindow();
            return window.getComputedStyle(el, null).getPropertyValue(prop);
        }
        function utils_elementIndex(el) {
            let child = el;
            let i;
            if (child) {
                i = 0;
                while ((child = child.previousSibling) !== null) if (child.nodeType === 1) i += 1;
                return i;
            }
            return;
        }
        function utils_elementParents(el, selector) {
            const parents = [];
            let parent = el.parentElement;
            while (parent) {
                if (selector) {
                    if (parent.matches(selector)) parents.push(parent);
                } else parents.push(parent);
                parent = parent.parentElement;
            }
            return parents;
        }
        function utils_elementTransitionEnd(el, callback) {
            function fireCallBack(e) {
                if (e.target !== el) return;
                callback.call(el, e);
                el.removeEventListener("transitionend", fireCallBack);
            }
            if (callback) el.addEventListener("transitionend", fireCallBack);
        }
        function elementOuterSize(el, size, includeMargins) {
            const window = ssr_window_esm_getWindow();
            if (includeMargins) return el[size === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-right" : "margin-top")) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-left" : "margin-bottom"));
            return el.offsetWidth;
        }
        function utils_makeElementsArray(el) {
            return (Array.isArray(el) ? el : [ el ]).filter(e => !!e);
        }
        function utils_setInnerHTML(el, html) {
            if (html === void 0) html = "";
            if (typeof trustedTypes !== "undefined") el.innerHTML = trustedTypes.createPolicy("html", {
                createHTML: s => s
            }).createHTML(html); else el.innerHTML = html;
        }
        let support;
        function calcSupport() {
            const window = ssr_window_esm_getWindow();
            const document = ssr_window_esm_getDocument();
            return {
                smoothScroll: document.documentElement && document.documentElement.style && "scrollBehavior" in document.documentElement.style,
                touch: !!("ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch)
            };
        }
        function getSupport() {
            if (!support) support = calcSupport();
            return support;
        }
        let deviceCached;
        function calcDevice(_temp) {
            let {userAgent} = _temp === void 0 ? {} : _temp;
            const support = getSupport();
            const window = ssr_window_esm_getWindow();
            const platform = window.navigator.platform;
            const ua = userAgent || window.navigator.userAgent;
            const device = {
                ios: false,
                android: false
            };
            const screenWidth = window.screen.width;
            const screenHeight = window.screen.height;
            const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
            let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
            const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
            const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
            const windows = platform === "Win32";
            let macos = platform === "MacIntel";
            const iPadScreens = [ "1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810" ];
            if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
                ipad = ua.match(/(Version)\/([\d.]+)/);
                if (!ipad) ipad = [ 0, 1, "13_0_0" ];
                macos = false;
            }
            if (android && !windows) {
                device.os = "android";
                device.android = true;
            }
            if (ipad || iphone || ipod) {
                device.os = "ios";
                device.ios = true;
            }
            return device;
        }
        function getDevice(overrides) {
            if (overrides === void 0) overrides = {};
            if (!deviceCached) deviceCached = calcDevice(overrides);
            return deviceCached;
        }
        let browser;
        function calcBrowser() {
            const window = ssr_window_esm_getWindow();
            const device = getDevice();
            let needPerspectiveFix = false;
            function isSafari() {
                const ua = window.navigator.userAgent.toLowerCase();
                return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
            }
            if (isSafari()) {
                const ua = String(window.navigator.userAgent);
                if (ua.includes("Version/")) {
                    const [major, minor] = ua.split("Version/")[1].split(" ")[0].split(".").map(num => Number(num));
                    needPerspectiveFix = major < 16 || major === 16 && minor < 2;
                }
            }
            const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent);
            const isSafariBrowser = isSafari();
            const need3dFix = isSafariBrowser || isWebView && device.ios;
            return {
                isSafari: needPerspectiveFix || isSafariBrowser,
                needPerspectiveFix,
                need3dFix,
                isWebView
            };
        }
        function getBrowser() {
            if (!browser) browser = calcBrowser();
            return browser;
        }
        function Resize(_ref) {
            let {swiper, on, emit} = _ref;
            const window = ssr_window_esm_getWindow();
            let observer = null;
            let animationFrame = null;
            const resizeHandler = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                emit("beforeResize");
                emit("resize");
            };
            const createObserver = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                observer = new ResizeObserver(entries => {
                    animationFrame = window.requestAnimationFrame(() => {
                        const {width, height} = swiper;
                        let newWidth = width;
                        let newHeight = height;
                        entries.forEach(_ref2 => {
                            let {contentBoxSize, contentRect, target} = _ref2;
                            if (target && target !== swiper.el) return;
                            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
                        });
                        if (newWidth !== width || newHeight !== height) resizeHandler();
                    });
                });
                observer.observe(swiper.el);
            };
            const removeObserver = () => {
                if (animationFrame) window.cancelAnimationFrame(animationFrame);
                if (observer && observer.unobserve && swiper.el) {
                    observer.unobserve(swiper.el);
                    observer = null;
                }
            };
            const orientationChangeHandler = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                emit("orientationchange");
            };
            on("init", () => {
                if (swiper.params.resizeObserver && typeof window.ResizeObserver !== "undefined") {
                    createObserver();
                    return;
                }
                window.addEventListener("resize", resizeHandler);
                window.addEventListener("orientationchange", orientationChangeHandler);
            });
            on("destroy", () => {
                removeObserver();
                window.removeEventListener("resize", resizeHandler);
                window.removeEventListener("orientationchange", orientationChangeHandler);
            });
        }
        function Observer(_ref) {
            let {swiper, extendParams, on, emit} = _ref;
            const observers = [];
            const window = ssr_window_esm_getWindow();
            const attach = function(target, options) {
                if (options === void 0) options = {};
                const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
                const observer = new ObserverFunc(mutations => {
                    if (swiper.__preventObserver__) return;
                    if (mutations.length === 1) {
                        emit("observerUpdate", mutations[0]);
                        return;
                    }
                    const observerUpdate = function observerUpdate() {
                        emit("observerUpdate", mutations[0]);
                    };
                    if (window.requestAnimationFrame) window.requestAnimationFrame(observerUpdate); else window.setTimeout(observerUpdate, 0);
                });
                observer.observe(target, {
                    attributes: typeof options.attributes === "undefined" ? true : options.attributes,
                    childList: swiper.isElement || (typeof options.childList === "undefined" ? true : options).childList,
                    characterData: typeof options.characterData === "undefined" ? true : options.characterData
                });
                observers.push(observer);
            };
            const init = () => {
                if (!swiper.params.observer) return;
                if (swiper.params.observeParents) {
                    const containerParents = utils_elementParents(swiper.hostEl);
                    for (let i = 0; i < containerParents.length; i += 1) attach(containerParents[i]);
                }
                attach(swiper.hostEl, {
                    childList: swiper.params.observeSlideChildren
                });
                attach(swiper.wrapperEl, {
                    attributes: false
                });
            };
            const destroy = () => {
                observers.forEach(observer => {
                    observer.disconnect();
                });
                observers.splice(0, observers.length);
            };
            extendParams({
                observer: false,
                observeParents: false,
                observeSlideChildren: false
            });
            on("init", init);
            on("destroy", destroy);
        }
        var eventsEmitter = {
            on(events, handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (typeof handler !== "function") return self;
                const method = priority ? "unshift" : "push";
                events.split(" ").forEach(event => {
                    if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
                    self.eventsListeners[event][method](handler);
                });
                return self;
            },
            once(events, handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (typeof handler !== "function") return self;
                function onceHandler() {
                    self.off(events, onceHandler);
                    if (onceHandler.__emitterProxy) delete onceHandler.__emitterProxy;
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    handler.apply(self, args);
                }
                onceHandler.__emitterProxy = handler;
                return self.on(events, onceHandler, priority);
            },
            onAny(handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (typeof handler !== "function") return self;
                const method = priority ? "unshift" : "push";
                if (self.eventsAnyListeners.indexOf(handler) < 0) self.eventsAnyListeners[method](handler);
                return self;
            },
            offAny(handler) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsAnyListeners) return self;
                const index = self.eventsAnyListeners.indexOf(handler);
                if (index >= 0) self.eventsAnyListeners.splice(index, 1);
                return self;
            },
            off(events, handler) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsListeners) return self;
                events.split(" ").forEach(event => {
                    if (typeof handler === "undefined") self.eventsListeners[event] = []; else if (self.eventsListeners[event]) self.eventsListeners[event].forEach((eventHandler, index) => {
                        if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) self.eventsListeners[event].splice(index, 1);
                    });
                });
                return self;
            },
            emit() {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsListeners) return self;
                let events;
                let data;
                let context;
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                if (typeof args[0] === "string" || Array.isArray(args[0])) {
                    events = args[0];
                    data = args.slice(1, args.length);
                    context = self;
                } else {
                    events = args[0].events;
                    data = args[0].data;
                    context = args[0].context || self;
                }
                data.unshift(context);
                const eventsArray = Array.isArray(events) ? events : events.split(" ");
                eventsArray.forEach(event => {
                    if (self.eventsAnyListeners && self.eventsAnyListeners.length) self.eventsAnyListeners.forEach(eventHandler => {
                        eventHandler.apply(context, [ event, ...data ]);
                    });
                    if (self.eventsListeners && self.eventsListeners[event]) self.eventsListeners[event].forEach(eventHandler => {
                        eventHandler.apply(context, data);
                    });
                });
                return self;
            }
        };
        function updateSize() {
            const swiper = this;
            let width;
            let height;
            const el = swiper.el;
            if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) width = swiper.params.width; else width = el.clientWidth;
            if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) height = swiper.params.height; else height = el.clientHeight;
            if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) return;
            width = width - parseInt(elementStyle(el, "padding-left") || 0, 10) - parseInt(elementStyle(el, "padding-right") || 0, 10);
            height = height - parseInt(elementStyle(el, "padding-top") || 0, 10) - parseInt(elementStyle(el, "padding-bottom") || 0, 10);
            if (Number.isNaN(width)) width = 0;
            if (Number.isNaN(height)) height = 0;
            Object.assign(swiper, {
                width,
                height,
                size: swiper.isHorizontal() ? width : height
            });
        }
        function updateSlides() {
            const swiper = this;
            function getDirectionPropertyValue(node, label) {
                return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);
            }
            const params = swiper.params;
            const {wrapperEl, slidesEl, size: swiperSize, rtlTranslate: rtl, wrongRTL} = swiper;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
            const slides = utils_elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
            const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
            let snapGrid = [];
            const slidesGrid = [];
            const slidesSizesGrid = [];
            let offsetBefore = params.slidesOffsetBefore;
            if (typeof offsetBefore === "function") offsetBefore = params.slidesOffsetBefore.call(swiper);
            let offsetAfter = params.slidesOffsetAfter;
            if (typeof offsetAfter === "function") offsetAfter = params.slidesOffsetAfter.call(swiper);
            const previousSnapGridLength = swiper.snapGrid.length;
            const previousSlidesGridLength = swiper.slidesGrid.length;
            let spaceBetween = params.spaceBetween;
            let slidePosition = -offsetBefore;
            let prevSlideSize = 0;
            let index = 0;
            if (typeof swiperSize === "undefined") return;
            if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize; else if (typeof spaceBetween === "string") spaceBetween = parseFloat(spaceBetween);
            swiper.virtualSize = -spaceBetween;
            slides.forEach(slideEl => {
                if (rtl) slideEl.style.marginLeft = ""; else slideEl.style.marginRight = "";
                slideEl.style.marginBottom = "";
                slideEl.style.marginTop = "";
            });
            if (params.centeredSlides && params.cssMode) {
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-before", "");
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-after", "");
            }
            const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
            if (gridEnabled) swiper.grid.initSlides(slides); else if (swiper.grid) swiper.grid.unsetSlides();
            let slideSize;
            const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter(key => typeof params.breakpoints[key].slidesPerView !== "undefined").length > 0;
            for (let i = 0; i < slidesLength; i += 1) {
                slideSize = 0;
                let slide;
                if (slides[i]) slide = slides[i];
                if (gridEnabled) swiper.grid.updateSlide(i, slide, slides);
                if (slides[i] && elementStyle(slide, "display") === "none") continue;
                if (params.slidesPerView === "auto") {
                    if (shouldResetSlideSize) slides[i].style[swiper.getDirectionLabel("width")] = ``;
                    const slideStyles = getComputedStyle(slide);
                    const currentTransform = slide.style.transform;
                    const currentWebKitTransform = slide.style.webkitTransform;
                    if (currentTransform) slide.style.transform = "none";
                    if (currentWebKitTransform) slide.style.webkitTransform = "none";
                    if (params.roundLengths) slideSize = swiper.isHorizontal() ? elementOuterSize(slide, "width", true) : elementOuterSize(slide, "height", true); else {
                        const width = getDirectionPropertyValue(slideStyles, "width");
                        const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
                        const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
                        const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
                        const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
                        const boxSizing = slideStyles.getPropertyValue("box-sizing");
                        if (boxSizing && boxSizing === "border-box") slideSize = width + marginLeft + marginRight; else {
                            const {clientWidth, offsetWidth} = slide;
                            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
                        }
                    }
                    if (currentTransform) slide.style.transform = currentTransform;
                    if (currentWebKitTransform) slide.style.webkitTransform = currentWebKitTransform;
                    if (params.roundLengths) slideSize = Math.floor(slideSize);
                } else {
                    slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
                    if (params.roundLengths) slideSize = Math.floor(slideSize);
                    if (slides[i]) slides[i].style[swiper.getDirectionLabel("width")] = `${slideSize}px`;
                }
                if (slides[i]) slides[i].swiperSlideSize = slideSize;
                slidesSizesGrid.push(slideSize);
                if (params.centeredSlides) {
                    slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
                    if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                    if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                    if (Math.abs(slidePosition) < 1 / 1e3) slidePosition = 0;
                    if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                    if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                    slidesGrid.push(slidePosition);
                } else {
                    if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                    if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                    slidesGrid.push(slidePosition);
                    slidePosition = slidePosition + slideSize + spaceBetween;
                }
                swiper.virtualSize += slideSize + spaceBetween;
                prevSlideSize = slideSize;
                index += 1;
            }
            swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
            if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
            if (params.setWrapperSize) wrapperEl.style[swiper.getDirectionLabel("width")] = `${swiper.virtualSize + spaceBetween}px`;
            if (gridEnabled) swiper.grid.updateWrapperSize(slideSize, snapGrid);
            if (!params.centeredSlides) {
                const newSlidesGrid = [];
                for (let i = 0; i < snapGrid.length; i += 1) {
                    let slidesGridItem = snapGrid[i];
                    if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                    if (snapGrid[i] <= swiper.virtualSize - swiperSize) newSlidesGrid.push(slidesGridItem);
                }
                snapGrid = newSlidesGrid;
                if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) snapGrid.push(swiper.virtualSize - swiperSize);
            }
            if (isVirtual && params.loop) {
                const size = slidesSizesGrid[0] + spaceBetween;
                if (params.slidesPerGroup > 1) {
                    const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
                    const groupSize = size * params.slidesPerGroup;
                    for (let i = 0; i < groups; i += 1) snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
                }
                for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {
                    if (params.slidesPerGroup === 1) snapGrid.push(snapGrid[snapGrid.length - 1] + size);
                    slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
                    swiper.virtualSize += size;
                }
            }
            if (snapGrid.length === 0) snapGrid = [ 0 ];
            if (spaceBetween !== 0) {
                const key = swiper.isHorizontal() && rtl ? "marginLeft" : swiper.getDirectionLabel("marginRight");
                slides.filter((_, slideIndex) => {
                    if (!params.cssMode || params.loop) return true;
                    if (slideIndex === slides.length - 1) return false;
                    return true;
                }).forEach(slideEl => {
                    slideEl.style[key] = `${spaceBetween}px`;
                });
            }
            if (params.centeredSlides && params.centeredSlidesBounds) {
                let allSlidesSize = 0;
                slidesSizesGrid.forEach(slideSizeValue => {
                    allSlidesSize += slideSizeValue + (spaceBetween || 0);
                });
                allSlidesSize -= spaceBetween;
                const maxSnap = allSlidesSize > swiperSize ? allSlidesSize - swiperSize : 0;
                snapGrid = snapGrid.map(snap => {
                    if (snap <= 0) return -offsetBefore;
                    if (snap > maxSnap) return maxSnap + offsetAfter;
                    return snap;
                });
            }
            if (params.centerInsufficientSlides) {
                let allSlidesSize = 0;
                slidesSizesGrid.forEach(slideSizeValue => {
                    allSlidesSize += slideSizeValue + (spaceBetween || 0);
                });
                allSlidesSize -= spaceBetween;
                const offsetSize = (params.slidesOffsetBefore || 0) + (params.slidesOffsetAfter || 0);
                if (allSlidesSize + offsetSize < swiperSize) {
                    const allSlidesOffset = (swiperSize - allSlidesSize - offsetSize) / 2;
                    snapGrid.forEach((snap, snapIndex) => {
                        snapGrid[snapIndex] = snap - allSlidesOffset;
                    });
                    slidesGrid.forEach((snap, snapIndex) => {
                        slidesGrid[snapIndex] = snap + allSlidesOffset;
                    });
                }
            }
            Object.assign(swiper, {
                slides,
                snapGrid,
                slidesGrid,
                slidesSizesGrid
            });
            if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
                const addToSnapGrid = -swiper.snapGrid[0];
                const addToSlidesGrid = -swiper.slidesGrid[0];
                swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
                swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
            }
            if (slidesLength !== previousSlidesLength) swiper.emit("slidesLengthChange");
            if (snapGrid.length !== previousSnapGridLength) {
                if (swiper.params.watchOverflow) swiper.checkOverflow();
                swiper.emit("snapGridLengthChange");
            }
            if (slidesGrid.length !== previousSlidesGridLength) swiper.emit("slidesGridLengthChange");
            if (params.watchSlidesProgress) swiper.updateSlidesOffset();
            swiper.emit("slidesUpdated");
            if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
                const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
                const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
                if (slidesLength <= params.maxBackfaceHiddenSlides) {
                    if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);
                } else if (hasClassBackfaceClassAdded) swiper.el.classList.remove(backFaceHiddenClass);
            }
        }
        function updateAutoHeight(speed) {
            const swiper = this;
            const activeSlides = [];
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            let newHeight = 0;
            let i;
            if (typeof speed === "number") swiper.setTransition(speed); else if (speed === true) swiper.setTransition(swiper.params.speed);
            const getSlideByIndex = index => {
                if (isVirtual) return swiper.slides[swiper.getSlideIndexByData(index)];
                return swiper.slides[index];
            };
            if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) if (swiper.params.centeredSlides) (swiper.visibleSlides || []).forEach(slide => {
                activeSlides.push(slide);
            }); else for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
                const index = swiper.activeIndex + i;
                if (index > swiper.slides.length && !isVirtual) break;
                activeSlides.push(getSlideByIndex(index));
            } else activeSlides.push(getSlideByIndex(swiper.activeIndex));
            for (i = 0; i < activeSlides.length; i += 1) if (typeof activeSlides[i] !== "undefined") {
                const height = activeSlides[i].offsetHeight;
                newHeight = height > newHeight ? height : newHeight;
            }
            if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;
        }
        function updateSlidesOffset() {
            const swiper = this;
            const slides = swiper.slides;
            const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
            for (let i = 0; i < slides.length; i += 1) slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
        }
        const toggleSlideClasses$1 = (slideEl, condition, className) => {
            if (condition && !slideEl.classList.contains(className)) slideEl.classList.add(className); else if (!condition && slideEl.classList.contains(className)) slideEl.classList.remove(className);
        };
        function updateSlidesProgress(translate) {
            if (translate === void 0) translate = this && this.translate || 0;
            const swiper = this;
            const params = swiper.params;
            const {slides, rtlTranslate: rtl, snapGrid} = swiper;
            if (slides.length === 0) return;
            if (typeof slides[0].swiperSlideOffset === "undefined") swiper.updateSlidesOffset();
            let offsetCenter = -translate;
            if (rtl) offsetCenter = translate;
            swiper.visibleSlidesIndexes = [];
            swiper.visibleSlides = [];
            let spaceBetween = params.spaceBetween;
            if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper.size; else if (typeof spaceBetween === "string") spaceBetween = parseFloat(spaceBetween);
            for (let i = 0; i < slides.length; i += 1) {
                const slide = slides[i];
                let slideOffset = slide.swiperSlideOffset;
                if (params.cssMode && params.centeredSlides) slideOffset -= slides[0].swiperSlideOffset;
                const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
                const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
                const slideBefore = -(offsetCenter - slideOffset);
                const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
                const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];
                const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
                if (isVisible) {
                    swiper.visibleSlides.push(slide);
                    swiper.visibleSlidesIndexes.push(i);
                }
                toggleSlideClasses$1(slide, isVisible, params.slideVisibleClass);
                toggleSlideClasses$1(slide, isFullyVisible, params.slideFullyVisibleClass);
                slide.progress = rtl ? -slideProgress : slideProgress;
                slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
            }
        }
        function updateProgress(translate) {
            const swiper = this;
            if (typeof translate === "undefined") {
                const multiplier = swiper.rtlTranslate ? -1 : 1;
                translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
            }
            const params = swiper.params;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            let {progress, isBeginning, isEnd, progressLoop} = swiper;
            const wasBeginning = isBeginning;
            const wasEnd = isEnd;
            if (translatesDiff === 0) {
                progress = 0;
                isBeginning = true;
                isEnd = true;
            } else {
                progress = (translate - swiper.minTranslate()) / translatesDiff;
                const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;
                const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;
                isBeginning = isBeginningRounded || progress <= 0;
                isEnd = isEndRounded || progress >= 1;
                if (isBeginningRounded) progress = 0;
                if (isEndRounded) progress = 1;
            }
            if (params.loop) {
                const firstSlideIndex = swiper.getSlideIndexByData(0);
                const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
                const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
                const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
                const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
                const translateAbs = Math.abs(translate);
                if (translateAbs >= firstSlideTranslate) progressLoop = (translateAbs - firstSlideTranslate) / translateMax; else progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
                if (progressLoop > 1) progressLoop -= 1;
            }
            Object.assign(swiper, {
                progress,
                progressLoop,
                isBeginning,
                isEnd
            });
            if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
            if (isBeginning && !wasBeginning) swiper.emit("reachBeginning toEdge");
            if (isEnd && !wasEnd) swiper.emit("reachEnd toEdge");
            if (wasBeginning && !isBeginning || wasEnd && !isEnd) swiper.emit("fromEdge");
            swiper.emit("progress", progress);
        }
        const toggleSlideClasses = (slideEl, condition, className) => {
            if (condition && !slideEl.classList.contains(className)) slideEl.classList.add(className); else if (!condition && slideEl.classList.contains(className)) slideEl.classList.remove(className);
        };
        function updateSlidesClasses() {
            const swiper = this;
            const {slides, params, slidesEl, activeIndex} = swiper;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
            const getFilteredSlide = selector => utils_elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
            let activeSlide;
            let prevSlide;
            let nextSlide;
            if (isVirtual) if (params.loop) {
                let slideIndex = activeIndex - swiper.virtual.slidesBefore;
                if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
                if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
                activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
            } else activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`); else if (gridEnabled) {
                activeSlide = slides.find(slideEl => slideEl.column === activeIndex);
                nextSlide = slides.find(slideEl => slideEl.column === activeIndex + 1);
                prevSlide = slides.find(slideEl => slideEl.column === activeIndex - 1);
            } else activeSlide = slides[activeIndex];
            if (activeSlide) if (!gridEnabled) {
                nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
                if (params.loop && !nextSlide) nextSlide = slides[0];
                prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
                if (params.loop && !prevSlide === 0) prevSlide = slides[slides.length - 1];
            }
            slides.forEach(slideEl => {
                toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);
                toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);
                toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);
            });
            swiper.emitSlidesClasses();
        }
        const processLazyPreloader = (swiper, imageEl) => {
            if (!swiper || swiper.destroyed || !swiper.params) return;
            const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
            const slideEl = imageEl.closest(slideSelector());
            if (slideEl) {
                let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
                if (!lazyEl && swiper.isElement) if (slideEl.shadowRoot) lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`); else requestAnimationFrame(() => {
                    if (slideEl.shadowRoot) {
                        lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
                        if (lazyEl) lazyEl.remove();
                    }
                });
                if (lazyEl) lazyEl.remove();
            }
        };
        const unlazy = (swiper, index) => {
            if (!swiper.slides[index]) return;
            const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
            if (imageEl) imageEl.removeAttribute("loading");
        };
        const preload = swiper => {
            if (!swiper || swiper.destroyed || !swiper.params) return;
            let amount = swiper.params.lazyPreloadPrevNext;
            const len = swiper.slides.length;
            if (!len || !amount || amount < 0) return;
            amount = Math.min(amount, len);
            const slidesPerView = swiper.params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
            const activeIndex = swiper.activeIndex;
            if (swiper.params.grid && swiper.params.grid.rows > 1) {
                const activeColumn = activeIndex;
                const preloadColumns = [ activeColumn - amount ];
                preloadColumns.push(...Array.from({
                    length: amount
                }).map((_, i) => activeColumn + slidesPerView + i));
                swiper.slides.forEach((slideEl, i) => {
                    if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);
                });
                return;
            }
            const slideIndexLastInView = activeIndex + slidesPerView - 1;
            if (swiper.params.rewind || swiper.params.loop) for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
                const realIndex = (i % len + len) % len;
                if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);
            } else for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) unlazy(swiper, i);
        };
        function getActiveIndexByTranslate(swiper) {
            const {slidesGrid, params} = swiper;
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            let activeIndex;
            for (let i = 0; i < slidesGrid.length; i += 1) if (typeof slidesGrid[i + 1] !== "undefined") {
                if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) activeIndex = i; else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) activeIndex = i + 1;
            } else if (translate >= slidesGrid[i]) activeIndex = i;
            if (params.normalizeSlideIndex) if (activeIndex < 0 || typeof activeIndex === "undefined") activeIndex = 0;
            return activeIndex;
        }
        function updateActiveIndex(newActiveIndex) {
            const swiper = this;
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            const {snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex} = swiper;
            let activeIndex = newActiveIndex;
            let snapIndex;
            const getVirtualRealIndex = aIndex => {
                let realIndex = aIndex - swiper.virtual.slidesBefore;
                if (realIndex < 0) realIndex = swiper.virtual.slides.length + realIndex;
                if (realIndex >= swiper.virtual.slides.length) realIndex -= swiper.virtual.slides.length;
                return realIndex;
            };
            if (typeof activeIndex === "undefined") activeIndex = getActiveIndexByTranslate(swiper);
            if (snapGrid.indexOf(translate) >= 0) snapIndex = snapGrid.indexOf(translate); else {
                const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
                snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
            }
            if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
            if (activeIndex === previousIndex && !swiper.params.loop) {
                if (snapIndex !== previousSnapIndex) {
                    swiper.snapIndex = snapIndex;
                    swiper.emit("snapIndexChange");
                }
                return;
            }
            if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
                swiper.realIndex = getVirtualRealIndex(activeIndex);
                return;
            }
            const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
            let realIndex;
            if (swiper.virtual && params.virtual.enabled && params.loop) realIndex = getVirtualRealIndex(activeIndex); else if (gridEnabled) {
                const firstSlideInColumn = swiper.slides.find(slideEl => slideEl.column === activeIndex);
                let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute("data-swiper-slide-index"), 10);
                if (Number.isNaN(activeSlideIndex)) activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);
                realIndex = Math.floor(activeSlideIndex / params.grid.rows);
            } else if (swiper.slides[activeIndex]) {
                const slideIndex = swiper.slides[activeIndex].getAttribute("data-swiper-slide-index");
                if (slideIndex) realIndex = parseInt(slideIndex, 10); else realIndex = activeIndex;
            } else realIndex = activeIndex;
            Object.assign(swiper, {
                previousSnapIndex,
                snapIndex,
                previousRealIndex,
                realIndex,
                previousIndex,
                activeIndex
            });
            if (swiper.initialized) preload(swiper);
            swiper.emit("activeIndexChange");
            swiper.emit("snapIndexChange");
            if (swiper.initialized || swiper.params.runCallbacksOnInit) {
                if (previousRealIndex !== realIndex) swiper.emit("realIndexChange");
                swiper.emit("slideChange");
            }
        }
        function updateClickedSlide(el, path) {
            const swiper = this;
            const params = swiper.params;
            let slide = el.closest(`.${params.slideClass}, swiper-slide`);
            if (!slide && swiper.isElement && path && path.length > 1 && path.includes(el)) [ ...path.slice(path.indexOf(el) + 1, path.length) ].forEach(pathEl => {
                if (!slide && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) slide = pathEl;
            });
            let slideFound = false;
            let slideIndex;
            if (slide) for (let i = 0; i < swiper.slides.length; i += 1) if (swiper.slides[i] === slide) {
                slideFound = true;
                slideIndex = i;
                break;
            }
            if (slide && slideFound) {
                swiper.clickedSlide = slide;
                if (swiper.virtual && swiper.params.virtual.enabled) swiper.clickedIndex = parseInt(slide.getAttribute("data-swiper-slide-index"), 10); else swiper.clickedIndex = slideIndex;
            } else {
                swiper.clickedSlide = void 0;
                swiper.clickedIndex = void 0;
                return;
            }
            if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) swiper.slideToClickedSlide();
        }
        var update = {
            updateSize,
            updateSlides,
            updateAutoHeight,
            updateSlidesOffset,
            updateSlidesProgress,
            updateProgress,
            updateSlidesClasses,
            updateActiveIndex,
            updateClickedSlide
        };
        function getSwiperTranslate(axis) {
            if (axis === void 0) axis = this.isHorizontal() ? "x" : "y";
            const swiper = this;
            const {params, rtlTranslate: rtl, translate, wrapperEl} = swiper;
            if (params.virtualTranslate) return rtl ? -translate : translate;
            if (params.cssMode) return translate;
            let currentTranslate = utils_getTranslate(wrapperEl, axis);
            currentTranslate += swiper.cssOverflowAdjustment();
            if (rtl) currentTranslate = -currentTranslate;
            return currentTranslate || 0;
        }
        function setTranslate(translate, byController) {
            const swiper = this;
            const {rtlTranslate: rtl, params, wrapperEl, progress} = swiper;
            let x = 0;
            let y = 0;
            const z = 0;
            if (swiper.isHorizontal()) x = rtl ? -translate : translate; else y = translate;
            if (params.roundLengths) {
                x = Math.floor(x);
                y = Math.floor(y);
            }
            swiper.previousTranslate = swiper.translate;
            swiper.translate = swiper.isHorizontal() ? x : y;
            if (params.cssMode) wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x : -y; else if (!params.virtualTranslate) {
                if (swiper.isHorizontal()) x -= swiper.cssOverflowAdjustment(); else y -= swiper.cssOverflowAdjustment();
                wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
            }
            let newProgress;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            if (translatesDiff === 0) newProgress = 0; else newProgress = (translate - swiper.minTranslate()) / translatesDiff;
            if (newProgress !== progress) swiper.updateProgress(translate);
            swiper.emit("setTranslate", swiper.translate, byController);
        }
        function minTranslate() {
            return -this.snapGrid[0];
        }
        function maxTranslate() {
            return -this.snapGrid[this.snapGrid.length - 1];
        }
        function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
            if (translate === void 0) translate = 0;
            if (speed === void 0) speed = this.params.speed;
            if (runCallbacks === void 0) runCallbacks = true;
            if (translateBounds === void 0) translateBounds = true;
            const swiper = this;
            const {params, wrapperEl} = swiper;
            if (swiper.animating && params.preventInteractionOnTransition) return false;
            const minTranslate = swiper.minTranslate();
            const maxTranslate = swiper.maxTranslate();
            let newTranslate;
            if (translateBounds && translate > minTranslate) newTranslate = minTranslate; else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate; else newTranslate = translate;
            swiper.updateProgress(newTranslate);
            if (params.cssMode) {
                const isH = swiper.isHorizontal();
                if (speed === 0) wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate; else {
                    if (!swiper.support.smoothScroll) {
                        animateCSSModeScroll({
                            swiper,
                            targetPosition: -newTranslate,
                            side: isH ? "left" : "top"
                        });
                        return true;
                    }
                    wrapperEl.scrollTo({
                        [isH ? "left" : "top"]: -newTranslate,
                        behavior: "smooth"
                    });
                }
                return true;
            }
            if (speed === 0) {
                swiper.setTransition(0);
                swiper.setTranslate(newTranslate);
                if (runCallbacks) {
                    swiper.emit("beforeTransitionStart", speed, internal);
                    swiper.emit("transitionEnd");
                }
            } else {
                swiper.setTransition(speed);
                swiper.setTranslate(newTranslate);
                if (runCallbacks) {
                    swiper.emit("beforeTransitionStart", speed, internal);
                    swiper.emit("transitionStart");
                }
                if (!swiper.animating) {
                    swiper.animating = true;
                    if (!swiper.onTranslateToWrapperTransitionEnd) swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
                        if (!swiper || swiper.destroyed) return;
                        if (e.target !== this) return;
                        swiper.wrapperEl.removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
                        swiper.onTranslateToWrapperTransitionEnd = null;
                        delete swiper.onTranslateToWrapperTransitionEnd;
                        swiper.animating = false;
                        if (runCallbacks) swiper.emit("transitionEnd");
                    };
                    swiper.wrapperEl.addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
                }
            }
            return true;
        }
        var translate = {
            getTranslate: getSwiperTranslate,
            setTranslate,
            minTranslate,
            maxTranslate,
            translateTo
        };
        function setTransition(duration, byController) {
            const swiper = this;
            if (!swiper.params.cssMode) {
                swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
                swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : "";
            }
            swiper.emit("setTransition", duration, byController);
        }
        function transitionEmit(_ref) {
            let {swiper, runCallbacks, direction, step} = _ref;
            const {activeIndex, previousIndex} = swiper;
            let dir = direction;
            if (!dir) if (activeIndex > previousIndex) dir = "next"; else if (activeIndex < previousIndex) dir = "prev"; else dir = "reset";
            swiper.emit(`transition${step}`);
            if (runCallbacks && dir === "reset") swiper.emit(`slideResetTransition${step}`); else if (runCallbacks && activeIndex !== previousIndex) {
                swiper.emit(`slideChangeTransition${step}`);
                if (dir === "next") swiper.emit(`slideNextTransition${step}`); else swiper.emit(`slidePrevTransition${step}`);
            }
        }
        function transitionStart(runCallbacks, direction) {
            if (runCallbacks === void 0) runCallbacks = true;
            const swiper = this;
            const {params} = swiper;
            if (params.cssMode) return;
            if (params.autoHeight) swiper.updateAutoHeight();
            transitionEmit({
                swiper,
                runCallbacks,
                direction,
                step: "Start"
            });
        }
        function transitionEnd(runCallbacks, direction) {
            if (runCallbacks === void 0) runCallbacks = true;
            const swiper = this;
            const {params} = swiper;
            swiper.animating = false;
            if (params.cssMode) return;
            swiper.setTransition(0);
            transitionEmit({
                swiper,
                runCallbacks,
                direction,
                step: "End"
            });
        }
        var transition = {
            setTransition,
            transitionStart,
            transitionEnd
        };
        function slideTo(index, speed, runCallbacks, internal, initial) {
            if (index === void 0) index = 0;
            if (runCallbacks === void 0) runCallbacks = true;
            if (typeof index === "string") index = parseInt(index, 10);
            const swiper = this;
            let slideIndex = index;
            if (slideIndex < 0) slideIndex = 0;
            const {params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl, enabled} = swiper;
            if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) return false;
            if (typeof speed === "undefined") speed = swiper.params.speed;
            const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
            let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
            if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
            const translate = -snapGrid[snapIndex];
            if (params.normalizeSlideIndex) for (let i = 0; i < slidesGrid.length; i += 1) {
                const normalizedTranslate = -Math.floor(translate * 100);
                const normalizedGrid = Math.floor(slidesGrid[i] * 100);
                const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
                if (typeof slidesGrid[i + 1] !== "undefined") {
                    if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) slideIndex = i; else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) slideIndex = i + 1;
                } else if (normalizedTranslate >= normalizedGrid) slideIndex = i;
            }
            if (swiper.initialized && slideIndex !== activeIndex) {
                if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) return false;
                if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) if ((activeIndex || 0) !== slideIndex) return false;
            }
            if (slideIndex !== (previousIndex || 0) && runCallbacks) swiper.emit("beforeSlideChangeStart");
            swiper.updateProgress(translate);
            let direction;
            if (slideIndex > activeIndex) direction = "next"; else if (slideIndex < activeIndex) direction = "prev"; else direction = "reset";
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            const isInitialVirtual = isVirtual && initial;
            if (!isInitialVirtual && (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate)) {
                swiper.updateActiveIndex(slideIndex);
                if (params.autoHeight) swiper.updateAutoHeight();
                swiper.updateSlidesClasses();
                if (params.effect !== "slide") swiper.setTranslate(translate);
                if (direction !== "reset") {
                    swiper.transitionStart(runCallbacks, direction);
                    swiper.transitionEnd(runCallbacks, direction);
                }
                return false;
            }
            if (params.cssMode) {
                const isH = swiper.isHorizontal();
                const t = rtl ? translate : -translate;
                if (speed === 0) {
                    if (isVirtual) {
                        swiper.wrapperEl.style.scrollSnapType = "none";
                        swiper._immediateVirtual = true;
                    }
                    if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
                        swiper._cssModeVirtualInitialSet = true;
                        requestAnimationFrame(() => {
                            wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
                        });
                    } else wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
                    if (isVirtual) requestAnimationFrame(() => {
                        swiper.wrapperEl.style.scrollSnapType = "";
                        swiper._immediateVirtual = false;
                    });
                } else {
                    if (!swiper.support.smoothScroll) {
                        animateCSSModeScroll({
                            swiper,
                            targetPosition: t,
                            side: isH ? "left" : "top"
                        });
                        return true;
                    }
                    wrapperEl.scrollTo({
                        [isH ? "left" : "top"]: t,
                        behavior: "smooth"
                    });
                }
                return true;
            }
            const browser = getBrowser();
            const isSafari = browser.isSafari;
            if (isVirtual && !initial && isSafari && swiper.isElement) swiper.virtual.update(false, false, slideIndex);
            swiper.setTransition(speed);
            swiper.setTranslate(translate);
            swiper.updateActiveIndex(slideIndex);
            swiper.updateSlidesClasses();
            swiper.emit("beforeTransitionStart", speed, internal);
            swiper.transitionStart(runCallbacks, direction);
            if (speed === 0) swiper.transitionEnd(runCallbacks, direction); else if (!swiper.animating) {
                swiper.animating = true;
                if (!swiper.onSlideToWrapperTransitionEnd) swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
                    if (!swiper || swiper.destroyed) return;
                    if (e.target !== this) return;
                    swiper.wrapperEl.removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
                    swiper.onSlideToWrapperTransitionEnd = null;
                    delete swiper.onSlideToWrapperTransitionEnd;
                    swiper.transitionEnd(runCallbacks, direction);
                };
                swiper.wrapperEl.addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
            }
            return true;
        }
        function slideToLoop(index, speed, runCallbacks, internal) {
            if (index === void 0) index = 0;
            if (runCallbacks === void 0) runCallbacks = true;
            if (typeof index === "string") {
                const indexAsNumber = parseInt(index, 10);
                index = indexAsNumber;
            }
            const swiper = this;
            if (swiper.destroyed) return;
            if (typeof speed === "undefined") speed = swiper.params.speed;
            const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
            let newIndex = index;
            if (swiper.params.loop) if (swiper.virtual && swiper.params.virtual.enabled) newIndex += swiper.virtual.slidesBefore; else {
                let targetSlideIndex;
                if (gridEnabled) {
                    const slideIndex = newIndex * swiper.params.grid.rows;
                    targetSlideIndex = swiper.slides.find(slideEl => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex).column;
                } else targetSlideIndex = swiper.getSlideIndexByData(newIndex);
                const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;
                const {centeredSlides} = swiper.params;
                let slidesPerView = swiper.params.slidesPerView;
                if (slidesPerView === "auto") slidesPerView = swiper.slidesPerViewDynamic(); else {
                    slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));
                    if (centeredSlides && slidesPerView % 2 === 0) slidesPerView += 1;
                }
                let needLoopFix = cols - targetSlideIndex < slidesPerView;
                if (centeredSlides) needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);
                if (internal && centeredSlides && swiper.params.slidesPerView !== "auto" && !gridEnabled) needLoopFix = false;
                if (needLoopFix) {
                    const direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? "prev" : "next" : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? "next" : "prev";
                    swiper.loopFix({
                        direction,
                        slideTo: true,
                        activeSlideIndex: direction === "next" ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,
                        slideRealIndex: direction === "next" ? swiper.realIndex : void 0
                    });
                }
                if (gridEnabled) {
                    const slideIndex = newIndex * swiper.params.grid.rows;
                    newIndex = swiper.slides.find(slideEl => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex).column;
                } else newIndex = swiper.getSlideIndexByData(newIndex);
            }
            requestAnimationFrame(() => {
                swiper.slideTo(newIndex, speed, runCallbacks, internal);
            });
            return swiper;
        }
        function slideNext(speed, runCallbacks, internal) {
            if (runCallbacks === void 0) runCallbacks = true;
            const swiper = this;
            const {enabled, params, animating} = swiper;
            if (!enabled || swiper.destroyed) return swiper;
            if (typeof speed === "undefined") speed = swiper.params.speed;
            let perGroup = params.slidesPerGroup;
            if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
            const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            if (params.loop) {
                if (animating && !isVirtual && params.loopPreventsSliding) return false;
                swiper.loopFix({
                    direction: "next"
                });
                swiper._clientLeft = swiper.wrapperEl.clientLeft;
                if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {
                    requestAnimationFrame(() => {
                        swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
                    });
                    return true;
                }
            }
            if (params.rewind && swiper.isEnd) return swiper.slideTo(0, speed, runCallbacks, internal);
            return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
        }
        function slidePrev(speed, runCallbacks, internal) {
            if (runCallbacks === void 0) runCallbacks = true;
            const swiper = this;
            const {params, snapGrid, slidesGrid, rtlTranslate, enabled, animating} = swiper;
            if (!enabled || swiper.destroyed) return swiper;
            if (typeof speed === "undefined") speed = swiper.params.speed;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            if (params.loop) {
                if (animating && !isVirtual && params.loopPreventsSliding) return false;
                swiper.loopFix({
                    direction: "prev"
                });
                swiper._clientLeft = swiper.wrapperEl.clientLeft;
            }
            const translate = rtlTranslate ? swiper.translate : -swiper.translate;
            function normalize(val) {
                if (val < 0) return -Math.floor(Math.abs(val));
                return Math.floor(val);
            }
            const normalizedTranslate = normalize(translate);
            const normalizedSnapGrid = snapGrid.map(val => normalize(val));
            const isFreeMode = params.freeMode && params.freeMode.enabled;
            let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
            if (typeof prevSnap === "undefined" && (params.cssMode || isFreeMode)) {
                let prevSnapIndex;
                snapGrid.forEach((snap, snapIndex) => {
                    if (normalizedTranslate >= snap) prevSnapIndex = snapIndex;
                });
                if (typeof prevSnapIndex !== "undefined") prevSnap = isFreeMode ? snapGrid[prevSnapIndex] : snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
            }
            let prevIndex = 0;
            if (typeof prevSnap !== "undefined") {
                prevIndex = slidesGrid.indexOf(prevSnap);
                if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
                if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
                    prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
                    prevIndex = Math.max(prevIndex, 0);
                }
            }
            if (params.rewind && swiper.isBeginning) {
                const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
                return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
            } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {
                requestAnimationFrame(() => {
                    swiper.slideTo(prevIndex, speed, runCallbacks, internal);
                });
                return true;
            }
            return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
        }
        function slideReset(speed, runCallbacks, internal) {
            if (runCallbacks === void 0) runCallbacks = true;
            const swiper = this;
            if (swiper.destroyed) return;
            if (typeof speed === "undefined") speed = swiper.params.speed;
            return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
        }
        function slideToClosest(speed, runCallbacks, internal, threshold) {
            if (runCallbacks === void 0) runCallbacks = true;
            if (threshold === void 0) threshold = .5;
            const swiper = this;
            if (swiper.destroyed) return;
            if (typeof speed === "undefined") speed = swiper.params.speed;
            let index = swiper.activeIndex;
            const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
            const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            if (translate >= swiper.snapGrid[snapIndex]) {
                const currentSnap = swiper.snapGrid[snapIndex];
                const nextSnap = swiper.snapGrid[snapIndex + 1];
                if (translate - currentSnap > (nextSnap - currentSnap) * threshold) index += swiper.params.slidesPerGroup;
            } else {
                const prevSnap = swiper.snapGrid[snapIndex - 1];
                const currentSnap = swiper.snapGrid[snapIndex];
                if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) index -= swiper.params.slidesPerGroup;
            }
            index = Math.max(index, 0);
            index = Math.min(index, swiper.slidesGrid.length - 1);
            return swiper.slideTo(index, speed, runCallbacks, internal);
        }
        function slideToClickedSlide() {
            const swiper = this;
            if (swiper.destroyed) return;
            const {params, slidesEl} = swiper;
            const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
            let slideToIndex = swiper.getSlideIndexWhenGrid(swiper.clickedIndex);
            let realIndex;
            const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
            const isGrid = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
            if (params.loop) {
                if (swiper.animating) return;
                realIndex = parseInt(swiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10);
                if (params.centeredSlides) swiper.slideToLoop(realIndex); else if (slideToIndex > (isGrid ? (swiper.slides.length - slidesPerView) / 2 - (swiper.params.grid.rows - 1) : swiper.slides.length - slidesPerView)) {
                    swiper.loopFix();
                    slideToIndex = swiper.getSlideIndex(utils_elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
                    utils_nextTick(() => {
                        swiper.slideTo(slideToIndex);
                    });
                } else swiper.slideTo(slideToIndex);
            } else swiper.slideTo(slideToIndex);
        }
        var slide = {
            slideTo,
            slideToLoop,
            slideNext,
            slidePrev,
            slideReset,
            slideToClosest,
            slideToClickedSlide
        };
        function loopCreate(slideRealIndex, initial) {
            const swiper = this;
            const {params, slidesEl} = swiper;
            if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
            const initSlides = () => {
                const slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
                slides.forEach((el, index) => {
                    el.setAttribute("data-swiper-slide-index", index);
                });
            };
            const clearBlankSlides = () => {
                const slides = utils_elementChildren(slidesEl, `.${params.slideBlankClass}`);
                slides.forEach(el => {
                    el.remove();
                });
                if (slides.length > 0) {
                    swiper.recalcSlides();
                    swiper.updateSlides();
                }
            };
            const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
            if (params.loopAddBlankSlides && (params.slidesPerGroup > 1 || gridEnabled)) clearBlankSlides();
            const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);
            const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;
            const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;
            const addBlankSlides = amountOfSlides => {
                for (let i = 0; i < amountOfSlides; i += 1) {
                    const slideEl = swiper.isElement ? utils_createElement("swiper-slide", [ params.slideBlankClass ]) : utils_createElement("div", [ params.slideClass, params.slideBlankClass ]);
                    swiper.slidesEl.append(slideEl);
                }
            };
            if (shouldFillGroup) {
                if (params.loopAddBlankSlides) {
                    const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;
                    addBlankSlides(slidesToAdd);
                    swiper.recalcSlides();
                    swiper.updateSlides();
                } else showWarning("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
                initSlides();
            } else if (shouldFillGrid) {
                if (params.loopAddBlankSlides) {
                    const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;
                    addBlankSlides(slidesToAdd);
                    swiper.recalcSlides();
                    swiper.updateSlides();
                } else showWarning("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
                initSlides();
            } else initSlides();
            swiper.loopFix({
                slideRealIndex,
                direction: params.centeredSlides ? void 0 : "next",
                initial
            });
        }
        function loopFix(_temp) {
            let {slideRealIndex, slideTo = true, direction, setTranslate, activeSlideIndex, initial, byController, byMousewheel} = _temp === void 0 ? {} : _temp;
            const swiper = this;
            if (!swiper.params.loop) return;
            swiper.emit("beforeLoopFix");
            const {slides, allowSlidePrev, allowSlideNext, slidesEl, params} = swiper;
            const {centeredSlides, initialSlide} = params;
            swiper.allowSlidePrev = true;
            swiper.allowSlideNext = true;
            if (swiper.virtual && params.virtual.enabled) {
                if (slideTo) if (!params.centeredSlides && swiper.snapIndex === 0) swiper.slideTo(swiper.virtual.slides.length, 0, false, true); else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true); else if (swiper.snapIndex === swiper.snapGrid.length - 1) swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
                swiper.allowSlidePrev = allowSlidePrev;
                swiper.allowSlideNext = allowSlideNext;
                swiper.emit("loopFix");
                return;
            }
            let slidesPerView = params.slidesPerView;
            if (slidesPerView === "auto") slidesPerView = swiper.slidesPerViewDynamic(); else {
                slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));
                if (centeredSlides && slidesPerView % 2 === 0) slidesPerView += 1;
            }
            const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;
            let loopedSlides = centeredSlides ? Math.max(slidesPerGroup, Math.ceil(slidesPerView / 2)) : slidesPerGroup;
            if (loopedSlides % slidesPerGroup !== 0) loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;
            loopedSlides += params.loopAdditionalSlides;
            swiper.loopedSlides = loopedSlides;
            const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
            if (slides.length < slidesPerView + loopedSlides || swiper.params.effect === "cards" && slides.length < slidesPerView + loopedSlides * 2) showWarning("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled or not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters"); else if (gridEnabled && params.grid.fill === "row") showWarning("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
            const prependSlidesIndexes = [];
            const appendSlidesIndexes = [];
            const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;
            const isInitialOverflow = initial && cols - initialSlide < slidesPerView && !centeredSlides;
            let activeIndex = isInitialOverflow ? initialSlide : swiper.activeIndex;
            if (typeof activeSlideIndex === "undefined") activeSlideIndex = swiper.getSlideIndex(slides.find(el => el.classList.contains(params.slideActiveClass))); else activeIndex = activeSlideIndex;
            const isNext = direction === "next" || !direction;
            const isPrev = direction === "prev" || !direction;
            let slidesPrepended = 0;
            let slidesAppended = 0;
            const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;
            const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate === "undefined" ? -slidesPerView / 2 + .5 : 0);
            if (activeColIndexWithShift < loopedSlides) {
                slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);
                for (let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1) {
                    const index = i - Math.floor(i / cols) * cols;
                    if (gridEnabled) {
                        const colIndexToPrepend = cols - index - 1;
                        for (let i = slides.length - 1; i >= 0; i -= 1) if (slides[i].column === colIndexToPrepend) prependSlidesIndexes.push(i);
                    } else prependSlidesIndexes.push(cols - index - 1);
                }
            } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {
                slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);
                if (isInitialOverflow) slidesAppended = Math.max(slidesAppended, slidesPerView - cols + initialSlide + 1);
                for (let i = 0; i < slidesAppended; i += 1) {
                    const index = i - Math.floor(i / cols) * cols;
                    if (gridEnabled) slides.forEach((slide, slideIndex) => {
                        if (slide.column === index) appendSlidesIndexes.push(slideIndex);
                    }); else appendSlidesIndexes.push(index);
                }
            }
            swiper.__preventObserver__ = true;
            requestAnimationFrame(() => {
                swiper.__preventObserver__ = false;
            });
            if (swiper.params.effect === "cards" && slides.length < slidesPerView + loopedSlides * 2) {
                if (appendSlidesIndexes.includes(activeSlideIndex)) appendSlidesIndexes.splice(appendSlidesIndexes.indexOf(activeSlideIndex), 1);
                if (prependSlidesIndexes.includes(activeSlideIndex)) prependSlidesIndexes.splice(prependSlidesIndexes.indexOf(activeSlideIndex), 1);
            }
            if (isPrev) prependSlidesIndexes.forEach(index => {
                slides[index].swiperLoopMoveDOM = true;
                slidesEl.prepend(slides[index]);
                slides[index].swiperLoopMoveDOM = false;
            });
            if (isNext) appendSlidesIndexes.forEach(index => {
                slides[index].swiperLoopMoveDOM = true;
                slidesEl.append(slides[index]);
                slides[index].swiperLoopMoveDOM = false;
            });
            swiper.recalcSlides();
            if (params.slidesPerView === "auto") swiper.updateSlides(); else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) swiper.slides.forEach((slide, slideIndex) => {
                swiper.grid.updateSlide(slideIndex, slide, swiper.slides);
            });
            if (params.watchSlidesProgress) swiper.updateSlidesOffset();
            if (slideTo) if (prependSlidesIndexes.length > 0 && isPrev) {
                if (typeof slideRealIndex === "undefined") {
                    const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                    const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
                    const diff = newSlideTranslate - currentSlideTranslate;
                    if (byMousewheel) swiper.setTranslate(swiper.translate - diff); else {
                        swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);
                        if (setTranslate) {
                            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
                            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
                        }
                    }
                } else if (setTranslate) {
                    const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;
                    swiper.slideTo(swiper.activeIndex + shift, 0, false, true);
                    swiper.touchEventsData.currentTranslate = swiper.translate;
                }
            } else if (appendSlidesIndexes.length > 0 && isNext) if (typeof slideRealIndex === "undefined") {
                const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
                const diff = newSlideTranslate - currentSlideTranslate;
                if (byMousewheel) swiper.setTranslate(swiper.translate - diff); else {
                    swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
                    if (setTranslate) {
                        swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
                        swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
                    }
                }
            } else {
                const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;
                swiper.slideTo(swiper.activeIndex - shift, 0, false, true);
            }
            swiper.allowSlidePrev = allowSlidePrev;
            swiper.allowSlideNext = allowSlideNext;
            if (swiper.controller && swiper.controller.control && !byController) {
                const loopParams = {
                    slideRealIndex,
                    direction,
                    setTranslate,
                    activeSlideIndex,
                    byController: true
                };
                if (Array.isArray(swiper.controller.control)) swiper.controller.control.forEach(c => {
                    if (!c.destroyed && c.params.loop) c.loopFix({
                        ...loopParams,
                        slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo : false
                    });
                }); else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) swiper.controller.control.loopFix({
                    ...loopParams,
                    slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo : false
                });
            }
            swiper.emit("loopFix");
        }
        function loopDestroy() {
            const swiper = this;
            const {params, slidesEl} = swiper;
            if (!params.loop || !slidesEl || swiper.virtual && swiper.params.virtual.enabled) return;
            swiper.recalcSlides();
            const newSlidesOrder = [];
            swiper.slides.forEach(slideEl => {
                const index = typeof slideEl.swiperSlideIndex === "undefined" ? slideEl.getAttribute("data-swiper-slide-index") * 1 : slideEl.swiperSlideIndex;
                newSlidesOrder[index] = slideEl;
            });
            swiper.slides.forEach(slideEl => {
                slideEl.removeAttribute("data-swiper-slide-index");
            });
            newSlidesOrder.forEach(slideEl => {
                slidesEl.append(slideEl);
            });
            swiper.recalcSlides();
            swiper.slideTo(swiper.realIndex, 0);
        }
        var loop = {
            loopCreate,
            loopFix,
            loopDestroy
        };
        function setGrabCursor(moving) {
            const swiper = this;
            if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
            const el = swiper.params.touchEventsTarget === "container" ? swiper.el : swiper.wrapperEl;
            if (swiper.isElement) swiper.__preventObserver__ = true;
            el.style.cursor = "move";
            el.style.cursor = moving ? "grabbing" : "grab";
            if (swiper.isElement) requestAnimationFrame(() => {
                swiper.__preventObserver__ = false;
            });
        }
        function unsetGrabCursor() {
            const swiper = this;
            if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
            if (swiper.isElement) swiper.__preventObserver__ = true;
            swiper[swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
            if (swiper.isElement) requestAnimationFrame(() => {
                swiper.__preventObserver__ = false;
            });
        }
        var grabCursor = {
            setGrabCursor,
            unsetGrabCursor
        };
        function closestElement(selector, base) {
            if (base === void 0) base = this;
            function __closestFrom(el) {
                if (!el || el === ssr_window_esm_getDocument() || el === ssr_window_esm_getWindow()) return null;
                if (el.assignedSlot) el = el.assignedSlot;
                const found = el.closest(selector);
                if (!found && !el.getRootNode) return null;
                return found || __closestFrom(el.getRootNode().host);
            }
            return __closestFrom(base);
        }
        function preventEdgeSwipe(swiper, event, startX) {
            const window = ssr_window_esm_getWindow();
            const {params} = swiper;
            const edgeSwipeDetection = params.edgeSwipeDetection;
            const edgeSwipeThreshold = params.edgeSwipeThreshold;
            if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
                if (edgeSwipeDetection === "prevent") {
                    event.preventDefault();
                    return true;
                }
                return false;
            }
            return true;
        }
        function onTouchStart(event) {
            const swiper = this;
            const document = ssr_window_esm_getDocument();
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            const data = swiper.touchEventsData;
            if (e.type === "pointerdown") {
                if (data.pointerId !== null && data.pointerId !== e.pointerId) return;
                data.pointerId = e.pointerId;
            } else if (e.type === "touchstart" && e.targetTouches.length === 1) data.touchId = e.targetTouches[0].identifier;
            if (e.type === "touchstart") {
                preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);
                return;
            }
            const {params, touches, enabled} = swiper;
            if (!enabled) return;
            if (!params.simulateTouch && e.pointerType === "mouse") return;
            if (swiper.animating && params.preventInteractionOnTransition) return;
            if (!swiper.animating && params.cssMode && params.loop) swiper.loopFix();
            let targetEl = e.target;
            if (params.touchEventsTarget === "wrapper") if (!elementIsChildOf(targetEl, swiper.wrapperEl)) return;
            if ("which" in e && e.which === 3) return;
            if ("button" in e && e.button > 0) return;
            if (data.isTouched && data.isMoved) return;
            const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
            const eventPath = e.composedPath ? e.composedPath() : e.path;
            if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) targetEl = eventPath[0];
            const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
            const isTargetShadow = !!(e.target && e.target.shadowRoot);
            if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
                swiper.allowClick = true;
                return;
            }
            if (params.swipeHandler) if (!targetEl.closest(params.swipeHandler)) return;
            touches.currentX = e.pageX;
            touches.currentY = e.pageY;
            const startX = touches.currentX;
            const startY = touches.currentY;
            if (!preventEdgeSwipe(swiper, e, startX)) return;
            Object.assign(data, {
                isTouched: true,
                isMoved: false,
                allowTouchCallbacks: true,
                isScrolling: void 0,
                startMoving: void 0
            });
            touches.startX = startX;
            touches.startY = startY;
            data.touchStartTime = now();
            swiper.allowClick = true;
            swiper.updateSize();
            swiper.swipeDirection = void 0;
            if (params.threshold > 0) data.allowThresholdMove = false;
            let preventDefault = true;
            if (targetEl.matches(data.focusableElements)) {
                preventDefault = false;
                if (targetEl.nodeName === "SELECT") data.isTouched = false;
            }
            if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl && (e.pointerType === "mouse" || e.pointerType !== "mouse" && !targetEl.matches(data.focusableElements))) document.activeElement.blur();
            const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
            if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) e.preventDefault();
            if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) swiper.freeMode.onTouchStart();
            swiper.emit("touchStart", e);
        }
        function onTouchMove(event) {
            const document = ssr_window_esm_getDocument();
            const swiper = this;
            const data = swiper.touchEventsData;
            const {params, touches, rtlTranslate: rtl, enabled} = swiper;
            if (!enabled) return;
            if (!params.simulateTouch && event.pointerType === "mouse") return;
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            if (e.type === "pointermove") {
                if (data.touchId !== null) return;
                const id = e.pointerId;
                if (id !== data.pointerId) return;
            }
            let targetTouch;
            if (e.type === "touchmove") {
                targetTouch = [ ...e.changedTouches ].find(t => t.identifier === data.touchId);
                if (!targetTouch || targetTouch.identifier !== data.touchId) return;
            } else targetTouch = e;
            if (!data.isTouched) {
                if (data.startMoving && data.isScrolling) swiper.emit("touchMoveOpposite", e);
                return;
            }
            const pageX = targetTouch.pageX;
            const pageY = targetTouch.pageY;
            if (e.preventedByNestedSwiper) {
                touches.startX = pageX;
                touches.startY = pageY;
                return;
            }
            if (!swiper.allowTouchMove) {
                if (!e.target.matches(data.focusableElements)) swiper.allowClick = false;
                if (data.isTouched) {
                    Object.assign(touches, {
                        startX: pageX,
                        startY: pageY,
                        currentX: pageX,
                        currentY: pageY
                    });
                    data.touchStartTime = now();
                }
                return;
            }
            if (params.touchReleaseOnEdges && !params.loop) if (swiper.isVertical()) {
                if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
                    data.isTouched = false;
                    data.isMoved = false;
                    return;
                }
            } else if (rtl && (pageX > touches.startX && -swiper.translate <= swiper.maxTranslate() || pageX < touches.startX && -swiper.translate >= swiper.minTranslate())) return; else if (!rtl && (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate())) return;
            if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== e.target && e.pointerType !== "mouse") document.activeElement.blur();
            if (document.activeElement) if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {
                data.isMoved = true;
                swiper.allowClick = false;
                return;
            }
            if (data.allowTouchCallbacks) swiper.emit("touchMove", e);
            touches.previousX = touches.currentX;
            touches.previousY = touches.currentY;
            touches.currentX = pageX;
            touches.currentY = pageY;
            const diffX = touches.currentX - touches.startX;
            const diffY = touches.currentY - touches.startY;
            if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
            if (typeof data.isScrolling === "undefined") {
                let touchAngle;
                if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) data.isScrolling = false; else if (diffX * diffX + diffY * diffY >= 25) {
                    touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
                    data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
                }
            }
            if (data.isScrolling) swiper.emit("touchMoveOpposite", e);
            if (typeof data.startMoving === "undefined") if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) data.startMoving = true;
            if (data.isScrolling || e.type === "touchmove" && data.preventTouchMoveFromPointerMove) {
                data.isTouched = false;
                return;
            }
            if (!data.startMoving) return;
            swiper.allowClick = false;
            if (!params.cssMode && e.cancelable) e.preventDefault();
            if (params.touchMoveStopPropagation && !params.nested) e.stopPropagation();
            let diff = swiper.isHorizontal() ? diffX : diffY;
            let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
            if (params.oneWayMovement) {
                diff = Math.abs(diff) * (rtl ? 1 : -1);
                touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
            }
            touches.diff = diff;
            diff *= params.touchRatio;
            if (rtl) {
                diff = -diff;
                touchesDiff = -touchesDiff;
            }
            const prevTouchesDirection = swiper.touchesDirection;
            swiper.swipeDirection = diff > 0 ? "prev" : "next";
            swiper.touchesDirection = touchesDiff > 0 ? "prev" : "next";
            const isLoop = swiper.params.loop && !params.cssMode;
            const allowLoopFix = swiper.touchesDirection === "next" && swiper.allowSlideNext || swiper.touchesDirection === "prev" && swiper.allowSlidePrev;
            if (!data.isMoved) {
                if (isLoop && allowLoopFix) swiper.loopFix({
                    direction: swiper.swipeDirection
                });
                data.startTranslate = swiper.getTranslate();
                swiper.setTransition(0);
                if (swiper.animating) {
                    const evt = new window.CustomEvent("transitionend", {
                        bubbles: true,
                        cancelable: true,
                        detail: {
                            bySwiperTouchMove: true
                        }
                    });
                    swiper.wrapperEl.dispatchEvent(evt);
                }
                data.allowMomentumBounce = false;
                if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) swiper.setGrabCursor(true);
                swiper.emit("sliderFirstMove", e);
            }
            let loopFixed;
            (new Date).getTime();
            if (params._loopSwapReset !== false && data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
                Object.assign(touches, {
                    startX: pageX,
                    startY: pageY,
                    currentX: pageX,
                    currentY: pageY,
                    startTranslate: data.currentTranslate
                });
                data.loopSwapReset = true;
                data.startTranslate = data.currentTranslate;
                return;
            }
            swiper.emit("sliderMove", e);
            data.isMoved = true;
            data.currentTranslate = diff + data.startTranslate;
            let disableParentSwiper = true;
            let resistanceRatio = params.resistanceRatio;
            if (params.touchReleaseOnEdges) resistanceRatio = 0;
            if (diff > 0) {
                if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] - (params.slidesPerView !== "auto" && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.activeIndex + 1] + swiper.params.spaceBetween : 0) - swiper.params.spaceBetween : swiper.minTranslate())) swiper.loopFix({
                    direction: "prev",
                    setTranslate: true,
                    activeSlideIndex: 0
                });
                if (data.currentTranslate > swiper.minTranslate()) {
                    disableParentSwiper = false;
                    if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
                }
            } else if (diff < 0) {
                if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween + (params.slidesPerView !== "auto" && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween : 0) : swiper.maxTranslate())) swiper.loopFix({
                    direction: "next",
                    setTranslate: true,
                    activeSlideIndex: swiper.slides.length - (params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
                });
                if (data.currentTranslate < swiper.maxTranslate()) {
                    disableParentSwiper = false;
                    if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
                }
            }
            if (disableParentSwiper) e.preventedByNestedSwiper = true;
            if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data.currentTranslate < data.startTranslate) data.currentTranslate = data.startTranslate;
            if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) data.currentTranslate = data.startTranslate;
            if (!swiper.allowSlidePrev && !swiper.allowSlideNext) data.currentTranslate = data.startTranslate;
            if (params.threshold > 0) if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
                if (!data.allowThresholdMove) {
                    data.allowThresholdMove = true;
                    touches.startX = touches.currentX;
                    touches.startY = touches.currentY;
                    data.currentTranslate = data.startTranslate;
                    touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                    return;
                }
            } else {
                data.currentTranslate = data.startTranslate;
                return;
            }
            if (!params.followFinger || params.cssMode) return;
            if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            if (params.freeMode && params.freeMode.enabled && swiper.freeMode) swiper.freeMode.onTouchMove();
            swiper.updateProgress(data.currentTranslate);
            swiper.setTranslate(data.currentTranslate);
        }
        function onTouchEnd(event) {
            const swiper = this;
            const data = swiper.touchEventsData;
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            let targetTouch;
            const isTouchEvent = e.type === "touchend" || e.type === "touchcancel";
            if (!isTouchEvent) {
                if (data.touchId !== null) return;
                if (e.pointerId !== data.pointerId) return;
                targetTouch = e;
            } else {
                targetTouch = [ ...e.changedTouches ].find(t => t.identifier === data.touchId);
                if (!targetTouch || targetTouch.identifier !== data.touchId) return;
            }
            if ([ "pointercancel", "pointerout", "pointerleave", "contextmenu" ].includes(e.type)) {
                const proceed = [ "pointercancel", "contextmenu" ].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);
                if (!proceed) return;
            }
            data.pointerId = null;
            data.touchId = null;
            const {params, touches, rtlTranslate: rtl, slidesGrid, enabled} = swiper;
            if (!enabled) return;
            if (!params.simulateTouch && e.pointerType === "mouse") return;
            if (data.allowTouchCallbacks) swiper.emit("touchEnd", e);
            data.allowTouchCallbacks = false;
            if (!data.isTouched) {
                if (data.isMoved && params.grabCursor) swiper.setGrabCursor(false);
                data.isMoved = false;
                data.startMoving = false;
                return;
            }
            if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) swiper.setGrabCursor(false);
            const touchEndTime = now();
            const timeDiff = touchEndTime - data.touchStartTime;
            if (swiper.allowClick) {
                const pathTree = e.path || e.composedPath && e.composedPath();
                swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);
                swiper.emit("tap click", e);
                if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) swiper.emit("doubleTap doubleClick", e);
            }
            data.lastClickTime = now();
            utils_nextTick(() => {
                if (!swiper.destroyed) swiper.allowClick = true;
            });
            if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {
                data.isTouched = false;
                data.isMoved = false;
                data.startMoving = false;
                return;
            }
            data.isTouched = false;
            data.isMoved = false;
            data.startMoving = false;
            let currentPos;
            if (params.followFinger) currentPos = rtl ? swiper.translate : -swiper.translate; else currentPos = -data.currentTranslate;
            if (params.cssMode) return;
            if (params.freeMode && params.freeMode.enabled) {
                swiper.freeMode.onTouchEnd({
                    currentPos
                });
                return;
            }
            const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;
            let stopIndex = 0;
            let groupSize = swiper.slidesSizesGrid[0];
            for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
                const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
                if (typeof slidesGrid[i + increment] !== "undefined") {
                    if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
                        stopIndex = i;
                        groupSize = slidesGrid[i + increment] - slidesGrid[i];
                    }
                } else if (swipeToLast || currentPos >= slidesGrid[i]) {
                    stopIndex = i;
                    groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
                }
            }
            let rewindFirstIndex = null;
            let rewindLastIndex = null;
            if (params.rewind) if (swiper.isBeginning) rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1; else if (swiper.isEnd) rewindFirstIndex = 0;
            const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
            const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
            if (timeDiff > params.longSwipesMs) {
                if (!params.longSwipes) {
                    swiper.slideTo(swiper.activeIndex);
                    return;
                }
                if (swiper.swipeDirection === "next") if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment); else swiper.slideTo(stopIndex);
                if (swiper.swipeDirection === "prev") if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment); else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) swiper.slideTo(rewindLastIndex); else swiper.slideTo(stopIndex);
            } else {
                if (!params.shortSwipes) {
                    swiper.slideTo(swiper.activeIndex);
                    return;
                }
                const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
                if (!isNavButtonTarget) {
                    if (swiper.swipeDirection === "next") swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
                    if (swiper.swipeDirection === "prev") swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
                } else if (e.target === swiper.navigation.nextEl) swiper.slideTo(stopIndex + increment); else swiper.slideTo(stopIndex);
            }
        }
        function onResize() {
            const swiper = this;
            const {params, el} = swiper;
            if (el && el.offsetWidth === 0) return;
            if (params.breakpoints) swiper.setBreakpoint();
            const {allowSlideNext, allowSlidePrev, snapGrid} = swiper;
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            swiper.allowSlideNext = true;
            swiper.allowSlidePrev = true;
            swiper.updateSize();
            swiper.updateSlides();
            swiper.updateSlidesClasses();
            const isVirtualLoop = isVirtual && params.loop;
            if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) swiper.slideTo(swiper.slides.length - 1, 0, false, true); else if (swiper.params.loop && !isVirtual) swiper.slideToLoop(swiper.realIndex, 0, false, true); else swiper.slideTo(swiper.activeIndex, 0, false, true);
            if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
                clearTimeout(swiper.autoplay.resizeTimeout);
                swiper.autoplay.resizeTimeout = setTimeout(() => {
                    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) swiper.autoplay.resume();
                }, 500);
            }
            swiper.allowSlidePrev = allowSlidePrev;
            swiper.allowSlideNext = allowSlideNext;
            if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();
        }
        function onClick(e) {
            const swiper = this;
            if (!swiper.enabled) return;
            if (!swiper.allowClick) {
                if (swiper.params.preventClicks) e.preventDefault();
                if (swiper.params.preventClicksPropagation && swiper.animating) {
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                }
            }
        }
        function onScroll() {
            const swiper = this;
            const {wrapperEl, rtlTranslate, enabled} = swiper;
            if (!enabled) return;
            swiper.previousTranslate = swiper.translate;
            if (swiper.isHorizontal()) swiper.translate = -wrapperEl.scrollLeft; else swiper.translate = -wrapperEl.scrollTop;
            if (swiper.translate === 0) swiper.translate = 0;
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
            let newProgress;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            if (translatesDiff === 0) newProgress = 0; else newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
            if (newProgress !== swiper.progress) swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
            swiper.emit("setTranslate", swiper.translate, false);
        }
        function onLoad(e) {
            const swiper = this;
            processLazyPreloader(swiper, e.target);
            if (swiper.params.cssMode || swiper.params.slidesPerView !== "auto" && !swiper.params.autoHeight) return;
            swiper.update();
        }
        function onDocumentTouchStart() {
            const swiper = this;
            if (swiper.documentTouchHandlerProceeded) return;
            swiper.documentTouchHandlerProceeded = true;
            if (swiper.params.touchReleaseOnEdges) swiper.el.style.touchAction = "auto";
        }
        const events = (swiper, method) => {
            const document = ssr_window_esm_getDocument();
            const {params, el, wrapperEl, device} = swiper;
            const capture = !!params.nested;
            const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
            const swiperMethod = method;
            if (!el || typeof el === "string") return;
            document[domMethod]("touchstart", swiper.onDocumentTouchStart, {
                passive: false,
                capture
            });
            el[domMethod]("touchstart", swiper.onTouchStart, {
                passive: false
            });
            el[domMethod]("pointerdown", swiper.onTouchStart, {
                passive: false
            });
            document[domMethod]("touchmove", swiper.onTouchMove, {
                passive: false,
                capture
            });
            document[domMethod]("pointermove", swiper.onTouchMove, {
                passive: false,
                capture
            });
            document[domMethod]("touchend", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointerup", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointercancel", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("touchcancel", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointerout", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointerleave", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("contextmenu", swiper.onTouchEnd, {
                passive: true
            });
            if (params.preventClicks || params.preventClicksPropagation) el[domMethod]("click", swiper.onClick, true);
            if (params.cssMode) wrapperEl[domMethod]("scroll", swiper.onScroll);
            if (params.updateOnWindowResize) swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true); else swiper[swiperMethod]("observerUpdate", onResize, true);
            el[domMethod]("load", swiper.onLoad, {
                capture: true
            });
        };
        function attachEvents() {
            const swiper = this;
            const {params} = swiper;
            swiper.onTouchStart = onTouchStart.bind(swiper);
            swiper.onTouchMove = onTouchMove.bind(swiper);
            swiper.onTouchEnd = onTouchEnd.bind(swiper);
            swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);
            if (params.cssMode) swiper.onScroll = onScroll.bind(swiper);
            swiper.onClick = onClick.bind(swiper);
            swiper.onLoad = onLoad.bind(swiper);
            events(swiper, "on");
        }
        function detachEvents() {
            const swiper = this;
            events(swiper, "off");
        }
        var events$1 = {
            attachEvents,
            detachEvents
        };
        const isGridEnabled = (swiper, params) => swiper.grid && params.grid && params.grid.rows > 1;
        function setBreakpoint() {
            const swiper = this;
            const {realIndex, initialized, params, el} = swiper;
            const breakpoints = params.breakpoints;
            if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;
            const document = ssr_window_esm_getDocument();
            const breakpointsBase = params.breakpointsBase === "window" || !params.breakpointsBase ? params.breakpointsBase : "container";
            const breakpointContainer = [ "window", "container" ].includes(params.breakpointsBase) || !params.breakpointsBase ? swiper.el : document.querySelector(params.breakpointsBase);
            const breakpoint = swiper.getBreakpoint(breakpoints, breakpointsBase, breakpointContainer);
            if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
            const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : void 0;
            const breakpointParams = breakpointOnlyParams || swiper.originalParams;
            const wasMultiRow = isGridEnabled(swiper, params);
            const isMultiRow = isGridEnabled(swiper, breakpointParams);
            const wasGrabCursor = swiper.params.grabCursor;
            const isGrabCursor = breakpointParams.grabCursor;
            const wasEnabled = params.enabled;
            if (wasMultiRow && !isMultiRow) {
                el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
                swiper.emitContainerClasses();
            } else if (!wasMultiRow && isMultiRow) {
                el.classList.add(`${params.containerModifierClass}grid`);
                if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") el.classList.add(`${params.containerModifierClass}grid-column`);
                swiper.emitContainerClasses();
            }
            if (wasGrabCursor && !isGrabCursor) swiper.unsetGrabCursor(); else if (!wasGrabCursor && isGrabCursor) swiper.setGrabCursor();
            [ "navigation", "pagination", "scrollbar" ].forEach(prop => {
                if (typeof breakpointParams[prop] === "undefined") return;
                const wasModuleEnabled = params[prop] && params[prop].enabled;
                const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
                if (wasModuleEnabled && !isModuleEnabled) swiper[prop].disable();
                if (!wasModuleEnabled && isModuleEnabled) swiper[prop].enable();
            });
            const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
            const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
            const wasLoop = params.loop;
            if (directionChanged && initialized) swiper.changeDirection();
            utils_extend(swiper.params, breakpointParams);
            const isEnabled = swiper.params.enabled;
            const hasLoop = swiper.params.loop;
            Object.assign(swiper, {
                allowTouchMove: swiper.params.allowTouchMove,
                allowSlideNext: swiper.params.allowSlideNext,
                allowSlidePrev: swiper.params.allowSlidePrev
            });
            if (wasEnabled && !isEnabled) swiper.disable(); else if (!wasEnabled && isEnabled) swiper.enable();
            swiper.currentBreakpoint = breakpoint;
            swiper.emit("_beforeBreakpoint", breakpointParams);
            if (initialized) if (needsReLoop) {
                swiper.loopDestroy();
                swiper.loopCreate(realIndex);
                swiper.updateSlides();
            } else if (!wasLoop && hasLoop) {
                swiper.loopCreate(realIndex);
                swiper.updateSlides();
            } else if (wasLoop && !hasLoop) swiper.loopDestroy();
            swiper.emit("breakpoint", breakpointParams);
        }
        function getBreakpoint(breakpoints, base, containerEl) {
            if (base === void 0) base = "window";
            if (!breakpoints || base === "container" && !containerEl) return;
            let breakpoint = false;
            const window = ssr_window_esm_getWindow();
            const currentHeight = base === "window" ? window.innerHeight : containerEl.clientHeight;
            const points = Object.keys(breakpoints).map(point => {
                if (typeof point === "string" && point.indexOf("@") === 0) {
                    const minRatio = parseFloat(point.substr(1));
                    const value = currentHeight * minRatio;
                    return {
                        value,
                        point
                    };
                }
                return {
                    value: point,
                    point
                };
            });
            points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
            for (let i = 0; i < points.length; i += 1) {
                const {point, value} = points[i];
                if (base === "window") {
                    if (window.matchMedia(`(min-width: ${value}px)`).matches) breakpoint = point;
                } else if (value <= containerEl.clientWidth) breakpoint = point;
            }
            return breakpoint || "max";
        }
        var breakpoints = {
            setBreakpoint,
            getBreakpoint
        };
        function prepareClasses(entries, prefix) {
            const resultClasses = [];
            entries.forEach(item => {
                if (typeof item === "object") Object.keys(item).forEach(classNames => {
                    if (item[classNames]) resultClasses.push(prefix + classNames);
                }); else if (typeof item === "string") resultClasses.push(prefix + item);
            });
            return resultClasses;
        }
        function addClasses() {
            const swiper = this;
            const {classNames, params, rtl, el, device} = swiper;
            const suffixes = prepareClasses([ "initialized", params.direction, {
                "free-mode": swiper.params.freeMode && params.freeMode.enabled
            }, {
                autoheight: params.autoHeight
            }, {
                rtl
            }, {
                grid: params.grid && params.grid.rows > 1
            }, {
                "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
            }, {
                android: device.android
            }, {
                ios: device.ios
            }, {
                "css-mode": params.cssMode
            }, {
                centered: params.cssMode && params.centeredSlides
            }, {
                "watch-progress": params.watchSlidesProgress
            } ], params.containerModifierClass);
            classNames.push(...suffixes);
            el.classList.add(...classNames);
            swiper.emitContainerClasses();
        }
        function removeClasses() {
            const swiper = this;
            const {el, classNames} = swiper;
            if (!el || typeof el === "string") return;
            el.classList.remove(...classNames);
            swiper.emitContainerClasses();
        }
        var classes = {
            addClasses,
            removeClasses
        };
        function checkOverflow() {
            const swiper = this;
            const {isLocked: wasLocked, params} = swiper;
            const {slidesOffsetBefore} = params;
            if (slidesOffsetBefore) {
                const lastSlideIndex = swiper.slides.length - 1;
                const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
                swiper.isLocked = swiper.size > lastSlideRightEdge;
            } else swiper.isLocked = swiper.snapGrid.length === 1;
            if (params.allowSlideNext === true) swiper.allowSlideNext = !swiper.isLocked;
            if (params.allowSlidePrev === true) swiper.allowSlidePrev = !swiper.isLocked;
            if (wasLocked && wasLocked !== swiper.isLocked) swiper.isEnd = false;
            if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? "lock" : "unlock");
        }
        var checkOverflow$1 = {
            checkOverflow
        };
        var defaults = {
            init: true,
            direction: "horizontal",
            oneWayMovement: false,
            swiperElementNodeName: "SWIPER-CONTAINER",
            touchEventsTarget: "wrapper",
            initialSlide: 0,
            speed: 300,
            cssMode: false,
            updateOnWindowResize: true,
            resizeObserver: true,
            nested: false,
            createElements: false,
            eventsPrefix: "swiper",
            enabled: true,
            focusableElements: "input, select, option, textarea, button, video, label",
            width: null,
            height: null,
            preventInteractionOnTransition: false,
            userAgent: null,
            url: null,
            edgeSwipeDetection: false,
            edgeSwipeThreshold: 20,
            autoHeight: false,
            setWrapperSize: false,
            virtualTranslate: false,
            effect: "slide",
            breakpoints: void 0,
            breakpointsBase: "window",
            spaceBetween: 0,
            slidesPerView: 1,
            slidesPerGroup: 1,
            slidesPerGroupSkip: 0,
            slidesPerGroupAuto: false,
            centeredSlides: false,
            centeredSlidesBounds: false,
            slidesOffsetBefore: 0,
            slidesOffsetAfter: 0,
            normalizeSlideIndex: true,
            centerInsufficientSlides: false,
            watchOverflow: true,
            roundLengths: false,
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: true,
            shortSwipes: true,
            longSwipes: true,
            longSwipesRatio: .5,
            longSwipesMs: 300,
            followFinger: true,
            allowTouchMove: true,
            threshold: 5,
            touchMoveStopPropagation: false,
            touchStartPreventDefault: true,
            touchStartForcePreventDefault: false,
            touchReleaseOnEdges: false,
            uniqueNavElements: true,
            resistance: true,
            resistanceRatio: .85,
            watchSlidesProgress: false,
            grabCursor: false,
            preventClicks: true,
            preventClicksPropagation: true,
            slideToClickedSlide: false,
            loop: false,
            loopAddBlankSlides: true,
            loopAdditionalSlides: 0,
            loopPreventsSliding: true,
            rewind: false,
            allowSlidePrev: true,
            allowSlideNext: true,
            swipeHandler: null,
            noSwiping: true,
            noSwipingClass: "swiper-no-swiping",
            noSwipingSelector: null,
            passiveListeners: true,
            maxBackfaceHiddenSlides: 10,
            containerModifierClass: "swiper-",
            slideClass: "swiper-slide",
            slideBlankClass: "swiper-slide-blank",
            slideActiveClass: "swiper-slide-active",
            slideVisibleClass: "swiper-slide-visible",
            slideFullyVisibleClass: "swiper-slide-fully-visible",
            slideNextClass: "swiper-slide-next",
            slidePrevClass: "swiper-slide-prev",
            wrapperClass: "swiper-wrapper",
            lazyPreloaderClass: "swiper-lazy-preloader",
            lazyPreloadPrevNext: 0,
            runCallbacksOnInit: true,
            _emitClasses: false
        };
        function moduleExtendParams(params, allModulesParams) {
            return function extendParams(obj) {
                if (obj === void 0) obj = {};
                const moduleParamName = Object.keys(obj)[0];
                const moduleParams = obj[moduleParamName];
                if (typeof moduleParams !== "object" || moduleParams === null) {
                    utils_extend(allModulesParams, obj);
                    return;
                }
                if (params[moduleParamName] === true) params[moduleParamName] = {
                    enabled: true
                };
                if (moduleParamName === "navigation" && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) params[moduleParamName].auto = true;
                if ([ "pagination", "scrollbar" ].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) params[moduleParamName].auto = true;
                if (!(moduleParamName in params && "enabled" in moduleParams)) {
                    utils_extend(allModulesParams, obj);
                    return;
                }
                if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) params[moduleParamName].enabled = true;
                if (!params[moduleParamName]) params[moduleParamName] = {
                    enabled: false
                };
                utils_extend(allModulesParams, obj);
            };
        }
        const prototypes = {
            eventsEmitter,
            update,
            translate,
            transition,
            slide,
            loop,
            grabCursor,
            events: events$1,
            breakpoints,
            checkOverflow: checkOverflow$1,
            classes
        };
        const extendedDefaults = {};
        class Swiper {
            constructor() {
                let el;
                let params;
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") params = args[0]; else [el, params] = args;
                if (!params) params = {};
                params = utils_extend({}, params);
                if (el && !params.el) params.el = el;
                const document = ssr_window_esm_getDocument();
                if (params.el && typeof params.el === "string" && document.querySelectorAll(params.el).length > 1) {
                    const swipers = [];
                    document.querySelectorAll(params.el).forEach(containerEl => {
                        const newParams = utils_extend({}, params, {
                            el: containerEl
                        });
                        swipers.push(new Swiper(newParams));
                    });
                    return swipers;
                }
                const swiper = this;
                swiper.__swiper__ = true;
                swiper.support = getSupport();
                swiper.device = getDevice({
                    userAgent: params.userAgent
                });
                swiper.browser = getBrowser();
                swiper.eventsListeners = {};
                swiper.eventsAnyListeners = [];
                swiper.modules = [ ...swiper.__modules__ ];
                if (params.modules && Array.isArray(params.modules)) swiper.modules.push(...params.modules);
                const allModulesParams = {};
                swiper.modules.forEach(mod => {
                    mod({
                        params,
                        swiper,
                        extendParams: moduleExtendParams(params, allModulesParams),
                        on: swiper.on.bind(swiper),
                        once: swiper.once.bind(swiper),
                        off: swiper.off.bind(swiper),
                        emit: swiper.emit.bind(swiper)
                    });
                });
                const swiperParams = utils_extend({}, defaults, allModulesParams);
                swiper.params = utils_extend({}, swiperParams, extendedDefaults, params);
                swiper.originalParams = utils_extend({}, swiper.params);
                swiper.passedParams = utils_extend({}, params);
                if (swiper.params && swiper.params.on) Object.keys(swiper.params.on).forEach(eventName => {
                    swiper.on(eventName, swiper.params.on[eventName]);
                });
                if (swiper.params && swiper.params.onAny) swiper.onAny(swiper.params.onAny);
                Object.assign(swiper, {
                    enabled: swiper.params.enabled,
                    el,
                    classNames: [],
                    slides: [],
                    slidesGrid: [],
                    snapGrid: [],
                    slidesSizesGrid: [],
                    isHorizontal() {
                        return swiper.params.direction === "horizontal";
                    },
                    isVertical() {
                        return swiper.params.direction === "vertical";
                    },
                    activeIndex: 0,
                    realIndex: 0,
                    isBeginning: true,
                    isEnd: false,
                    translate: 0,
                    previousTranslate: 0,
                    progress: 0,
                    velocity: 0,
                    animating: false,
                    cssOverflowAdjustment() {
                        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
                    },
                    allowSlideNext: swiper.params.allowSlideNext,
                    allowSlidePrev: swiper.params.allowSlidePrev,
                    touchEventsData: {
                        isTouched: void 0,
                        isMoved: void 0,
                        allowTouchCallbacks: void 0,
                        touchStartTime: void 0,
                        isScrolling: void 0,
                        currentTranslate: void 0,
                        startTranslate: void 0,
                        allowThresholdMove: void 0,
                        focusableElements: swiper.params.focusableElements,
                        lastClickTime: 0,
                        clickTimeout: void 0,
                        velocities: [],
                        allowMomentumBounce: void 0,
                        startMoving: void 0,
                        pointerId: null,
                        touchId: null
                    },
                    allowClick: true,
                    allowTouchMove: swiper.params.allowTouchMove,
                    touches: {
                        startX: 0,
                        startY: 0,
                        currentX: 0,
                        currentY: 0,
                        diff: 0
                    },
                    imagesToLoad: [],
                    imagesLoaded: 0
                });
                swiper.emit("_swiper");
                if (swiper.params.init) swiper.init();
                return swiper;
            }
            getDirectionLabel(property) {
                if (this.isHorizontal()) return property;
                return {
                    width: "height",
                    "margin-top": "margin-left",
                    "margin-bottom ": "margin-right",
                    "margin-left": "margin-top",
                    "margin-right": "margin-bottom",
                    "padding-left": "padding-top",
                    "padding-right": "padding-bottom",
                    marginRight: "marginBottom"
                }[property];
            }
            getSlideIndex(slideEl) {
                const {slidesEl, params} = this;
                const slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
                const firstSlideIndex = utils_elementIndex(slides[0]);
                return utils_elementIndex(slideEl) - firstSlideIndex;
            }
            getSlideIndexByData(index) {
                return this.getSlideIndex(this.slides.find(slideEl => slideEl.getAttribute("data-swiper-slide-index") * 1 === index));
            }
            getSlideIndexWhenGrid(index) {
                if (this.grid && this.params.grid && this.params.grid.rows > 1) if (this.params.grid.fill === "column") index = Math.floor(index / this.params.grid.rows); else if (this.params.grid.fill === "row") index %= Math.ceil(this.slides.length / this.params.grid.rows);
                return index;
            }
            recalcSlides() {
                const swiper = this;
                const {slidesEl, params} = swiper;
                swiper.slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
            }
            enable() {
                const swiper = this;
                if (swiper.enabled) return;
                swiper.enabled = true;
                if (swiper.params.grabCursor) swiper.setGrabCursor();
                swiper.emit("enable");
            }
            disable() {
                const swiper = this;
                if (!swiper.enabled) return;
                swiper.enabled = false;
                if (swiper.params.grabCursor) swiper.unsetGrabCursor();
                swiper.emit("disable");
            }
            setProgress(progress, speed) {
                const swiper = this;
                progress = Math.min(Math.max(progress, 0), 1);
                const min = swiper.minTranslate();
                const max = swiper.maxTranslate();
                const current = (max - min) * progress + min;
                swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            emitContainerClasses() {
                const swiper = this;
                if (!swiper.params._emitClasses || !swiper.el) return;
                const cls = swiper.el.className.split(" ").filter(className => className.indexOf("swiper") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0);
                swiper.emit("_containerClasses", cls.join(" "));
            }
            getSlideClasses(slideEl) {
                const swiper = this;
                if (swiper.destroyed) return "";
                return slideEl.className.split(" ").filter(className => className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0).join(" ");
            }
            emitSlidesClasses() {
                const swiper = this;
                if (!swiper.params._emitClasses || !swiper.el) return;
                const updates = [];
                swiper.slides.forEach(slideEl => {
                    const classNames = swiper.getSlideClasses(slideEl);
                    updates.push({
                        slideEl,
                        classNames
                    });
                    swiper.emit("_slideClass", slideEl, classNames);
                });
                swiper.emit("_slideClasses", updates);
            }
            slidesPerViewDynamic(view, exact) {
                if (view === void 0) view = "current";
                if (exact === void 0) exact = false;
                const swiper = this;
                const {params, slides, slidesGrid, slidesSizesGrid, size: swiperSize, activeIndex} = swiper;
                let spv = 1;
                if (typeof params.slidesPerView === "number") return params.slidesPerView;
                if (params.centeredSlides) {
                    let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;
                    let breakLoop;
                    for (let i = activeIndex + 1; i < slides.length; i += 1) if (slides[i] && !breakLoop) {
                        slideSize += Math.ceil(slides[i].swiperSlideSize);
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                    for (let i = activeIndex - 1; i >= 0; i -= 1) if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                } else if (view === "current") for (let i = activeIndex + 1; i < slides.length; i += 1) {
                    const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
                    if (slideInView) spv += 1;
                } else for (let i = activeIndex - 1; i >= 0; i -= 1) {
                    const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
                    if (slideInView) spv += 1;
                }
                return spv;
            }
            update() {
                const swiper = this;
                if (!swiper || swiper.destroyed) return;
                const {snapGrid, params} = swiper;
                if (params.breakpoints) swiper.setBreakpoint();
                [ ...swiper.el.querySelectorAll('[loading="lazy"]') ].forEach(imageEl => {
                    if (imageEl.complete) processLazyPreloader(swiper, imageEl);
                });
                swiper.updateSize();
                swiper.updateSlides();
                swiper.updateProgress();
                swiper.updateSlidesClasses();
                function setTranslate() {
                    const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
                    const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
                    swiper.setTranslate(newTranslate);
                    swiper.updateActiveIndex();
                    swiper.updateSlidesClasses();
                }
                let translated;
                if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
                    setTranslate();
                    if (params.autoHeight) swiper.updateAutoHeight();
                } else {
                    if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
                        const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
                        translated = swiper.slideTo(slides.length - 1, 0, false, true);
                    } else translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
                    if (!translated) setTranslate();
                }
                if (params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();
                swiper.emit("update");
            }
            changeDirection(newDirection, needUpdate) {
                if (needUpdate === void 0) needUpdate = true;
                const swiper = this;
                const currentDirection = swiper.params.direction;
                if (!newDirection) newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
                if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") return swiper;
                swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
                swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
                swiper.emitContainerClasses();
                swiper.params.direction = newDirection;
                swiper.slides.forEach(slideEl => {
                    if (newDirection === "vertical") slideEl.style.width = ""; else slideEl.style.height = "";
                });
                swiper.emit("changeDirection");
                if (needUpdate) swiper.update();
                return swiper;
            }
            changeLanguageDirection(direction) {
                const swiper = this;
                if (swiper.rtl && direction === "rtl" || !swiper.rtl && direction === "ltr") return;
                swiper.rtl = direction === "rtl";
                swiper.rtlTranslate = swiper.params.direction === "horizontal" && swiper.rtl;
                if (swiper.rtl) {
                    swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
                    swiper.el.dir = "rtl";
                } else {
                    swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
                    swiper.el.dir = "ltr";
                }
                swiper.update();
            }
            mount(element) {
                const swiper = this;
                if (swiper.mounted) return true;
                let el = element || swiper.params.el;
                if (typeof el === "string") el = document.querySelector(el);
                if (!el) return false;
                el.swiper = swiper;
                if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) swiper.isElement = true;
                const getWrapperSelector = () => `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`;
                const getWrapper = () => {
                    if (el && el.shadowRoot && el.shadowRoot.querySelector) {
                        const res = el.shadowRoot.querySelector(getWrapperSelector());
                        return res;
                    }
                    return utils_elementChildren(el, getWrapperSelector())[0];
                };
                let wrapperEl = getWrapper();
                if (!wrapperEl && swiper.params.createElements) {
                    wrapperEl = utils_createElement("div", swiper.params.wrapperClass);
                    el.append(wrapperEl);
                    utils_elementChildren(el, `.${swiper.params.slideClass}`).forEach(slideEl => {
                        wrapperEl.append(slideEl);
                    });
                }
                Object.assign(swiper, {
                    el,
                    wrapperEl,
                    slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
                    hostEl: swiper.isElement ? el.parentNode.host : el,
                    mounted: true,
                    rtl: el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl",
                    rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl"),
                    wrongRTL: elementStyle(wrapperEl, "display") === "-webkit-box"
                });
                return true;
            }
            init(el) {
                const swiper = this;
                if (swiper.initialized) return swiper;
                const mounted = swiper.mount(el);
                if (mounted === false) return swiper;
                swiper.emit("beforeInit");
                if (swiper.params.breakpoints) swiper.setBreakpoint();
                swiper.addClasses();
                swiper.updateSize();
                swiper.updateSlides();
                if (swiper.params.watchOverflow) swiper.checkOverflow();
                if (swiper.params.grabCursor && swiper.enabled) swiper.setGrabCursor();
                if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true); else swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
                if (swiper.params.loop) swiper.loopCreate(void 0, true);
                swiper.attachEvents();
                const lazyElements = [ ...swiper.el.querySelectorAll('[loading="lazy"]') ];
                if (swiper.isElement) lazyElements.push(...swiper.hostEl.querySelectorAll('[loading="lazy"]'));
                lazyElements.forEach(imageEl => {
                    if (imageEl.complete) processLazyPreloader(swiper, imageEl); else imageEl.addEventListener("load", e => {
                        processLazyPreloader(swiper, e.target);
                    });
                });
                preload(swiper);
                swiper.initialized = true;
                preload(swiper);
                swiper.emit("init");
                swiper.emit("afterInit");
                return swiper;
            }
            destroy(deleteInstance, cleanStyles) {
                if (deleteInstance === void 0) deleteInstance = true;
                if (cleanStyles === void 0) cleanStyles = true;
                const swiper = this;
                const {params, el, wrapperEl, slides} = swiper;
                if (typeof swiper.params === "undefined" || swiper.destroyed) return null;
                swiper.emit("beforeDestroy");
                swiper.initialized = false;
                swiper.detachEvents();
                if (params.loop) swiper.loopDestroy();
                if (cleanStyles) {
                    swiper.removeClasses();
                    if (el && typeof el !== "string") el.removeAttribute("style");
                    if (wrapperEl) wrapperEl.removeAttribute("style");
                    if (slides && slides.length) slides.forEach(slideEl => {
                        slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
                        slideEl.removeAttribute("style");
                        slideEl.removeAttribute("data-swiper-slide-index");
                    });
                }
                swiper.emit("destroy");
                Object.keys(swiper.eventsListeners).forEach(eventName => {
                    swiper.off(eventName);
                });
                if (deleteInstance !== false) {
                    if (swiper.el && typeof swiper.el !== "string") swiper.el.swiper = null;
                    deleteProps(swiper);
                }
                swiper.destroyed = true;
                return null;
            }
            static extendDefaults(newDefaults) {
                utils_extend(extendedDefaults, newDefaults);
            }
            static get extendedDefaults() {
                return extendedDefaults;
            }
            static get defaults() {
                return defaults;
            }
            static installModule(mod) {
                if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
                const modules = Swiper.prototype.__modules__;
                if (typeof mod === "function" && modules.indexOf(mod) < 0) modules.push(mod);
            }
            static use(module) {
                if (Array.isArray(module)) {
                    module.forEach(m => Swiper.installModule(m));
                    return Swiper;
                }
                Swiper.installModule(module);
                return Swiper;
            }
        }
        Object.keys(prototypes).forEach(prototypeGroup => {
            Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
                Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
            });
        });
        Swiper.use([ Resize, Observer ]);
        const paramsList = [ "eventsPrefix", "injectStyles", "injectStylesUrls", "modules", "init", "_direction", "oneWayMovement", "swiperElementNodeName", "touchEventsTarget", "initialSlide", "_speed", "cssMode", "updateOnWindowResize", "resizeObserver", "nested", "focusableElements", "_enabled", "_width", "_height", "preventInteractionOnTransition", "userAgent", "url", "_edgeSwipeDetection", "_edgeSwipeThreshold", "_freeMode", "_autoHeight", "setWrapperSize", "virtualTranslate", "_effect", "breakpoints", "breakpointsBase", "_spaceBetween", "_slidesPerView", "maxBackfaceHiddenSlides", "_grid", "_slidesPerGroup", "_slidesPerGroupSkip", "_slidesPerGroupAuto", "_centeredSlides", "_centeredSlidesBounds", "_slidesOffsetBefore", "_slidesOffsetAfter", "normalizeSlideIndex", "_centerInsufficientSlides", "_watchOverflow", "roundLengths", "touchRatio", "touchAngle", "simulateTouch", "_shortSwipes", "_longSwipes", "longSwipesRatio", "longSwipesMs", "_followFinger", "allowTouchMove", "_threshold", "touchMoveStopPropagation", "touchStartPreventDefault", "touchStartForcePreventDefault", "touchReleaseOnEdges", "uniqueNavElements", "_resistance", "_resistanceRatio", "_watchSlidesProgress", "_grabCursor", "preventClicks", "preventClicksPropagation", "_slideToClickedSlide", "_loop", "loopAdditionalSlides", "loopAddBlankSlides", "loopPreventsSliding", "_rewind", "_allowSlidePrev", "_allowSlideNext", "_swipeHandler", "_noSwiping", "noSwipingClass", "noSwipingSelector", "passiveListeners", "containerModifierClass", "slideClass", "slideActiveClass", "slideVisibleClass", "slideFullyVisibleClass", "slideNextClass", "slidePrevClass", "slideBlankClass", "wrapperClass", "lazyPreloaderClass", "lazyPreloadPrevNext", "runCallbacksOnInit", "observer", "observeParents", "observeSlideChildren", "a11y", "_autoplay", "_controller", "coverflowEffect", "cubeEffect", "fadeEffect", "flipEffect", "creativeEffect", "cardsEffect", "hashNavigation", "history", "keyboard", "mousewheel", "_navigation", "_pagination", "parallax", "_scrollbar", "_thumbs", "virtual", "zoom", "control" ];
        function update_swiper_isObject(o) {
            return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object" && !o.__swiper__;
        }
        function update_swiper_extend(target, src) {
            const noExtend = [ "__proto__", "constructor", "prototype" ];
            Object.keys(src).filter(key => noExtend.indexOf(key) < 0).forEach(key => {
                if (typeof target[key] === "undefined") target[key] = src[key]; else if (update_swiper_isObject(src[key]) && update_swiper_isObject(target[key]) && Object.keys(src[key]).length > 0) if (src[key].__swiper__) target[key] = src[key]; else update_swiper_extend(target[key], src[key]); else target[key] = src[key];
            });
        }
        function needsNavigation(params) {
            if (params === void 0) params = {};
            return params.navigation && typeof params.navigation.nextEl === "undefined" && typeof params.navigation.prevEl === "undefined";
        }
        function needsPagination(params) {
            if (params === void 0) params = {};
            return params.pagination && typeof params.pagination.el === "undefined";
        }
        function needsScrollbar(params) {
            if (params === void 0) params = {};
            return params.scrollbar && typeof params.scrollbar.el === "undefined";
        }
        function uniqueClasses(classNames) {
            if (classNames === void 0) classNames = "";
            const classes = classNames.split(" ").map(c => c.trim()).filter(c => !!c);
            const unique = [];
            classes.forEach(c => {
                if (unique.indexOf(c) < 0) unique.push(c);
            });
            return unique.join(" ");
        }
        function wrapperClass(className) {
            if (className === void 0) className = "";
            if (!className) return "swiper-wrapper";
            if (!className.includes("swiper-wrapper")) return `swiper-wrapper ${className}`;
            return className;
        }
        function updateSwiper(_ref) {
            let {swiper, slides, passedParams, changedParams, nextEl, prevEl, scrollbarEl, paginationEl} = _ref;
            const updateParams = changedParams.filter(key => key !== "children" && key !== "direction" && key !== "wrapperClass");
            const {params: currentParams, pagination, navigation, scrollbar, virtual, thumbs} = swiper;
            let needThumbsInit;
            let needControllerInit;
            let needPaginationInit;
            let needScrollbarInit;
            let needNavigationInit;
            let loopNeedDestroy;
            let loopNeedEnable;
            let loopNeedReloop;
            if (changedParams.includes("thumbs") && passedParams.thumbs && passedParams.thumbs.swiper && !passedParams.thumbs.swiper.destroyed && currentParams.thumbs && (!currentParams.thumbs.swiper || currentParams.thumbs.swiper.destroyed)) needThumbsInit = true;
            if (changedParams.includes("controller") && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control) needControllerInit = true;
            if (changedParams.includes("pagination") && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === false) && pagination && !pagination.el) needPaginationInit = true;
            if (changedParams.includes("scrollbar") && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === false) && scrollbar && !scrollbar.el) needScrollbarInit = true;
            if (changedParams.includes("navigation") && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === false) && navigation && !navigation.prevEl && !navigation.nextEl) needNavigationInit = true;
            const destroyModule = mod => {
                if (!swiper[mod]) return;
                swiper[mod].destroy();
                if (mod === "navigation") {
                    if (swiper.isElement) {
                        swiper[mod].prevEl.remove();
                        swiper[mod].nextEl.remove();
                    }
                    currentParams[mod].prevEl = void 0;
                    currentParams[mod].nextEl = void 0;
                    swiper[mod].prevEl = void 0;
                    swiper[mod].nextEl = void 0;
                } else {
                    if (swiper.isElement) swiper[mod].el.remove();
                    currentParams[mod].el = void 0;
                    swiper[mod].el = void 0;
                }
            };
            if (changedParams.includes("loop") && swiper.isElement) if (currentParams.loop && !passedParams.loop) loopNeedDestroy = true; else if (!currentParams.loop && passedParams.loop) loopNeedEnable = true; else loopNeedReloop = true;
            updateParams.forEach(key => {
                if (update_swiper_isObject(currentParams[key]) && update_swiper_isObject(passedParams[key])) {
                    Object.assign(currentParams[key], passedParams[key]);
                    if ((key === "navigation" || key === "pagination" || key === "scrollbar") && "enabled" in passedParams[key] && !passedParams[key].enabled) destroyModule(key);
                } else {
                    const newValue = passedParams[key];
                    if ((newValue === true || newValue === false) && (key === "navigation" || key === "pagination" || key === "scrollbar")) {
                        if (newValue === false) destroyModule(key);
                    } else currentParams[key] = passedParams[key];
                }
            });
            if (updateParams.includes("controller") && !needControllerInit && swiper.controller && swiper.controller.control && currentParams.controller && currentParams.controller.control) swiper.controller.control = currentParams.controller.control;
            if (changedParams.includes("children") && slides && virtual && currentParams.virtual.enabled) {
                virtual.slides = slides;
                virtual.update(true);
            } else if (changedParams.includes("virtual") && virtual && currentParams.virtual.enabled) {
                if (slides) virtual.slides = slides;
                virtual.update(true);
            }
            if (changedParams.includes("children") && slides && currentParams.loop) loopNeedReloop = true;
            if (needThumbsInit) {
                const initialized = thumbs.init();
                if (initialized) thumbs.update(true);
            }
            if (needControllerInit) swiper.controller.control = currentParams.controller.control;
            if (needPaginationInit) {
                if (swiper.isElement && (!paginationEl || typeof paginationEl === "string")) {
                    paginationEl = document.createElement("div");
                    paginationEl.classList.add("swiper-pagination");
                    paginationEl.part.add("pagination");
                    swiper.el.appendChild(paginationEl);
                }
                if (paginationEl) currentParams.pagination.el = paginationEl;
                pagination.init();
                pagination.render();
                pagination.update();
            }
            if (needScrollbarInit) {
                if (swiper.isElement && (!scrollbarEl || typeof scrollbarEl === "string")) {
                    scrollbarEl = document.createElement("div");
                    scrollbarEl.classList.add("swiper-scrollbar");
                    scrollbarEl.part.add("scrollbar");
                    swiper.el.appendChild(scrollbarEl);
                }
                if (scrollbarEl) currentParams.scrollbar.el = scrollbarEl;
                scrollbar.init();
                scrollbar.updateSize();
                scrollbar.setTranslate();
            }
            if (needNavigationInit) {
                if (swiper.isElement) {
                    if (!nextEl || typeof nextEl === "string") {
                        nextEl = document.createElement("div");
                        nextEl.classList.add("swiper-button-next");
                        utils_setInnerHTML(nextEl, swiper.hostEl.constructor.nextButtonSvg);
                        nextEl.part.add("button-next");
                        swiper.el.appendChild(nextEl);
                    }
                    if (!prevEl || typeof prevEl === "string") {
                        prevEl = document.createElement("div");
                        prevEl.classList.add("swiper-button-prev");
                        utils_setInnerHTML(prevEl, swiper.hostEl.constructor.prevButtonSvg);
                        prevEl.part.add("button-prev");
                        swiper.el.appendChild(prevEl);
                    }
                }
                if (nextEl) currentParams.navigation.nextEl = nextEl;
                if (prevEl) currentParams.navigation.prevEl = prevEl;
                navigation.init();
                navigation.update();
            }
            if (changedParams.includes("allowSlideNext")) swiper.allowSlideNext = passedParams.allowSlideNext;
            if (changedParams.includes("allowSlidePrev")) swiper.allowSlidePrev = passedParams.allowSlidePrev;
            if (changedParams.includes("direction")) swiper.changeDirection(passedParams.direction, false);
            if (loopNeedDestroy || loopNeedReloop) swiper.loopDestroy();
            if (loopNeedEnable || loopNeedReloop) swiper.loopCreate();
            swiper.update();
        }
        function getParams(obj, splitEvents) {
            if (obj === void 0) obj = {};
            if (splitEvents === void 0) splitEvents = true;
            const params = {
                on: {}
            };
            const events = {};
            const passedParams = {};
            update_swiper_extend(params, defaults);
            params._emitClasses = true;
            params.init = false;
            const rest = {};
            const allowedParams = paramsList.map(key => key.replace(/_/, ""));
            const plainObj = Object.assign({}, obj);
            Object.keys(plainObj).forEach(key => {
                if (typeof obj[key] === "undefined") return;
                if (allowedParams.indexOf(key) >= 0) if (update_swiper_isObject(obj[key])) {
                    params[key] = {};
                    passedParams[key] = {};
                    update_swiper_extend(params[key], obj[key]);
                    update_swiper_extend(passedParams[key], obj[key]);
                } else {
                    params[key] = obj[key];
                    passedParams[key] = obj[key];
                } else if (key.search(/on[A-Z]/) === 0 && typeof obj[key] === "function") if (splitEvents) events[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key]; else params.on[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key]; else rest[key] = obj[key];
            });
            [ "navigation", "pagination", "scrollbar" ].forEach(key => {
                if (params[key] === true) params[key] = {};
                if (params[key] === false) delete params[key];
            });
            return {
                params,
                passedParams,
                rest,
                events
            };
        }
        function mountSwiper(_ref, swiperParams) {
            let {el, nextEl, prevEl, paginationEl, scrollbarEl, swiper} = _ref;
            if (needsNavigation(swiperParams) && nextEl && prevEl) {
                swiper.params.navigation.nextEl = nextEl;
                swiper.originalParams.navigation.nextEl = nextEl;
                swiper.params.navigation.prevEl = prevEl;
                swiper.originalParams.navigation.prevEl = prevEl;
            }
            if (needsPagination(swiperParams) && paginationEl) {
                swiper.params.pagination.el = paginationEl;
                swiper.originalParams.pagination.el = paginationEl;
            }
            if (needsScrollbar(swiperParams) && scrollbarEl) {
                swiper.params.scrollbar.el = scrollbarEl;
                swiper.originalParams.scrollbar.el = scrollbarEl;
            }
            swiper.init(el);
        }
        function getChangedParams(swiperParams, oldParams, children, oldChildren, getKey) {
            const keys = [];
            if (!oldParams) return keys;
            const addKey = key => {
                if (keys.indexOf(key) < 0) keys.push(key);
            };
            if (children && oldChildren) {
                const oldChildrenKeys = oldChildren.map(getKey);
                const childrenKeys = children.map(getKey);
                if (oldChildrenKeys.join("") !== childrenKeys.join("")) addKey("children");
                if (oldChildren.length !== children.length) addKey("children");
            }
            const watchParams = paramsList.filter(key => key[0] === "_").map(key => key.replace(/_/, ""));
            watchParams.forEach(key => {
                if (key in swiperParams && key in oldParams) if (update_swiper_isObject(swiperParams[key]) && update_swiper_isObject(oldParams[key])) {
                    const newKeys = Object.keys(swiperParams[key]);
                    const oldKeys = Object.keys(oldParams[key]);
                    if (newKeys.length !== oldKeys.length) addKey(key); else {
                        newKeys.forEach(newKey => {
                            if (swiperParams[key][newKey] !== oldParams[key][newKey]) addKey(key);
                        });
                        oldKeys.forEach(oldKey => {
                            if (swiperParams[key][oldKey] !== oldParams[key][oldKey]) addKey(key);
                        });
                    }
                } else if (swiperParams[key] !== oldParams[key]) addKey(key);
            });
            return keys;
        }
        const updateOnVirtualData = swiper => {
            if (!swiper || swiper.destroyed || !swiper.params.virtual || swiper.params.virtual && !swiper.params.virtual.enabled) return;
            swiper.updateSlides();
            swiper.updateProgress();
            swiper.updateSlidesClasses();
            swiper.emit("_virtualUpdated");
            if (swiper.parallax && swiper.params.parallax && swiper.params.parallax.enabled) swiper.parallax.setTranslate();
        };
        function _extends() {
            _extends = Object.assign ? Object.assign.bind() : function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
                }
                return target;
            };
            return _extends.apply(this, arguments);
        }
        function isChildSwiperSlide(child) {
            return child.type && child.type.displayName && child.type.displayName.includes("SwiperSlide");
        }
        function processChildren(c) {
            const slides = [];
            react.Children.toArray(c).forEach(child => {
                if (isChildSwiperSlide(child)) slides.push(child); else if (child.props && child.props.children) processChildren(child.props.children).forEach(slide => slides.push(slide));
            });
            return slides;
        }
        function getChildren(c) {
            const slides = [];
            const slots = {
                "container-start": [],
                "container-end": [],
                "wrapper-start": [],
                "wrapper-end": []
            };
            react.Children.toArray(c).forEach(child => {
                if (isChildSwiperSlide(child)) slides.push(child); else if (child.props && child.props.slot && slots[child.props.slot]) slots[child.props.slot].push(child); else if (child.props && child.props.children) {
                    const foundSlides = processChildren(child.props.children);
                    if (foundSlides.length > 0) foundSlides.forEach(slide => slides.push(slide)); else slots["container-end"].push(child);
                } else slots["container-end"].push(child);
            });
            return {
                slides,
                slots
            };
        }
        function renderVirtual(swiper, slides, virtualData) {
            if (!virtualData) return null;
            const getSlideIndex = index => {
                let slideIndex = index;
                if (index < 0) slideIndex = slides.length + index; else if (slideIndex >= slides.length) slideIndex -= slides.length;
                return slideIndex;
            };
            const style = swiper.isHorizontal() ? {
                [swiper.rtlTranslate ? "right" : "left"]: `${virtualData.offset}px`
            } : {
                top: `${virtualData.offset}px`
            };
            const {from, to} = virtualData;
            const loopFrom = swiper.params.loop ? -slides.length : 0;
            const loopTo = swiper.params.loop ? slides.length * 2 : slides.length;
            const slidesToRender = [];
            for (let i = loopFrom; i < loopTo; i += 1) if (i >= from && i <= to) slidesToRender.push(slides[getSlideIndex(i)]);
            return slidesToRender.map((child, index) => react.cloneElement(child, {
                swiper,
                style,
                key: child.props.virtualIndex || child.key || `slide-${index}`
            }));
        }
        function swiper_react_useIsomorphicLayoutEffect(callback, deps) {
            if (typeof window === "undefined") return (0, react.useEffect)(callback, deps);
            return (0, react.useLayoutEffect)(callback, deps);
        }
        const SwiperSlideContext = (0, react.createContext)(null);
        const SwiperContext = (0, react.createContext)(null);
        const swiper_react_Swiper = (0, react.forwardRef)(function(_temp, externalElRef) {
            let {className, tag: Tag = "div", wrapperTag: WrapperTag = "div", children, onSwiper, ...rest} = _temp === void 0 ? {} : _temp;
            let eventsAssigned = false;
            const [containerClasses, setContainerClasses] = (0, react.useState)("swiper");
            const [virtualData, setVirtualData] = (0, react.useState)(null);
            const [breakpointChanged, setBreakpointChanged] = (0, react.useState)(false);
            const initializedRef = (0, react.useRef)(false);
            const swiperElRef = (0, react.useRef)(null);
            const swiperRef = (0, react.useRef)(null);
            const oldPassedParamsRef = (0, react.useRef)(null);
            const oldSlides = (0, react.useRef)(null);
            const nextElRef = (0, react.useRef)(null);
            const prevElRef = (0, react.useRef)(null);
            const paginationElRef = (0, react.useRef)(null);
            const scrollbarElRef = (0, react.useRef)(null);
            const {params: swiperParams, passedParams, rest: restProps, events} = getParams(rest);
            const {slides, slots} = getChildren(children);
            const onBeforeBreakpoint = () => {
                setBreakpointChanged(!breakpointChanged);
            };
            Object.assign(swiperParams.on, {
                _containerClasses(swiper, classes) {
                    setContainerClasses(classes);
                }
            });
            const initSwiper = () => {
                Object.assign(swiperParams.on, events);
                eventsAssigned = true;
                const passParams = {
                    ...swiperParams
                };
                delete passParams.wrapperClass;
                swiperRef.current = new Swiper(passParams);
                if (swiperRef.current.virtual && swiperRef.current.params.virtual.enabled) {
                    swiperRef.current.virtual.slides = slides;
                    const extendWith = {
                        cache: false,
                        slides,
                        renderExternal: setVirtualData,
                        renderExternalUpdate: false
                    };
                    update_swiper_extend(swiperRef.current.params.virtual, extendWith);
                    update_swiper_extend(swiperRef.current.originalParams.virtual, extendWith);
                }
            };
            if (!swiperElRef.current) initSwiper();
            if (swiperRef.current) swiperRef.current.on("_beforeBreakpoint", onBeforeBreakpoint);
            const attachEvents = () => {
                if (eventsAssigned || !events || !swiperRef.current) return;
                Object.keys(events).forEach(eventName => {
                    swiperRef.current.on(eventName, events[eventName]);
                });
            };
            const detachEvents = () => {
                if (!events || !swiperRef.current) return;
                Object.keys(events).forEach(eventName => {
                    swiperRef.current.off(eventName, events[eventName]);
                });
            };
            (0, react.useEffect)(() => () => {
                if (swiperRef.current) swiperRef.current.off("_beforeBreakpoint", onBeforeBreakpoint);
            });
            (0, react.useEffect)(() => {
                if (!initializedRef.current && swiperRef.current) {
                    swiperRef.current.emitSlidesClasses();
                    initializedRef.current = true;
                }
            });
            swiper_react_useIsomorphicLayoutEffect(() => {
                if (externalElRef) externalElRef.current = swiperElRef.current;
                if (!swiperElRef.current) return;
                if (swiperRef.current.destroyed) initSwiper();
                mountSwiper({
                    el: swiperElRef.current,
                    nextEl: nextElRef.current,
                    prevEl: prevElRef.current,
                    paginationEl: paginationElRef.current,
                    scrollbarEl: scrollbarElRef.current,
                    swiper: swiperRef.current
                }, swiperParams);
                if (onSwiper && !swiperRef.current.destroyed) onSwiper(swiperRef.current);
                return () => {
                    if (swiperRef.current && !swiperRef.current.destroyed) swiperRef.current.destroy(true, false);
                };
            }, []);
            swiper_react_useIsomorphicLayoutEffect(() => {
                attachEvents();
                const changedParams = getChangedParams(passedParams, oldPassedParamsRef.current, slides, oldSlides.current, c => c.key);
                oldPassedParamsRef.current = passedParams;
                oldSlides.current = slides;
                if (changedParams.length && swiperRef.current && !swiperRef.current.destroyed) updateSwiper({
                    swiper: swiperRef.current,
                    slides,
                    passedParams,
                    changedParams,
                    nextEl: nextElRef.current,
                    prevEl: prevElRef.current,
                    scrollbarEl: scrollbarElRef.current,
                    paginationEl: paginationElRef.current
                });
                return () => {
                    detachEvents();
                };
            });
            swiper_react_useIsomorphicLayoutEffect(() => {
                updateOnVirtualData(swiperRef.current);
            }, [ virtualData ]);
            function renderSlides() {
                if (swiperParams.virtual) return renderVirtual(swiperRef.current, slides, virtualData);
                return slides.map((child, index) => react.cloneElement(child, {
                    swiper: swiperRef.current,
                    swiperSlideIndex: index
                }));
            }
            return react.createElement(Tag, _extends({
                ref: swiperElRef,
                className: uniqueClasses(`${containerClasses}${className ? ` ${className}` : ""}`)
            }, restProps), react.createElement(SwiperContext.Provider, {
                value: swiperRef.current
            }, slots["container-start"], react.createElement(WrapperTag, {
                className: wrapperClass(swiperParams.wrapperClass)
            }, slots["wrapper-start"], renderSlides(), slots["wrapper-end"]), needsNavigation(swiperParams) && react.createElement(react.Fragment, null, react.createElement("div", {
                ref: prevElRef,
                className: "swiper-button-prev"
            }), react.createElement("div", {
                ref: nextElRef,
                className: "swiper-button-next"
            })), needsScrollbar(swiperParams) && react.createElement("div", {
                ref: scrollbarElRef,
                className: "swiper-scrollbar"
            }), needsPagination(swiperParams) && react.createElement("div", {
                ref: paginationElRef,
                className: "swiper-pagination"
            }), slots["container-end"]));
        });
        swiper_react_Swiper.displayName = "Swiper";
        const SwiperSlide = (0, react.forwardRef)(function(_temp, externalRef) {
            let {tag: Tag = "div", children, className = "", swiper, zoom, lazy, virtualIndex, swiperSlideIndex, ...rest} = _temp === void 0 ? {} : _temp;
            const slideElRef = (0, react.useRef)(null);
            const [slideClasses, setSlideClasses] = (0, react.useState)("swiper-slide");
            const [lazyLoaded, setLazyLoaded] = (0, react.useState)(false);
            function updateClasses(_s, el, classNames) {
                if (el === slideElRef.current) setSlideClasses(classNames);
            }
            swiper_react_useIsomorphicLayoutEffect(() => {
                if (typeof swiperSlideIndex !== "undefined") slideElRef.current.swiperSlideIndex = swiperSlideIndex;
                if (externalRef) externalRef.current = slideElRef.current;
                if (!slideElRef.current || !swiper) return;
                if (swiper.destroyed) {
                    if (slideClasses !== "swiper-slide") setSlideClasses("swiper-slide");
                    return;
                }
                swiper.on("_slideClass", updateClasses);
                return () => {
                    if (!swiper) return;
                    swiper.off("_slideClass", updateClasses);
                };
            });
            swiper_react_useIsomorphicLayoutEffect(() => {
                if (swiper && slideElRef.current && !swiper.destroyed) setSlideClasses(swiper.getSlideClasses(slideElRef.current));
            }, [ swiper ]);
            const slideData = {
                isActive: slideClasses.indexOf("swiper-slide-active") >= 0,
                isVisible: slideClasses.indexOf("swiper-slide-visible") >= 0,
                isPrev: slideClasses.indexOf("swiper-slide-prev") >= 0,
                isNext: slideClasses.indexOf("swiper-slide-next") >= 0
            };
            const renderChildren = () => typeof children === "function" ? children(slideData) : children;
            const onLoad = () => {
                setLazyLoaded(true);
            };
            return react.createElement(Tag, _extends({
                ref: slideElRef,
                className: uniqueClasses(`${slideClasses}${className ? ` ${className}` : ""}`),
                "data-swiper-slide-index": virtualIndex,
                onLoad
            }, rest), zoom && react.createElement(SwiperSlideContext.Provider, {
                value: slideData
            }, react.createElement("div", {
                className: "swiper-zoom-container",
                "data-swiper-zoom": typeof zoom === "number" ? zoom : void 0
            }, renderChildren(), lazy && !lazyLoaded && react.createElement("div", {
                className: "swiper-lazy-preloader"
            }))), !zoom && react.createElement(SwiperSlideContext.Provider, {
                value: slideData
            }, renderChildren(), lazy && !lazyLoaded && react.createElement("div", {
                className: "swiper-lazy-preloader"
            })));
        });
        SwiperSlide.displayName = "SwiperSlide";
        function Mousewheel(_ref) {
            let {swiper, extendParams, on, emit} = _ref;
            const window = ssr_window_esm_getWindow();
            extendParams({
                mousewheel: {
                    enabled: false,
                    releaseOnEdges: false,
                    invert: false,
                    forceToAxis: false,
                    sensitivity: 1,
                    eventsTarget: "container",
                    thresholdDelta: null,
                    thresholdTime: null,
                    noMousewheelClass: "swiper-no-mousewheel"
                }
            });
            swiper.mousewheel = {
                enabled: false
            };
            let timeout;
            let lastScrollTime = now();
            let lastEventBeforeSnap;
            const recentWheelEvents = [];
            function normalize(e) {
                const PIXEL_STEP = 10;
                const LINE_HEIGHT = 40;
                const PAGE_HEIGHT = 800;
                let sX = 0;
                let sY = 0;
                let pX = 0;
                let pY = 0;
                if ("detail" in e) sY = e.detail;
                if ("wheelDelta" in e) sY = -e.wheelDelta / 120;
                if ("wheelDeltaY" in e) sY = -e.wheelDeltaY / 120;
                if ("wheelDeltaX" in e) sX = -e.wheelDeltaX / 120;
                if ("axis" in e && e.axis === e.HORIZONTAL_AXIS) {
                    sX = sY;
                    sY = 0;
                }
                pX = sX * PIXEL_STEP;
                pY = sY * PIXEL_STEP;
                if ("deltaY" in e) pY = e.deltaY;
                if ("deltaX" in e) pX = e.deltaX;
                if (e.shiftKey && !pX) {
                    pX = pY;
                    pY = 0;
                }
                if ((pX || pY) && e.deltaMode) if (e.deltaMode === 1) {
                    pX *= LINE_HEIGHT;
                    pY *= LINE_HEIGHT;
                } else {
                    pX *= PAGE_HEIGHT;
                    pY *= PAGE_HEIGHT;
                }
                if (pX && !sX) sX = pX < 1 ? -1 : 1;
                if (pY && !sY) sY = pY < 1 ? -1 : 1;
                return {
                    spinX: sX,
                    spinY: sY,
                    pixelX: pX,
                    pixelY: pY
                };
            }
            function handleMouseEnter() {
                if (!swiper.enabled) return;
                swiper.mouseEntered = true;
            }
            function handleMouseLeave() {
                if (!swiper.enabled) return;
                swiper.mouseEntered = false;
            }
            function animateSlider(newEvent) {
                if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) return false;
                if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) return false;
                if (newEvent.delta >= 6 && now() - lastScrollTime < 60) return true;
                if (newEvent.direction < 0) {
                    if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
                        swiper.slideNext();
                        emit("scroll", newEvent.raw);
                    }
                } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
                    swiper.slidePrev();
                    emit("scroll", newEvent.raw);
                }
                lastScrollTime = (new window.Date).getTime();
                return false;
            }
            function releaseScroll(newEvent) {
                const params = swiper.params.mousewheel;
                if (newEvent.direction < 0) {
                    if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) return true;
                } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) return true;
                return false;
            }
            function handle(event) {
                let e = event;
                let disableParentSwiper = true;
                if (!swiper.enabled) return;
                if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;
                const params = swiper.params.mousewheel;
                if (swiper.params.cssMode) e.preventDefault();
                let targetEl = swiper.el;
                if (swiper.params.mousewheel.eventsTarget !== "container") targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
                const targetElContainsTarget = targetEl && targetEl.contains(e.target);
                if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;
                if (e.originalEvent) e = e.originalEvent;
                let delta = 0;
                const rtlFactor = swiper.rtlTranslate ? -1 : 1;
                const data = normalize(e);
                if (params.forceToAxis) if (swiper.isHorizontal()) if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor; else return true; else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY; else return true; else delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
                if (delta === 0) return true;
                if (params.invert) delta = -delta;
                let positions = swiper.getTranslate() + delta * params.sensitivity;
                if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
                if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();
                disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
                if (disableParentSwiper && swiper.params.nested) e.stopPropagation();
                if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
                    const newEvent = {
                        time: now(),
                        delta: Math.abs(delta),
                        direction: Math.sign(delta),
                        raw: event
                    };
                    if (recentWheelEvents.length >= 2) recentWheelEvents.shift();
                    const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
                    recentWheelEvents.push(newEvent);
                    if (prevEvent) {
                        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) animateSlider(newEvent);
                    } else animateSlider(newEvent);
                    if (releaseScroll(newEvent)) return true;
                } else {
                    const newEvent = {
                        time: now(),
                        delta: Math.abs(delta),
                        direction: Math.sign(delta)
                    };
                    const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;
                    if (!ignoreWheelEvents) {
                        lastEventBeforeSnap = void 0;
                        let position = swiper.getTranslate() + delta * params.sensitivity;
                        const wasBeginning = swiper.isBeginning;
                        const wasEnd = swiper.isEnd;
                        if (position >= swiper.minTranslate()) position = swiper.minTranslate();
                        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
                        swiper.setTransition(0);
                        swiper.setTranslate(position);
                        swiper.updateProgress();
                        swiper.updateActiveIndex();
                        swiper.updateSlidesClasses();
                        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) swiper.updateSlidesClasses();
                        if (swiper.params.loop) swiper.loopFix({
                            direction: newEvent.direction < 0 ? "next" : "prev",
                            byMousewheel: true
                        });
                        if (swiper.params.freeMode.sticky) {
                            clearTimeout(timeout);
                            timeout = void 0;
                            if (recentWheelEvents.length >= 15) recentWheelEvents.shift();
                            const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
                            const firstEvent = recentWheelEvents[0];
                            recentWheelEvents.push(newEvent);
                            if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) recentWheelEvents.splice(0); else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
                                const snapToThreshold = delta > 0 ? .8 : .2;
                                lastEventBeforeSnap = newEvent;
                                recentWheelEvents.splice(0);
                                timeout = utils_nextTick(() => {
                                    if (swiper.destroyed || !swiper.params) return;
                                    swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);
                                }, 0);
                            }
                            if (!timeout) timeout = utils_nextTick(() => {
                                if (swiper.destroyed || !swiper.params) return;
                                const snapToThreshold = .5;
                                lastEventBeforeSnap = newEvent;
                                recentWheelEvents.splice(0);
                                swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);
                            }, 500);
                        }
                        if (!ignoreWheelEvents) emit("scroll", e);
                        if (swiper.params.autoplay && swiper.params.autoplay.disableOnInteraction) swiper.autoplay.stop();
                        if (params.releaseOnEdges && (position === swiper.minTranslate() || position === swiper.maxTranslate())) return true;
                    }
                }
                if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
                return false;
            }
            function events(method) {
                let targetEl = swiper.el;
                if (swiper.params.mousewheel.eventsTarget !== "container") targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
                targetEl[method]("mouseenter", handleMouseEnter);
                targetEl[method]("mouseleave", handleMouseLeave);
                targetEl[method]("wheel", handle);
            }
            function enable() {
                if (swiper.params.cssMode) {
                    swiper.wrapperEl.removeEventListener("wheel", handle);
                    return true;
                }
                if (swiper.mousewheel.enabled) return false;
                events("addEventListener");
                swiper.mousewheel.enabled = true;
                return true;
            }
            function disable() {
                if (swiper.params.cssMode) {
                    swiper.wrapperEl.addEventListener(event, handle);
                    return true;
                }
                if (!swiper.mousewheel.enabled) return false;
                events("removeEventListener");
                swiper.mousewheel.enabled = false;
                return true;
            }
            on("init", () => {
                if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) disable();
                if (swiper.params.mousewheel.enabled) enable();
            });
            on("destroy", () => {
                if (swiper.params.cssMode) enable();
                if (swiper.mousewheel.enabled) disable();
            });
            Object.assign(swiper.mousewheel, {
                enable,
                disable
            });
        }
        function create_element_if_not_defined_createElementIfNotDefined(swiper, originalParams, params, checkProps) {
            if (swiper.params.createElements) Object.keys(checkProps).forEach(key => {
                if (!params[key] && params.auto === true) {
                    let element = utils_elementChildren(swiper.el, `.${checkProps[key]}`)[0];
                    if (!element) {
                        element = utils_createElement("div", checkProps[key]);
                        element.className = checkProps[key];
                        swiper.el.append(element);
                    }
                    params[key] = element;
                    originalParams[key] = element;
                }
            });
            return params;
        }
        function classes_to_selector_classesToSelector(classes) {
            if (classes === void 0) classes = "";
            return `.${classes.trim().replace(/([\.:!+\/()[\]])/g, "\\$1").replace(/ /g, ".")}`;
        }
        function Pagination(_ref) {
            let {swiper, extendParams, on, emit} = _ref;
            const pfx = "swiper-pagination";
            extendParams({
                pagination: {
                    el: null,
                    bulletElement: "span",
                    clickable: false,
                    hideOnClick: false,
                    renderBullet: null,
                    renderProgressbar: null,
                    renderFraction: null,
                    renderCustom: null,
                    progressbarOpposite: false,
                    type: "bullets",
                    dynamicBullets: false,
                    dynamicMainBullets: 1,
                    formatFractionCurrent: number => number,
                    formatFractionTotal: number => number,
                    bulletClass: `${pfx}-bullet`,
                    bulletActiveClass: `${pfx}-bullet-active`,
                    modifierClass: `${pfx}-`,
                    currentClass: `${pfx}-current`,
                    totalClass: `${pfx}-total`,
                    hiddenClass: `${pfx}-hidden`,
                    progressbarFillClass: `${pfx}-progressbar-fill`,
                    progressbarOppositeClass: `${pfx}-progressbar-opposite`,
                    clickableClass: `${pfx}-clickable`,
                    lockClass: `${pfx}-lock`,
                    horizontalClass: `${pfx}-horizontal`,
                    verticalClass: `${pfx}-vertical`,
                    paginationDisabledClass: `${pfx}-disabled`
                }
            });
            swiper.pagination = {
                el: null,
                bullets: []
            };
            let bulletSize;
            let dynamicBulletIndex = 0;
            function isPaginationDisabled() {
                return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;
            }
            function setSideBullets(bulletEl, position) {
                const {bulletActiveClass} = swiper.params.pagination;
                if (!bulletEl) return;
                bulletEl = bulletEl[`${position === "prev" ? "previous" : "next"}ElementSibling`];
                if (bulletEl) {
                    bulletEl.classList.add(`${bulletActiveClass}-${position}`);
                    bulletEl = bulletEl[`${position === "prev" ? "previous" : "next"}ElementSibling`];
                    if (bulletEl) bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);
                }
            }
            function getMoveDirection(prevIndex, nextIndex, length) {
                prevIndex %= length;
                nextIndex %= length;
                if (nextIndex === prevIndex + 1) return "next"; else if (nextIndex === prevIndex - 1) return "previous";
                return;
            }
            function onBulletClick(e) {
                const bulletEl = e.target.closest(classes_to_selector_classesToSelector(swiper.params.pagination.bulletClass));
                if (!bulletEl) return;
                e.preventDefault();
                const index = utils_elementIndex(bulletEl) * swiper.params.slidesPerGroup;
                if (swiper.params.loop) {
                    if (swiper.realIndex === index) return;
                    const moveDirection = getMoveDirection(swiper.realIndex, index, swiper.slides.length);
                    if (moveDirection === "next") swiper.slideNext(); else if (moveDirection === "previous") swiper.slidePrev(); else swiper.slideToLoop(index);
                } else swiper.slideTo(index);
            }
            function update() {
                const rtl = swiper.rtl;
                const params = swiper.params.pagination;
                if (isPaginationDisabled()) return;
                let el = swiper.pagination.el;
                el = utils_makeElementsArray(el);
                let current;
                let previousIndex;
                const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
                const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
                if (swiper.params.loop) {
                    previousIndex = swiper.previousRealIndex || 0;
                    current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;
                } else if (typeof swiper.snapIndex !== "undefined") {
                    current = swiper.snapIndex;
                    previousIndex = swiper.previousSnapIndex;
                } else {
                    previousIndex = swiper.previousIndex || 0;
                    current = swiper.activeIndex || 0;
                }
                if (params.type === "bullets" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
                    const bullets = swiper.pagination.bullets;
                    let firstIndex;
                    let lastIndex;
                    let midIndex;
                    if (params.dynamicBullets) {
                        bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? "width" : "height", true);
                        el.forEach(subEl => {
                            subEl.style[swiper.isHorizontal() ? "width" : "height"] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;
                        });
                        if (params.dynamicMainBullets > 1 && previousIndex !== void 0) {
                            dynamicBulletIndex += current - (previousIndex || 0);
                            if (dynamicBulletIndex > params.dynamicMainBullets - 1) dynamicBulletIndex = params.dynamicMainBullets - 1; else if (dynamicBulletIndex < 0) dynamicBulletIndex = 0;
                        }
                        firstIndex = Math.max(current - dynamicBulletIndex, 0);
                        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
                        midIndex = (lastIndex + firstIndex) / 2;
                    }
                    bullets.forEach(bulletEl => {
                        const classesToRemove = [ ...[ "", "-next", "-next-next", "-prev", "-prev-prev", "-main" ].map(suffix => `${params.bulletActiveClass}${suffix}`) ].map(s => typeof s === "string" && s.includes(" ") ? s.split(" ") : s).flat();
                        bulletEl.classList.remove(...classesToRemove);
                    });
                    if (el.length > 1) bullets.forEach(bullet => {
                        const bulletIndex = utils_elementIndex(bullet);
                        if (bulletIndex === current) bullet.classList.add(...params.bulletActiveClass.split(" ")); else if (swiper.isElement) bullet.setAttribute("part", "bullet");
                        if (params.dynamicBullets) {
                            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) bullet.classList.add(...`${params.bulletActiveClass}-main`.split(" "));
                            if (bulletIndex === firstIndex) setSideBullets(bullet, "prev");
                            if (bulletIndex === lastIndex) setSideBullets(bullet, "next");
                        }
                    }); else {
                        const bullet = bullets[current];
                        if (bullet) bullet.classList.add(...params.bulletActiveClass.split(" "));
                        if (swiper.isElement) bullets.forEach((bulletEl, bulletIndex) => {
                            bulletEl.setAttribute("part", bulletIndex === current ? "bullet-active" : "bullet");
                        });
                        if (params.dynamicBullets) {
                            const firstDisplayedBullet = bullets[firstIndex];
                            const lastDisplayedBullet = bullets[lastIndex];
                            for (let i = firstIndex; i <= lastIndex; i += 1) if (bullets[i]) bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(" "));
                            setSideBullets(firstDisplayedBullet, "prev");
                            setSideBullets(lastDisplayedBullet, "next");
                        }
                    }
                    if (params.dynamicBullets) {
                        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
                        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
                        const offsetProp = rtl ? "right" : "left";
                        bullets.forEach(bullet => {
                            bullet.style[swiper.isHorizontal() ? offsetProp : "top"] = `${bulletsOffset}px`;
                        });
                    }
                }
                el.forEach((subEl, subElIndex) => {
                    if (params.type === "fraction") {
                        subEl.querySelectorAll(classes_to_selector_classesToSelector(params.currentClass)).forEach(fractionEl => {
                            fractionEl.textContent = params.formatFractionCurrent(current + 1);
                        });
                        subEl.querySelectorAll(classes_to_selector_classesToSelector(params.totalClass)).forEach(totalEl => {
                            totalEl.textContent = params.formatFractionTotal(total);
                        });
                    }
                    if (params.type === "progressbar") {
                        let progressbarDirection;
                        if (params.progressbarOpposite) progressbarDirection = swiper.isHorizontal() ? "vertical" : "horizontal"; else progressbarDirection = swiper.isHorizontal() ? "horizontal" : "vertical";
                        const scale = (current + 1) / total;
                        let scaleX = 1;
                        let scaleY = 1;
                        if (progressbarDirection === "horizontal") scaleX = scale; else scaleY = scale;
                        subEl.querySelectorAll(classes_to_selector_classesToSelector(params.progressbarFillClass)).forEach(progressEl => {
                            progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;
                            progressEl.style.transitionDuration = `${swiper.params.speed}ms`;
                        });
                    }
                    if (params.type === "custom" && params.renderCustom) {
                        utils_setInnerHTML(subEl, params.renderCustom(swiper, current + 1, total));
                        if (subElIndex === 0) emit("paginationRender", subEl);
                    } else {
                        if (subElIndex === 0) emit("paginationRender", subEl);
                        emit("paginationUpdate", subEl);
                    }
                    if (swiper.params.watchOverflow && swiper.enabled) subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
                });
            }
            function render() {
                const params = swiper.params.pagination;
                if (isPaginationDisabled()) return;
                const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.grid && swiper.params.grid.rows > 1 ? swiper.slides.length / Math.ceil(swiper.params.grid.rows) : swiper.slides.length;
                let el = swiper.pagination.el;
                el = utils_makeElementsArray(el);
                let paginationHTML = "";
                if (params.type === "bullets") {
                    let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
                    if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) numberOfBullets = slidesLength;
                    for (let i = 0; i < numberOfBullets; i += 1) if (params.renderBullet) paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass); else paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part="bullet"' : ""} class="${params.bulletClass}"></${params.bulletElement}>`;
                }
                if (params.type === "fraction") if (params.renderFraction) paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass); else paginationHTML = `<span class="${params.currentClass}"></span>` + " / " + `<span class="${params.totalClass}"></span>`;
                if (params.type === "progressbar") if (params.renderProgressbar) paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass); else paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
                swiper.pagination.bullets = [];
                el.forEach(subEl => {
                    if (params.type !== "custom") utils_setInnerHTML(subEl, paginationHTML || "");
                    if (params.type === "bullets") swiper.pagination.bullets.push(...subEl.querySelectorAll(classes_to_selector_classesToSelector(params.bulletClass)));
                });
                if (params.type !== "custom") emit("paginationRender", el[0]);
            }
            function init() {
                swiper.params.pagination = create_element_if_not_defined_createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
                    el: "swiper-pagination"
                });
                const params = swiper.params.pagination;
                if (!params.el) return;
                let el;
                if (typeof params.el === "string" && swiper.isElement) el = swiper.el.querySelector(params.el);
                if (!el && typeof params.el === "string") el = [ ...document.querySelectorAll(params.el) ];
                if (!el) el = params.el;
                if (!el || el.length === 0) return;
                if (swiper.params.uniqueNavElements && typeof params.el === "string" && Array.isArray(el) && el.length > 1) {
                    el = [ ...swiper.el.querySelectorAll(params.el) ];
                    if (el.length > 1) el = el.find(subEl => {
                        if (utils_elementParents(subEl, ".swiper")[0] !== swiper.el) return false;
                        return true;
                    });
                }
                if (Array.isArray(el) && el.length === 1) el = el[0];
                Object.assign(swiper.pagination, {
                    el
                });
                el = utils_makeElementsArray(el);
                el.forEach(subEl => {
                    if (params.type === "bullets" && params.clickable) subEl.classList.add(...(params.clickableClass || "").split(" "));
                    subEl.classList.add(params.modifierClass + params.type);
                    subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                    if (params.type === "bullets" && params.dynamicBullets) {
                        subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);
                        dynamicBulletIndex = 0;
                        if (params.dynamicMainBullets < 1) params.dynamicMainBullets = 1;
                    }
                    if (params.type === "progressbar" && params.progressbarOpposite) subEl.classList.add(params.progressbarOppositeClass);
                    if (params.clickable) subEl.addEventListener("click", onBulletClick);
                    if (!swiper.enabled) subEl.classList.add(params.lockClass);
                });
            }
            function destroy() {
                const params = swiper.params.pagination;
                if (isPaginationDisabled()) return;
                let el = swiper.pagination.el;
                if (el) {
                    el = utils_makeElementsArray(el);
                    el.forEach(subEl => {
                        subEl.classList.remove(params.hiddenClass);
                        subEl.classList.remove(params.modifierClass + params.type);
                        subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                        if (params.clickable) {
                            subEl.classList.remove(...(params.clickableClass || "").split(" "));
                            subEl.removeEventListener("click", onBulletClick);
                        }
                    });
                }
                if (swiper.pagination.bullets) swiper.pagination.bullets.forEach(subEl => subEl.classList.remove(...params.bulletActiveClass.split(" ")));
            }
            on("changeDirection", () => {
                if (!swiper.pagination || !swiper.pagination.el) return;
                const params = swiper.params.pagination;
                let {el} = swiper.pagination;
                el = utils_makeElementsArray(el);
                el.forEach(subEl => {
                    subEl.classList.remove(params.horizontalClass, params.verticalClass);
                    subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                });
            });
            on("init", () => {
                if (swiper.params.pagination.enabled === false) disable(); else {
                    init();
                    render();
                    update();
                }
            });
            on("activeIndexChange", () => {
                if (typeof swiper.snapIndex === "undefined") update();
            });
            on("snapIndexChange", () => {
                update();
            });
            on("snapGridLengthChange", () => {
                render();
                update();
            });
            on("destroy", () => {
                destroy();
            });
            on("enable disable", () => {
                let {el} = swiper.pagination;
                if (el) {
                    el = utils_makeElementsArray(el);
                    el.forEach(subEl => subEl.classList[swiper.enabled ? "remove" : "add"](swiper.params.pagination.lockClass));
                }
            });
            on("lock unlock", () => {
                update();
            });
            on("click", (_s, e) => {
                const targetEl = e.target;
                const el = utils_makeElementsArray(swiper.pagination.el);
                if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {
                    if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
                    const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);
                    if (isHidden === true) emit("paginationShow"); else emit("paginationHide");
                    el.forEach(subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass));
                }
            });
            const enable = () => {
                swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);
                let {el} = swiper.pagination;
                if (el) {
                    el = utils_makeElementsArray(el);
                    el.forEach(subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));
                }
                init();
                render();
                update();
            };
            const disable = () => {
                swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);
                let {el} = swiper.pagination;
                if (el) {
                    el = utils_makeElementsArray(el);
                    el.forEach(subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));
                }
                destroy();
            };
            Object.assign(swiper.pagination, {
                enable,
                disable,
                render,
                update,
                init,
                destroy
            });
        }
        function Autoplay(_ref) {
            let {swiper, extendParams, on, emit, params} = _ref;
            swiper.autoplay = {
                running: false,
                paused: false,
                timeLeft: 0
            };
            extendParams({
                autoplay: {
                    enabled: false,
                    delay: 3e3,
                    waitForTransition: true,
                    disableOnInteraction: false,
                    stopOnLastSlide: false,
                    reverseDirection: false,
                    pauseOnMouseEnter: false
                }
            });
            let timeout;
            let raf;
            let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3e3;
            let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3e3;
            let autoplayTimeLeft;
            let autoplayStartTime = (new Date).getTime();
            let wasPaused;
            let isTouched;
            let pausedByTouch;
            let touchStartTimeout;
            let slideChanged;
            let pausedByInteraction;
            let pausedByPointerEnter;
            function onTransitionEnd(e) {
                if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;
                if (e.target !== swiper.wrapperEl) return;
                swiper.wrapperEl.removeEventListener("transitionend", onTransitionEnd);
                if (pausedByPointerEnter || e.detail && e.detail.bySwiperTouchMove) return;
                resume();
            }
            const calcTimeLeft = () => {
                if (swiper.destroyed || !swiper.autoplay.running) return;
                if (swiper.autoplay.paused) wasPaused = true; else if (wasPaused) {
                    autoplayDelayCurrent = autoplayTimeLeft;
                    wasPaused = false;
                }
                const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - (new Date).getTime();
                swiper.autoplay.timeLeft = timeLeft;
                emit("autoplayTimeLeft", timeLeft, timeLeft / autoplayDelayTotal);
                raf = requestAnimationFrame(() => {
                    calcTimeLeft();
                });
            };
            const getSlideDelay = () => {
                let activeSlideEl;
                if (swiper.virtual && swiper.params.virtual.enabled) activeSlideEl = swiper.slides.find(slideEl => slideEl.classList.contains("swiper-slide-active")); else activeSlideEl = swiper.slides[swiper.activeIndex];
                if (!activeSlideEl) return;
                const currentSlideDelay = parseInt(activeSlideEl.getAttribute("data-swiper-autoplay"), 10);
                return currentSlideDelay;
            };
            const run = delayForce => {
                if (swiper.destroyed || !swiper.autoplay.running) return;
                cancelAnimationFrame(raf);
                calcTimeLeft();
                let delay = typeof delayForce === "undefined" ? swiper.params.autoplay.delay : delayForce;
                autoplayDelayTotal = swiper.params.autoplay.delay;
                autoplayDelayCurrent = swiper.params.autoplay.delay;
                const currentSlideDelay = getSlideDelay();
                if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === "undefined") {
                    delay = currentSlideDelay;
                    autoplayDelayTotal = currentSlideDelay;
                    autoplayDelayCurrent = currentSlideDelay;
                }
                autoplayTimeLeft = delay;
                const speed = swiper.params.speed;
                const proceed = () => {
                    if (!swiper || swiper.destroyed) return;
                    if (swiper.params.autoplay.reverseDirection) {
                        if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {
                            swiper.slidePrev(speed, true, true);
                            emit("autoplay");
                        } else if (!swiper.params.autoplay.stopOnLastSlide) {
                            swiper.slideTo(swiper.slides.length - 1, speed, true, true);
                            emit("autoplay");
                        }
                    } else if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {
                        swiper.slideNext(speed, true, true);
                        emit("autoplay");
                    } else if (!swiper.params.autoplay.stopOnLastSlide) {
                        swiper.slideTo(0, speed, true, true);
                        emit("autoplay");
                    }
                    if (swiper.params.cssMode) {
                        autoplayStartTime = (new Date).getTime();
                        requestAnimationFrame(() => {
                            run();
                        });
                    }
                };
                if (delay > 0) {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => {
                        proceed();
                    }, delay);
                } else requestAnimationFrame(() => {
                    proceed();
                });
                return delay;
            };
            const start = () => {
                autoplayStartTime = (new Date).getTime();
                swiper.autoplay.running = true;
                run();
                emit("autoplayStart");
            };
            const stop = () => {
                swiper.autoplay.running = false;
                clearTimeout(timeout);
                cancelAnimationFrame(raf);
                emit("autoplayStop");
            };
            const pause = (internal, reset) => {
                if (swiper.destroyed || !swiper.autoplay.running) return;
                clearTimeout(timeout);
                if (!internal) pausedByInteraction = true;
                const proceed = () => {
                    emit("autoplayPause");
                    if (swiper.params.autoplay.waitForTransition) swiper.wrapperEl.addEventListener("transitionend", onTransitionEnd); else resume();
                };
                swiper.autoplay.paused = true;
                if (reset) {
                    if (slideChanged) autoplayTimeLeft = swiper.params.autoplay.delay;
                    slideChanged = false;
                    proceed();
                    return;
                }
                const delay = autoplayTimeLeft || swiper.params.autoplay.delay;
                autoplayTimeLeft = delay - ((new Date).getTime() - autoplayStartTime);
                if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;
                if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;
                proceed();
            };
            const resume = () => {
                if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;
                autoplayStartTime = (new Date).getTime();
                if (pausedByInteraction) {
                    pausedByInteraction = false;
                    run(autoplayTimeLeft);
                } else run();
                swiper.autoplay.paused = false;
                emit("autoplayResume");
            };
            const onVisibilityChange = () => {
                if (swiper.destroyed || !swiper.autoplay.running) return;
                const document = ssr_window_esm_getDocument();
                if (document.visibilityState === "hidden") {
                    pausedByInteraction = true;
                    pause(true);
                }
                if (document.visibilityState === "visible") resume();
            };
            const onPointerEnter = e => {
                if (e.pointerType !== "mouse") return;
                pausedByInteraction = true;
                pausedByPointerEnter = true;
                if (swiper.animating || swiper.autoplay.paused) return;
                pause(true);
            };
            const onPointerLeave = e => {
                if (e.pointerType !== "mouse") return;
                pausedByPointerEnter = false;
                if (swiper.autoplay.paused) resume();
            };
            const attachMouseEvents = () => {
                if (swiper.params.autoplay.pauseOnMouseEnter) {
                    swiper.el.addEventListener("pointerenter", onPointerEnter);
                    swiper.el.addEventListener("pointerleave", onPointerLeave);
                }
            };
            const detachMouseEvents = () => {
                if (swiper.el && typeof swiper.el !== "string") {
                    swiper.el.removeEventListener("pointerenter", onPointerEnter);
                    swiper.el.removeEventListener("pointerleave", onPointerLeave);
                }
            };
            const attachDocumentEvents = () => {
                const document = ssr_window_esm_getDocument();
                document.addEventListener("visibilitychange", onVisibilityChange);
            };
            const detachDocumentEvents = () => {
                const document = ssr_window_esm_getDocument();
                document.removeEventListener("visibilitychange", onVisibilityChange);
            };
            on("init", () => {
                if (swiper.params.autoplay.enabled) {
                    attachMouseEvents();
                    attachDocumentEvents();
                    start();
                }
            });
            on("destroy", () => {
                detachMouseEvents();
                detachDocumentEvents();
                if (swiper.autoplay.running) stop();
            });
            on("_freeModeStaticRelease", () => {
                if (pausedByTouch || pausedByInteraction) resume();
            });
            on("_freeModeNoMomentumRelease", () => {
                if (!swiper.params.autoplay.disableOnInteraction) pause(true, true); else stop();
            });
            on("beforeTransitionStart", (_s, speed, internal) => {
                if (swiper.destroyed || !swiper.autoplay.running) return;
                if (internal || !swiper.params.autoplay.disableOnInteraction) pause(true, true); else stop();
            });
            on("sliderFirstMove", () => {
                if (swiper.destroyed || !swiper.autoplay.running) return;
                if (swiper.params.autoplay.disableOnInteraction) {
                    stop();
                    return;
                }
                isTouched = true;
                pausedByTouch = false;
                pausedByInteraction = false;
                touchStartTimeout = setTimeout(() => {
                    pausedByInteraction = true;
                    pausedByTouch = true;
                    pause(true);
                }, 200);
            });
            on("touchEnd", () => {
                if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;
                clearTimeout(touchStartTimeout);
                clearTimeout(timeout);
                if (swiper.params.autoplay.disableOnInteraction) {
                    pausedByTouch = false;
                    isTouched = false;
                    return;
                }
                if (pausedByTouch && swiper.params.cssMode) resume();
                pausedByTouch = false;
                isTouched = false;
            });
            on("slideChange", () => {
                if (swiper.destroyed || !swiper.autoplay.running) return;
                slideChanged = true;
            });
            Object.assign(swiper.autoplay, {
                start,
                stop,
                pause,
                resume
            });
        }
        function freeMode(_ref) {
            let {swiper, extendParams, emit, once} = _ref;
            extendParams({
                freeMode: {
                    enabled: false,
                    momentum: true,
                    momentumRatio: 1,
                    momentumBounce: true,
                    momentumBounceRatio: 1,
                    momentumVelocityRatio: 1,
                    sticky: false,
                    minimumVelocity: .02
                }
            });
            function onTouchStart() {
                if (swiper.params.cssMode) return;
                const translate = swiper.getTranslate();
                swiper.setTranslate(translate);
                swiper.setTransition(0);
                swiper.touchEventsData.velocities.length = 0;
                swiper.freeMode.onTouchEnd({
                    currentPos: swiper.rtl ? swiper.translate : -swiper.translate
                });
            }
            function onTouchMove() {
                if (swiper.params.cssMode) return;
                const {touchEventsData: data, touches} = swiper;
                if (data.velocities.length === 0) data.velocities.push({
                    position: touches[swiper.isHorizontal() ? "startX" : "startY"],
                    time: data.touchStartTime
                });
                data.velocities.push({
                    position: touches[swiper.isHorizontal() ? "currentX" : "currentY"],
                    time: now()
                });
            }
            function onTouchEnd(_ref2) {
                let {currentPos} = _ref2;
                if (swiper.params.cssMode) return;
                const {params, wrapperEl, rtlTranslate: rtl, snapGrid, touchEventsData: data} = swiper;
                const touchEndTime = now();
                const timeDiff = touchEndTime - data.touchStartTime;
                if (currentPos < -swiper.minTranslate()) {
                    swiper.slideTo(swiper.activeIndex);
                    return;
                }
                if (currentPos > -swiper.maxTranslate()) {
                    if (swiper.slides.length < snapGrid.length) swiper.slideTo(snapGrid.length - 1); else swiper.slideTo(swiper.slides.length - 1);
                    return;
                }
                if (params.freeMode.momentum) {
                    if (data.velocities.length > 1) {
                        const lastMoveEvent = data.velocities.pop();
                        const velocityEvent = data.velocities.pop();
                        const distance = lastMoveEvent.position - velocityEvent.position;
                        const time = lastMoveEvent.time - velocityEvent.time;
                        swiper.velocity = distance / time;
                        swiper.velocity /= 2;
                        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) swiper.velocity = 0;
                        if (time > 150 || now() - lastMoveEvent.time > 300) swiper.velocity = 0;
                    } else swiper.velocity = 0;
                    swiper.velocity *= params.freeMode.momentumVelocityRatio;
                    data.velocities.length = 0;
                    let momentumDuration = 1e3 * params.freeMode.momentumRatio;
                    const momentumDistance = swiper.velocity * momentumDuration;
                    let newPosition = swiper.translate + momentumDistance;
                    if (rtl) newPosition = -newPosition;
                    let doBounce = false;
                    let afterBouncePosition;
                    const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
                    let needsLoopFix;
                    if (newPosition < swiper.maxTranslate()) {
                        if (params.freeMode.momentumBounce) {
                            if (newPosition + swiper.maxTranslate() < -bounceAmount) newPosition = swiper.maxTranslate() - bounceAmount;
                            afterBouncePosition = swiper.maxTranslate();
                            doBounce = true;
                            data.allowMomentumBounce = true;
                        } else newPosition = swiper.maxTranslate();
                        if (params.loop && params.centeredSlides) needsLoopFix = true;
                    } else if (newPosition > swiper.minTranslate()) {
                        if (params.freeMode.momentumBounce) {
                            if (newPosition - swiper.minTranslate() > bounceAmount) newPosition = swiper.minTranslate() + bounceAmount;
                            afterBouncePosition = swiper.minTranslate();
                            doBounce = true;
                            data.allowMomentumBounce = true;
                        } else newPosition = swiper.minTranslate();
                        if (params.loop && params.centeredSlides) needsLoopFix = true;
                    } else if (params.freeMode.sticky) {
                        let nextSlide;
                        for (let j = 0; j < snapGrid.length; j += 1) if (snapGrid[j] > -newPosition) {
                            nextSlide = j;
                            break;
                        }
                        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === "next") newPosition = snapGrid[nextSlide]; else newPosition = snapGrid[nextSlide - 1];
                        newPosition = -newPosition;
                    }
                    if (needsLoopFix) once("transitionEnd", () => {
                        swiper.loopFix();
                    });
                    if (swiper.velocity !== 0) {
                        if (rtl) momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity); else momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
                        if (params.freeMode.sticky) {
                            const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
                            const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
                            if (moveDistance < currentSlideSize) momentumDuration = params.speed; else if (moveDistance < 2 * currentSlideSize) momentumDuration = params.speed * 1.5; else momentumDuration = params.speed * 2.5;
                        }
                    } else if (params.freeMode.sticky) {
                        swiper.slideToClosest();
                        return;
                    }
                    if (params.freeMode.momentumBounce && doBounce) {
                        swiper.updateProgress(afterBouncePosition);
                        swiper.setTransition(momentumDuration);
                        swiper.setTranslate(newPosition);
                        swiper.transitionStart(true, swiper.swipeDirection);
                        swiper.animating = true;
                        utils_elementTransitionEnd(wrapperEl, () => {
                            if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
                            emit("momentumBounce");
                            swiper.setTransition(params.speed);
                            setTimeout(() => {
                                swiper.setTranslate(afterBouncePosition);
                                utils_elementTransitionEnd(wrapperEl, () => {
                                    if (!swiper || swiper.destroyed) return;
                                    swiper.transitionEnd();
                                });
                            }, 0);
                        });
                    } else if (swiper.velocity) {
                        emit("_freeModeNoMomentumRelease");
                        swiper.updateProgress(newPosition);
                        swiper.setTransition(momentumDuration);
                        swiper.setTranslate(newPosition);
                        swiper.transitionStart(true, swiper.swipeDirection);
                        if (!swiper.animating) {
                            swiper.animating = true;
                            utils_elementTransitionEnd(wrapperEl, () => {
                                if (!swiper || swiper.destroyed) return;
                                swiper.transitionEnd();
                            });
                        }
                    } else swiper.updateProgress(newPosition);
                    swiper.updateActiveIndex();
                    swiper.updateSlidesClasses();
                } else if (params.freeMode.sticky) {
                    swiper.slideToClosest();
                    return;
                } else if (params.freeMode) emit("_freeModeNoMomentumRelease");
                if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
                    emit("_freeModeStaticRelease");
                    swiper.updateProgress();
                    swiper.updateActiveIndex();
                    swiper.updateSlidesClasses();
                }
            }
            Object.assign(swiper, {
                freeMode: {
                    onTouchStart,
                    onTouchMove,
                    onTouchEnd
                }
            });
        }
        function effect_init_effectInit(params) {
            const {effect, swiper, on, setTranslate, setTransition, overwriteParams, perspective, recreateShadows, getEffectParams} = params;
            on("beforeInit", () => {
                if (swiper.params.effect !== effect) return;
                swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);
                if (perspective && perspective()) swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
                const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
                Object.assign(swiper.params, overwriteParamsResult);
                Object.assign(swiper.originalParams, overwriteParamsResult);
            });
            on("setTranslate _virtualUpdated", () => {
                if (swiper.params.effect !== effect) return;
                setTranslate();
            });
            on("setTransition", (_s, duration) => {
                if (swiper.params.effect !== effect) return;
                setTransition(duration);
            });
            on("transitionEnd", () => {
                if (swiper.params.effect !== effect) return;
                if (recreateShadows) {
                    if (!getEffectParams || !getEffectParams().slideShadows) return;
                    swiper.slides.forEach(slideEl => {
                        slideEl.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(shadowEl => shadowEl.remove());
                    });
                    recreateShadows();
                }
            });
            let requireUpdateOnVirtual;
            on("virtualUpdate", () => {
                if (swiper.params.effect !== effect) return;
                if (!swiper.slides.length) requireUpdateOnVirtual = true;
                requestAnimationFrame(() => {
                    if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
                        setTranslate();
                        requireUpdateOnVirtual = false;
                    }
                });
            });
        }
        function effect_target_effectTarget(effectParams, slideEl) {
            const transformEl = utils_getSlideTransformEl(slideEl);
            if (transformEl !== slideEl) {
                transformEl.style.backfaceVisibility = "hidden";
                transformEl.style["-webkit-backface-visibility"] = "hidden";
            }
            return transformEl;
        }
        function effect_virtual_transition_end_effectVirtualTransitionEnd(_ref) {
            let {swiper, duration, transformElements, allSlides} = _ref;
            const {activeIndex} = swiper;
            const getSlide = el => {
                if (!el.parentElement) {
                    const slide = swiper.slides.find(slideEl => slideEl.shadowRoot && slideEl.shadowRoot === el.parentNode);
                    return slide;
                }
                return el.parentElement;
            };
            if (swiper.params.virtualTranslate && duration !== 0) {
                let eventTriggered = false;
                let transitionEndTarget;
                if (allSlides) transitionEndTarget = transformElements; else transitionEndTarget = transformElements.filter(transformEl => {
                    const el = transformEl.classList.contains("swiper-slide-transform") ? getSlide(transformEl) : transformEl;
                    return swiper.getSlideIndex(el) === activeIndex;
                });
                transitionEndTarget.forEach(el => {
                    utils_elementTransitionEnd(el, () => {
                        if (eventTriggered) return;
                        if (!swiper || swiper.destroyed) return;
                        eventTriggered = true;
                        swiper.animating = false;
                        const evt = new window.CustomEvent("transitionend", {
                            bubbles: true,
                            cancelable: true
                        });
                        swiper.wrapperEl.dispatchEvent(evt);
                    });
                });
            }
        }
        function EffectFade(_ref) {
            let {swiper, extendParams, on} = _ref;
            extendParams({
                fadeEffect: {
                    crossFade: false
                }
            });
            const setTranslate = () => {
                const {slides} = swiper;
                const params = swiper.params.fadeEffect;
                for (let i = 0; i < slides.length; i += 1) {
                    const slideEl = swiper.slides[i];
                    const offset = slideEl.swiperSlideOffset;
                    let tx = -offset;
                    if (!swiper.params.virtualTranslate) tx -= swiper.translate;
                    let ty = 0;
                    if (!swiper.isHorizontal()) {
                        ty = tx;
                        tx = 0;
                    }
                    const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);
                    const targetEl = effect_target_effectTarget(params, slideEl);
                    targetEl.style.opacity = slideOpacity;
                    targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;
                }
            };
            const setTransition = duration => {
                const transformElements = swiper.slides.map(slideEl => utils_getSlideTransformEl(slideEl));
                transformElements.forEach(el => {
                    el.style.transitionDuration = `${duration}ms`;
                });
                effect_virtual_transition_end_effectVirtualTransitionEnd({
                    swiper,
                    duration,
                    transformElements,
                    allSlides: true
                });
            };
            effect_init_effectInit({
                effect: "fade",
                swiper,
                on,
                setTranslate,
                setTransition,
                overwriteParams: () => ({
                    slidesPerView: 1,
                    slidesPerGroup: 1,
                    watchSlidesProgress: true,
                    spaceBetween: 0,
                    virtualTranslate: !swiper.params.cssMode
                })
            });
        }
        const newsItems = [ {
            image: "img/news/image-01.webp",
            title: "igb live london",
            date: "July 1-4, 2025"
        }, {
            image: "img/news/image-02.webp",
            title: "SiGMA Euro-Med Malta",
            date: "September 1-4, 2025"
        }, {
            image: "img/news/image-03.webp",
            title: "affiliate world europe",
            date: "September 4-5, 2025"
        }, {
            image: "img/news/image-01.webp",
            title: "igb live london",
            date: "July 1-4, 2025"
        } ];
        const NewsSection = () => react.createElement("section", {
            id: "news",
            className: "news"
        }, react.createElement("div", {
            className: "news__container blur-1 blur-2"
        }, react.createElement("div", {
            className: "news__title h2"
        }, "lates NEWS & EVENTS"), react.createElement("div", {
            className: "news__text"
        }, "Book the meeting with us"), react.createElement(swiper_react_Swiper, {
            modules: [ Pagination, freeMode, Mousewheel, Autoplay ],
            observer: true,
            observeParents: true,
            slidesPerView: 1,
            spaceBetween: 16,
            speed: 800,
            pagination: {
                clickable: true
            },
            freeMode: {
                enabled: true,
                sticky: false,
                momentumBounce: false
            },
            mousewheel: {
                enabled: true,
                sensitivity: .2,
                forceToAxis: true
            },
            scrollbar: {
                draggable: true
            },
            autoplay: {
                delay: 5e3,
                disableOnInteraction: false,
                pauseOnMouseEnter: true
            },
            breakpoints: {
                0: {
                    freeMode: {
                        enabled: false,
                        sticky: true,
                        momentumBounce: false
                    }
                },
                768: {
                    slidesPerView: 2
                },
                992: {
                    slidesPerView: 3
                }
            }
        }, newsItems.map((item, index) => react.createElement(SwiperSlide, {
            key: index
        }, react.createElement(homepage_NewsSlide, item))))));
        const homepage_NewsSection = NewsSection;
        function useFormValidate(initialValues) {
            const [formData, setFormData] = (0, react.useState)(initialValues);
            const [errors, setErrors] = (0, react.useState)({});
            const validateInput = (name, value) => {
                let error = "";
                if (name === "firstName") {
                    if (!/[a-zA-Z--]{2,}$/.test(value.trim())) error = "Enter a valid name (min 2 letters)";
                } else if (name === "email") {
                    if (!/^[^\s@]+@[^\s@]+\.[^\s@]{2,}$/.test(value.trim())) error = "Enter a valid e-mail";
                } else if (name === "message") {
                    if (value.trim().length < 10) error = "Message must be at least 10 characters";
                } else if (name === "agree") if (!value) error = "You must agree to continue";
                return error;
            };
            const addError = (name, message) => {
                setErrors(prev => ({
                    ...prev,
                    [name]: message
                }));
            };
            const removeError = name => {
                setErrors(prev => {
                    const newErrors = {
                        ...prev
                    };
                    delete newErrors[name];
                    return newErrors;
                });
            };
            const handleChange = e => {
                const {name, type, value, checked} = e.target;
                const newValue = type === "checkbox" ? checked : value;
                setFormData(prev => ({
                    ...prev,
                    [name]: newValue
                }));
                if (errors[name]) {
                    const error = validateInput(name, newValue);
                    if (error) addError(name, error); else removeError(name);
                }
            };
            const handleSubmit = callback => e => {
                e.preventDefault();
                let newErrors = {};
                Object.entries(formData).forEach(([name, value]) => {
                    const error = validateInput(name, value);
                    if (error) newErrors[name] = error;
                });
                if (Object.keys(newErrors).length > 0) setErrors(newErrors); else {
                    setErrors({});
                    callback(formData);
                    setFormData(initialValues);
                }
            };
            return {
                formData,
                errors,
                handleChange,
                handleSubmit
            };
        }
        const FormSection = () => {
            const {formData, errors, handleChange, handleSubmit} = useFormValidate({
                firstName: "",
                email: "",
                message: "",
                agree: true
            });
            const submitForm = data => {
                console.log("Submitting the form:", data);
            };
            return react.createElement("section", {
                id: "contacts",
                className: "form-block"
            }, react.createElement("div", {
                className: "form-block__container"
            }, react.createElement("div", {
                className: "form-block__content"
            }, react.createElement("div", {
                className: "form-block__top"
            }, react.createElement("div", {
                className: "form-block__title h2"
            }, "LET'S FIND ", react.createElement("br", null), react.createElement("span", null, "THE BEST"), " SOLUTION FOR YOU"), react.createElement("div", {
                className: "form-block__text text-mob"
            }, "Contact us anytime  we handle each partnership individually.")), react.createElement("form", {
                className: "form-block__main form",
                onSubmit: handleSubmit(submitForm)
            }, react.createElement("div", {
                className: "form__wrapper"
            }, react.createElement("div", {
                className: "form__item"
            }, react.createElement("input", {
                type: "text",
                name: "firstName",
                className: `form__input ${errors.firstName ? "_form-error" : ""}`,
                placeholder: "Name",
                value: formData.firstName,
                onChange: handleChange
            }), errors.firstName && react.createElement("div", {
                className: "form__error"
            }, errors.firstName)), react.createElement("div", {
                className: "form__item"
            }, react.createElement("input", {
                type: "text",
                name: "email",
                className: `form__input ${errors.email ? "_form-error" : ""}`,
                placeholder: "E-mail",
                value: formData.email,
                onChange: handleChange
            }), errors.email && react.createElement("div", {
                className: "form__error"
            }, errors.email)), react.createElement("div", {
                className: "form__item"
            }, react.createElement("textarea", {
                name: "message",
                className: `form__input ${errors.message ? "_form-error" : ""}`,
                placeholder: "Message",
                value: formData.message,
                onChange: handleChange
            }), errors.message && react.createElement("div", {
                className: "form__error"
            }, errors.message))), react.createElement("div", {
                className: "form__checkbox checkbox"
            }, react.createElement("input", {
                className: "checkbox__input",
                type: "checkbox",
                id: "agree-checkbox",
                name: "agree",
                checked: formData.agree,
                onChange: handleChange
            }), react.createElement("label", {
                htmlFor: "agree-checkbox",
                className: "checkbox__label"
            }, react.createElement("span", null, "I understand that my personal data will be processed in accordance with the PikeBit")), errors.agree && react.createElement("div", {
                className: "form__error"
            }, errors.agree)), react.createElement("button", {
                type: "submit",
                className: "form__button"
            }, "Submit request"))), react.createElement("div", {
                className: "form-block__bg"
            })));
        };
        const homepage_FormSection = FormSection;
        function createDOMMotionComponentProxy(componentFactory) {
            if (typeof Proxy === "undefined") return componentFactory;
            const componentCache = new Map;
            const deprecatedFactoryFunction = (...args) => {
                if (false) ;
                return componentFactory(...args);
            };
            return new Proxy(deprecatedFactoryFunction, {
                get: (_target, key) => {
                    if (key === "create") return componentFactory;
                    if (!componentCache.has(key)) componentCache.set(key, componentFactory(key));
                    return componentCache.get(key);
                }
            });
        }
        function isAnimationControls(v) {
            return v !== null && typeof v === "object" && typeof v.start === "function";
        }
        function getValueState(visualElement) {
            const state = [ {}, {} ];
            visualElement?.values.forEach((value, key) => {
                state[0][key] = value.get();
                state[1][key] = value.getVelocity();
            });
            return state;
        }
        function resolveVariantFromProps(props, definition, custom, visualElement) {
            if (typeof definition === "function") {
                const [current, velocity] = getValueState(visualElement);
                definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
            }
            if (typeof definition === "string") definition = props.variants && props.variants[definition];
            if (typeof definition === "function") {
                const [current, velocity] = getValueState(visualElement);
                definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
            }
            return definition;
        }
        function resolveVariant(visualElement, definition, custom) {
            const props = visualElement.getProps();
            return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, visualElement);
        }
        function getValueTransition(transition, key) {
            return transition?.[key] ?? transition?.["default"] ?? transition;
        }
        const noop = any => any;
        const MotionGlobalConfig = {};
        const stepsOrder = [ "setup", "read", "resolveKeyframes", "preUpdate", "update", "preRender", "render", "postRender" ];
        const statsBuffer = {
            value: null,
            addProjectionMetrics: null
        };
        function createRenderStep(runNextFrame, stepName) {
            let thisFrame = new Set;
            let nextFrame = new Set;
            let isProcessing = false;
            let flushNextFrame = false;
            const toKeepAlive = new WeakSet;
            let latestFrameData = {
                delta: 0,
                timestamp: 0,
                isProcessing: false
            };
            let numCalls = 0;
            function triggerCallback(callback) {
                if (toKeepAlive.has(callback)) {
                    step.schedule(callback);
                    runNextFrame();
                }
                numCalls++;
                callback(latestFrameData);
            }
            const step = {
                schedule: (callback, keepAlive = false, immediate = false) => {
                    const addToCurrentFrame = immediate && isProcessing;
                    const queue = addToCurrentFrame ? thisFrame : nextFrame;
                    if (keepAlive) toKeepAlive.add(callback);
                    if (!queue.has(callback)) queue.add(callback);
                    return callback;
                },
                cancel: callback => {
                    nextFrame.delete(callback);
                    toKeepAlive.delete(callback);
                },
                process: frameData => {
                    latestFrameData = frameData;
                    if (isProcessing) {
                        flushNextFrame = true;
                        return;
                    }
                    isProcessing = true;
                    [thisFrame, nextFrame] = [ nextFrame, thisFrame ];
                    thisFrame.forEach(triggerCallback);
                    if (stepName && statsBuffer.value) statsBuffer.value.frameloop[stepName].push(numCalls);
                    numCalls = 0;
                    thisFrame.clear();
                    isProcessing = false;
                    if (flushNextFrame) {
                        flushNextFrame = false;
                        step.process(frameData);
                    }
                }
            };
            return step;
        }
        const maxElapsed = 40;
        function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
            let runNextFrame = false;
            let useDefaultElapsed = true;
            const state = {
                delta: 0,
                timestamp: 0,
                isProcessing: false
            };
            const flagRunNextFrame = () => runNextFrame = true;
            const steps = stepsOrder.reduce((acc, key) => {
                acc[key] = createRenderStep(flagRunNextFrame, allowKeepAlive ? key : void 0);
                return acc;
            }, {});
            const {setup, read, resolveKeyframes, preUpdate, update, preRender, render, postRender} = steps;
            const processBatch = () => {
                const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();
                runNextFrame = false;
                if (!MotionGlobalConfig.useManualTiming) state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
                state.timestamp = timestamp;
                state.isProcessing = true;
                setup.process(state);
                read.process(state);
                resolveKeyframes.process(state);
                preUpdate.process(state);
                update.process(state);
                preRender.process(state);
                render.process(state);
                postRender.process(state);
                state.isProcessing = false;
                if (runNextFrame && allowKeepAlive) {
                    useDefaultElapsed = false;
                    scheduleNextBatch(processBatch);
                }
            };
            const wake = () => {
                runNextFrame = true;
                useDefaultElapsed = true;
                if (!state.isProcessing) scheduleNextBatch(processBatch);
            };
            const schedule = stepsOrder.reduce((acc, key) => {
                const step = steps[key];
                acc[key] = (process, keepAlive = false, immediate = false) => {
                    if (!runNextFrame) wake();
                    return step.schedule(process, keepAlive, immediate);
                };
                return acc;
            }, {});
            const cancel = process => {
                for (let i = 0; i < stepsOrder.length; i++) steps[stepsOrder[i]].cancel(process);
            };
            return {
                schedule,
                cancel,
                state,
                steps
            };
        }
        const {schedule: frame_frame, cancel: cancelFrame, state: frameData, steps: frameSteps} = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop, true);
        const transformPropOrder = [ "transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY" ];
        const transformProps = (() => new Set(transformPropOrder))();
        const positionalKeys = new Set([ "width", "height", "top", "left", "right", "bottom", ...transformPropOrder ]);
        function addUniqueItem(arr, item) {
            if (arr.indexOf(item) === -1) arr.push(item);
        }
        function removeItem(arr, item) {
            const index = arr.indexOf(item);
            if (index > -1) arr.splice(index, 1);
        }
        class SubscriptionManager {
            constructor() {
                this.subscriptions = [];
            }
            add(handler) {
                addUniqueItem(this.subscriptions, handler);
                return () => removeItem(this.subscriptions, handler);
            }
            notify(a, b, c) {
                const numSubscriptions = this.subscriptions.length;
                if (!numSubscriptions) return;
                if (numSubscriptions === 1) this.subscriptions[0](a, b, c); else for (let i = 0; i < numSubscriptions; i++) {
                    const handler = this.subscriptions[i];
                    handler && handler(a, b, c);
                }
            }
            getSize() {
                return this.subscriptions.length;
            }
            clear() {
                this.subscriptions.length = 0;
            }
        }
        function velocityPerSecond(velocity, frameDuration) {
            return frameDuration ? velocity * (1e3 / frameDuration) : 0;
        }
        let sync_time_now;
        function clearTime() {
            sync_time_now = void 0;
        }
        const time = {
            now: () => {
                if (sync_time_now === void 0) time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
                return sync_time_now;
            },
            set: newTime => {
                sync_time_now = newTime;
                queueMicrotask(clearTime);
            }
        };
        const MAX_VELOCITY_DELTA = 30;
        const isFloat = value => !isNaN(parseFloat(value));
        const collectMotionValues = {
            current: void 0
        };
        class MotionValue {
            constructor(init, options = {}) {
                this.canTrackVelocity = null;
                this.events = {};
                this.updateAndNotify = (v, render = true) => {
                    const currentTime = time.now();
                    if (this.updatedAt !== currentTime) this.setPrevFrameValue();
                    this.prev = this.current;
                    this.setCurrent(v);
                    if (this.current !== this.prev) {
                        this.events.change?.notify(this.current);
                        if (this.dependents) for (const dependent of this.dependents) dependent.dirty();
                    }
                    if (render) this.events.renderRequest?.notify(this.current);
                };
                this.hasAnimated = false;
                this.setCurrent(init);
                this.owner = options.owner;
            }
            setCurrent(current) {
                this.current = current;
                this.updatedAt = time.now();
                if (this.canTrackVelocity === null && current !== void 0) this.canTrackVelocity = isFloat(this.current);
            }
            setPrevFrameValue(prevFrameValue = this.current) {
                this.prevFrameValue = prevFrameValue;
                this.prevUpdatedAt = this.updatedAt;
            }
            onChange(subscription) {
                if (false) ;
                return this.on("change", subscription);
            }
            on(eventName, callback) {
                if (!this.events[eventName]) this.events[eventName] = new SubscriptionManager;
                const unsubscribe = this.events[eventName].add(callback);
                if (eventName === "change") return () => {
                    unsubscribe();
                    frame_frame.read(() => {
                        if (!this.events.change.getSize()) this.stop();
                    });
                };
                return unsubscribe;
            }
            clearListeners() {
                for (const eventManagers in this.events) this.events[eventManagers].clear();
            }
            attach(passiveEffect, stopPassiveEffect) {
                this.passiveEffect = passiveEffect;
                this.stopPassiveEffect = stopPassiveEffect;
            }
            set(v, render = true) {
                if (!render || !this.passiveEffect) this.updateAndNotify(v, render); else this.passiveEffect(v, this.updateAndNotify);
            }
            setWithVelocity(prev, current, delta) {
                this.set(current);
                this.prev = void 0;
                this.prevFrameValue = prev;
                this.prevUpdatedAt = this.updatedAt - delta;
            }
            jump(v, endAnimation = true) {
                this.updateAndNotify(v);
                this.prev = v;
                this.prevUpdatedAt = this.prevFrameValue = void 0;
                endAnimation && this.stop();
                if (this.stopPassiveEffect) this.stopPassiveEffect();
            }
            dirty() {
                this.events.change?.notify(this.current);
            }
            addDependent(dependent) {
                if (!this.dependents) this.dependents = new Set;
                this.dependents.add(dependent);
            }
            removeDependent(dependent) {
                if (this.dependents) this.dependents.delete(dependent);
            }
            get() {
                if (collectMotionValues.current) collectMotionValues.current.push(this);
                return this.current;
            }
            getPrevious() {
                return this.prev;
            }
            getVelocity() {
                const currentTime = time.now();
                if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) return 0;
                const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
                return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
            }
            start(startAnimation) {
                this.stop();
                return new Promise(resolve => {
                    this.hasAnimated = true;
                    this.animation = startAnimation(resolve);
                    if (this.events.animationStart) this.events.animationStart.notify();
                }).then(() => {
                    if (this.events.animationComplete) this.events.animationComplete.notify();
                    this.clearAnimation();
                });
            }
            stop() {
                if (this.animation) {
                    this.animation.stop();
                    if (this.events.animationCancel) this.events.animationCancel.notify();
                }
                this.clearAnimation();
            }
            isAnimating() {
                return !!this.animation;
            }
            clearAnimation() {
                delete this.animation;
            }
            destroy() {
                this.dependents?.clear();
                this.events.destroy?.notify();
                this.clearListeners();
                this.stop();
                if (this.stopPassiveEffect) this.stopPassiveEffect();
            }
        }
        function motionValue(init, options) {
            return new MotionValue(init, options);
        }
        const isKeyframesTarget = v => Array.isArray(v);
        function setMotionValue(visualElement, key, value) {
            if (visualElement.hasValue(key)) visualElement.getValue(key).set(value); else visualElement.addValue(key, motionValue(value));
        }
        function resolveFinalValueInKeyframes(v) {
            return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
        }
        function setTarget(visualElement, definition) {
            const resolved = resolveVariant(visualElement, definition);
            let {transitionEnd = {}, transition = {}, ...target} = resolved || {};
            target = {
                ...target,
                ...transitionEnd
            };
            for (const key in target) {
                const value = resolveFinalValueInKeyframes(target[key]);
                setMotionValue(visualElement, key, value);
            }
        }
        const isMotionValue = value => Boolean(value && value.getVelocity);
        function isWillChangeMotionValue(value) {
            return Boolean(isMotionValue(value) && value.add);
        }
        function addValueToWillChange(visualElement, key) {
            const willChange = visualElement.getValue("willChange");
            if (isWillChangeMotionValue(willChange)) return willChange.add(key); else if (!willChange && MotionGlobalConfig.WillChange) {
                const newWillChange = new MotionGlobalConfig.WillChange("auto");
                visualElement.addValue("willChange", newWillChange);
                newWillChange.add(key);
            }
        }
        const camelToDash = str => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase();
        const optimizedAppearDataId = "framerAppearId";
        const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
        function getOptimisedAppearId(visualElement) {
            return visualElement.props[optimizedAppearDataAttribute];
        }
        const combineFunctions = (a, b) => v => b(a(v));
        const pipe = (...transformers) => transformers.reduce(combineFunctions);
        const clamp = (min, max, v) => {
            if (v > max) return max;
            if (v < min) return min;
            return v;
        };
        const time_conversion_secondsToMilliseconds = seconds => seconds * 1e3;
        const millisecondsToSeconds = milliseconds => milliseconds / 1e3;
        const activeAnimations = {
            layout: 0,
            mainThread: 0,
            waapi: 0
        };
        let errors_warning = () => {};
        let errors_invariant = () => {};
        if (false) ;
        const checkStringStartsWith = token => key => typeof key === "string" && key.startsWith(token);
        const isCSSVariableName = checkStringStartsWith("--");
        const startsAsVariableToken = checkStringStartsWith("var(--");
        const isCSSVariableToken = value => {
            const startsWithToken = startsAsVariableToken(value);
            if (!startsWithToken) return false;
            return singleCssVariableRegex.test(value.split("/*")[0].trim());
        };
        const singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
        const number = {
            test: v => typeof v === "number",
            parse: parseFloat,
            transform: v => v
        };
        const alpha = {
            ...number,
            transform: v => clamp(0, 1, v)
        };
        const scale = {
            ...number,
            default: 1
        };
        const sanitize = v => Math.round(v * 1e5) / 1e5;
        const floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
        function isNullish(v) {
            return v == null;
        }
        const singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
        const isColorString = (type, testProp) => v => Boolean(typeof v === "string" && singleColorRegex.test(v) && v.startsWith(type) || testProp && !isNullish(v) && Object.prototype.hasOwnProperty.call(v, testProp));
        const splitColor = (aName, bName, cName) => v => {
            if (typeof v !== "string") return v;
            const [a, b, c, alpha] = v.match(floatRegex);
            return {
                [aName]: parseFloat(a),
                [bName]: parseFloat(b),
                [cName]: parseFloat(c),
                alpha: alpha !== void 0 ? parseFloat(alpha) : 1
            };
        };
        const clampRgbUnit = v => clamp(0, 255, v);
        const rgbUnit = {
            ...number,
            transform: v => Math.round(clampRgbUnit(v))
        };
        const rgba = {
            test: isColorString("rgb", "red"),
            parse: splitColor("red", "green", "blue"),
            transform: ({red, green, blue, alpha: alpha$1 = 1}) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
        };
        function parseHex(v) {
            let r = "";
            let g = "";
            let b = "";
            let a = "";
            if (v.length > 5) {
                r = v.substring(1, 3);
                g = v.substring(3, 5);
                b = v.substring(5, 7);
                a = v.substring(7, 9);
            } else {
                r = v.substring(1, 2);
                g = v.substring(2, 3);
                b = v.substring(3, 4);
                a = v.substring(4, 5);
                r += r;
                g += g;
                b += b;
                a += a;
            }
            return {
                red: parseInt(r, 16),
                green: parseInt(g, 16),
                blue: parseInt(b, 16),
                alpha: a ? parseInt(a, 16) / 255 : 1
            };
        }
        const hex_hex = {
            test: isColorString("#"),
            parse: parseHex,
            transform: rgba.transform
        };
        const createUnitType = unit => ({
            test: v => typeof v === "string" && v.endsWith(unit) && v.split(" ").length === 1,
            parse: parseFloat,
            transform: v => `${v}${unit}`
        });
        const degrees = createUnitType("deg");
        const percent = createUnitType("%");
        const px = createUnitType("px");
        const vh = createUnitType("vh");
        const vw = createUnitType("vw");
        const progressPercentage = (() => ({
            ...percent,
            parse: v => percent.parse(v) / 100,
            transform: v => percent.transform(v * 100)
        }))();
        const hsla = {
            test: isColorString("hsl", "hue"),
            parse: splitColor("hue", "saturation", "lightness"),
            transform: ({hue, saturation, lightness, alpha: alpha$1 = 1}) => "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
        };
        const color = {
            test: v => rgba.test(v) || hex_hex.test(v) || hsla.test(v),
            parse: v => {
                if (rgba.test(v)) return rgba.parse(v); else if (hsla.test(v)) return hsla.parse(v); else return hex_hex.parse(v);
            },
            transform: v => typeof v === "string" ? v : v.hasOwnProperty("red") ? rgba.transform(v) : hsla.transform(v),
            getAnimatableNone: v => {
                const parsed = color.parse(v);
                parsed.alpha = 0;
                return color.transform(parsed);
            }
        };
        const colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
        function test(v) {
            return isNaN(v) && typeof v === "string" && (v.match(floatRegex)?.length || 0) + (v.match(colorRegex)?.length || 0) > 0;
        }
        const NUMBER_TOKEN = "number";
        const COLOR_TOKEN = "color";
        const VAR_TOKEN = "var";
        const VAR_FUNCTION_TOKEN = "var(";
        const SPLIT_TOKEN = "${}";
        const complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
        function analyseComplexValue(value) {
            const originalValue = value.toString();
            const values = [];
            const indexes = {
                color: [],
                number: [],
                var: []
            };
            const types = [];
            let i = 0;
            const tokenised = originalValue.replace(complexRegex, parsedValue => {
                if (color.test(parsedValue)) {
                    indexes.color.push(i);
                    types.push(COLOR_TOKEN);
                    values.push(color.parse(parsedValue));
                } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
                    indexes.var.push(i);
                    types.push(VAR_TOKEN);
                    values.push(parsedValue);
                } else {
                    indexes.number.push(i);
                    types.push(NUMBER_TOKEN);
                    values.push(parseFloat(parsedValue));
                }
                ++i;
                return SPLIT_TOKEN;
            });
            const split = tokenised.split(SPLIT_TOKEN);
            return {
                values,
                split,
                indexes,
                types
            };
        }
        function parseComplexValue(v) {
            return analyseComplexValue(v).values;
        }
        function createTransformer(source) {
            const {split, types} = analyseComplexValue(source);
            const numSections = split.length;
            return v => {
                let output = "";
                for (let i = 0; i < numSections; i++) {
                    output += split[i];
                    if (v[i] !== void 0) {
                        const type = types[i];
                        if (type === NUMBER_TOKEN) output += sanitize(v[i]); else if (type === COLOR_TOKEN) output += color.transform(v[i]); else output += v[i];
                    }
                }
                return output;
            };
        }
        const convertNumbersToZero = v => typeof v === "number" ? 0 : color.test(v) ? color.getAnimatableNone(v) : v;
        function getAnimatableNone(v) {
            const parsed = parseComplexValue(v);
            const transformer = createTransformer(v);
            return transformer(parsed.map(convertNumbersToZero));
        }
        const complex = {
            test,
            parse: parseComplexValue,
            createTransformer,
            getAnimatableNone
        };
        function hueToRgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        }
        function hslaToRgba({hue, saturation, lightness, alpha}) {
            hue /= 360;
            saturation /= 100;
            lightness /= 100;
            let red = 0;
            let green = 0;
            let blue = 0;
            if (!saturation) red = green = blue = lightness; else {
                const q = lightness < .5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
                const p = 2 * lightness - q;
                red = hueToRgb(p, q, hue + 1 / 3);
                green = hueToRgb(p, q, hue);
                blue = hueToRgb(p, q, hue - 1 / 3);
            }
            return {
                red: Math.round(red * 255),
                green: Math.round(green * 255),
                blue: Math.round(blue * 255),
                alpha
            };
        }
        function mixImmediate(a, b) {
            return p => p > 0 ? b : a;
        }
        const mixNumber = (from, to, progress) => from + (to - from) * progress;
        const mixLinearColor = (from, to, v) => {
            const fromExpo = from * from;
            const expo = v * (to * to - fromExpo) + fromExpo;
            return expo < 0 ? 0 : Math.sqrt(expo);
        };
        const colorTypes = [ hex_hex, rgba, hsla ];
        const getColorType = v => colorTypes.find(type => type.test(v));
        function asRGBA(color) {
            const type = getColorType(color);
            errors_warning(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);
            if (!Boolean(type)) return false;
            let model = type.parse(color);
            if (type === hsla) model = hslaToRgba(model);
            return model;
        }
        const mixColor = (from, to) => {
            const fromRGBA = asRGBA(from);
            const toRGBA = asRGBA(to);
            if (!fromRGBA || !toRGBA) return mixImmediate(from, to);
            const blended = {
                ...fromRGBA
            };
            return v => {
                blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);
                blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);
                blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);
                blended.alpha = mixNumber(fromRGBA.alpha, toRGBA.alpha, v);
                return rgba.transform(blended);
            };
        };
        const invisibleValues = new Set([ "none", "hidden" ]);
        function mixVisibility(origin, target) {
            if (invisibleValues.has(origin)) return p => p <= 0 ? origin : target; else return p => p >= 1 ? target : origin;
        }
        function complex_mixNumber(a, b) {
            return p => mixNumber(a, b, p);
        }
        function getMixer(a) {
            if (typeof a === "number") return complex_mixNumber; else if (typeof a === "string") return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex; else if (Array.isArray(a)) return mixArray; else if (typeof a === "object") return color.test(a) ? mixColor : mixObject;
            return mixImmediate;
        }
        function mixArray(a, b) {
            const output = [ ...a ];
            const numValues = output.length;
            const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));
            return p => {
                for (let i = 0; i < numValues; i++) output[i] = blendValue[i](p);
                return output;
            };
        }
        function mixObject(a, b) {
            const output = {
                ...a,
                ...b
            };
            const blendValue = {};
            for (const key in output) if (a[key] !== void 0 && b[key] !== void 0) blendValue[key] = getMixer(a[key])(a[key], b[key]);
            return v => {
                for (const key in blendValue) output[key] = blendValue[key](v);
                return output;
            };
        }
        function matchOrder(origin, target) {
            const orderedOrigin = [];
            const pointers = {
                color: 0,
                var: 0,
                number: 0
            };
            for (let i = 0; i < target.values.length; i++) {
                const type = target.types[i];
                const originIndex = origin.indexes[type][pointers[type]];
                const originValue = origin.values[originIndex] ?? 0;
                orderedOrigin[i] = originValue;
                pointers[type]++;
            }
            return orderedOrigin;
        }
        const mixComplex = (origin, target) => {
            const template = complex.createTransformer(target);
            const originStats = analyseComplexValue(origin);
            const targetStats = analyseComplexValue(target);
            const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
            if (canInterpolate) {
                if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) return mixVisibility(origin, target);
                return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
            } else {
                errors_warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
                return mixImmediate(origin, target);
            }
        };
        function mix(from, to, p) {
            if (typeof from === "number" && typeof to === "number" && typeof p === "number") return mixNumber(from, to, p);
            const mixer = getMixer(from);
            return mixer(from, to);
        }
        const frameloopDriver = update => {
            const passTimestamp = ({timestamp}) => update(timestamp);
            return {
                start: (keepAlive = true) => frame_frame.update(passTimestamp, keepAlive),
                stop: () => cancelFrame(passTimestamp),
                now: () => frameData.isProcessing ? frameData.timestamp : time.now()
            };
        };
        const generateLinearEasing = (easing, duration, resolution = 10) => {
            let points = "";
            const numPoints = Math.max(Math.round(duration / resolution), 2);
            for (let i = 0; i < numPoints; i++) points += Math.round(easing(i / (numPoints - 1)) * 1e4) / 1e4 + ", ";
            return `linear(${points.substring(0, points.length - 2)})`;
        };
        const maxGeneratorDuration = 2e4;
        function calcGeneratorDuration(generator) {
            let duration = 0;
            const timeStep = 50;
            let state = generator.next(duration);
            while (!state.done && duration < maxGeneratorDuration) {
                duration += timeStep;
                state = generator.next(duration);
            }
            return duration >= maxGeneratorDuration ? 1 / 0 : duration;
        }
        function createGeneratorEasing(options, scale = 100, createGenerator) {
            const generator = createGenerator({
                ...options,
                keyframes: [ 0, scale ]
            });
            const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
            return {
                type: "keyframes",
                ease: progress => generator.next(duration * progress).value / scale,
                duration: millisecondsToSeconds(duration)
            };
        }
        const velocitySampleDuration = 5;
        function calcGeneratorVelocity(resolveValue, t, current) {
            const prevT = Math.max(t - velocitySampleDuration, 0);
            return velocityPerSecond(current - resolveValue(prevT), t - prevT);
        }
        const springDefaults = {
            stiffness: 100,
            damping: 10,
            mass: 1,
            velocity: 0,
            duration: 800,
            bounce: .3,
            visualDuration: .3,
            restSpeed: {
                granular: .01,
                default: 2
            },
            restDelta: {
                granular: .005,
                default: .5
            },
            minDuration: .01,
            maxDuration: 10,
            minDamping: .05,
            maxDamping: 1
        };
        const safeMin = .001;
        function findSpring({duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass}) {
            let envelope;
            let derivative;
            errors_warning(duration <= time_conversion_secondsToMilliseconds(springDefaults.maxDuration), "Spring duration must be 10 seconds or less");
            let dampingRatio = 1 - bounce;
            dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
            duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));
            if (dampingRatio < 1) {
                envelope = undampedFreq => {
                    const exponentialDecay = undampedFreq * dampingRatio;
                    const delta = exponentialDecay * duration;
                    const a = exponentialDecay - velocity;
                    const b = calcAngularFreq(undampedFreq, dampingRatio);
                    const c = Math.exp(-delta);
                    return safeMin - a / b * c;
                };
                derivative = undampedFreq => {
                    const exponentialDecay = undampedFreq * dampingRatio;
                    const delta = exponentialDecay * duration;
                    const d = delta * velocity + velocity;
                    const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;
                    const f = Math.exp(-delta);
                    const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);
                    const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;
                    return factor * ((d - e) * f) / g;
                };
            } else {
                envelope = undampedFreq => {
                    const a = Math.exp(-undampedFreq * duration);
                    const b = (undampedFreq - velocity) * duration + 1;
                    return -safeMin + a * b;
                };
                derivative = undampedFreq => {
                    const a = Math.exp(-undampedFreq * duration);
                    const b = (velocity - undampedFreq) * (duration * duration);
                    return a * b;
                };
            }
            const initialGuess = 5 / duration;
            const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
            duration = time_conversion_secondsToMilliseconds(duration);
            if (isNaN(undampedFreq)) return {
                stiffness: springDefaults.stiffness,
                damping: springDefaults.damping,
                duration
            }; else {
                const stiffness = Math.pow(undampedFreq, 2) * mass;
                return {
                    stiffness,
                    damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
                    duration
                };
            }
        }
        const rootIterations = 12;
        function approximateRoot(envelope, derivative, initialGuess) {
            let result = initialGuess;
            for (let i = 1; i < rootIterations; i++) result -= envelope(result) / derivative(result);
            return result;
        }
        function calcAngularFreq(undampedFreq, dampingRatio) {
            return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
        }
        const durationKeys = [ "duration", "bounce" ];
        const physicsKeys = [ "stiffness", "damping", "mass" ];
        function isSpringType(options, keys) {
            return keys.some(key => options[key] !== void 0);
        }
        function getSpringOptions(options) {
            let springOptions = {
                velocity: springDefaults.velocity,
                stiffness: springDefaults.stiffness,
                damping: springDefaults.damping,
                mass: springDefaults.mass,
                isResolvedFromDuration: false,
                ...options
            };
            if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) if (options.visualDuration) {
                const visualDuration = options.visualDuration;
                const root = 2 * Math.PI / (visualDuration * 1.2);
                const stiffness = root * root;
                const damping = 2 * clamp(.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);
                springOptions = {
                    ...springOptions,
                    mass: springDefaults.mass,
                    stiffness,
                    damping
                };
            } else {
                const derived = findSpring(options);
                springOptions = {
                    ...springOptions,
                    ...derived,
                    mass: springDefaults.mass
                };
                springOptions.isResolvedFromDuration = true;
            }
            return springOptions;
        }
        function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
            const options = typeof optionsOrVisualDuration !== "object" ? {
                visualDuration: optionsOrVisualDuration,
                keyframes: [ 0, 1 ],
                bounce
            } : optionsOrVisualDuration;
            let {restSpeed, restDelta} = options;
            const origin = options.keyframes[0];
            const target = options.keyframes[options.keyframes.length - 1];
            const state = {
                done: false,
                value: origin
            };
            const {stiffness, damping, mass, duration, velocity, isResolvedFromDuration} = getSpringOptions({
                ...options,
                velocity: -millisecondsToSeconds(options.velocity || 0)
            });
            const initialVelocity = velocity || 0;
            const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
            const initialDelta = target - origin;
            const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
            const isGranularScale = Math.abs(initialDelta) < 5;
            restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);
            restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
            let resolveSpring;
            if (dampingRatio < 1) {
                const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
                resolveSpring = t => {
                    const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
                    return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));
                };
            } else if (dampingRatio === 1) resolveSpring = t => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t); else {
                const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
                resolveSpring = t => {
                    const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
                    const freqForT = Math.min(dampedAngularFreq * t, 300);
                    return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
                };
            }
            const generator = {
                calculatedDuration: isResolvedFromDuration ? duration || null : null,
                next: t => {
                    const current = resolveSpring(t);
                    if (!isResolvedFromDuration) {
                        let currentVelocity = t === 0 ? initialVelocity : 0;
                        if (dampingRatio < 1) currentVelocity = t === 0 ? time_conversion_secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t, current);
                        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
                        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
                        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
                    } else state.done = t >= duration;
                    state.value = state.done ? target : current;
                    return state;
                },
                toString: () => {
                    const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
                    const easing = generateLinearEasing(progress => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);
                    return calculatedDuration + "ms " + easing;
                },
                toTransition: () => {}
            };
            return generator;
        }
        spring.applyToOptions = options => {
            const generatorOptions = createGeneratorEasing(options, 100, spring);
            options.ease = generatorOptions.ease;
            options.duration = time_conversion_secondsToMilliseconds(generatorOptions.duration);
            options.type = "keyframes";
            return options;
        };
        function inertia({keyframes, velocity = 0, power = .8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = .5, restSpeed}) {
            const origin = keyframes[0];
            const state = {
                done: false,
                value: origin
            };
            const isOutOfBounds = v => min !== void 0 && v < min || max !== void 0 && v > max;
            const nearestBoundary = v => {
                if (min === void 0) return max;
                if (max === void 0) return min;
                return Math.abs(min - v) < Math.abs(max - v) ? min : max;
            };
            let amplitude = power * velocity;
            const ideal = origin + amplitude;
            const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
            if (target !== ideal) amplitude = target - origin;
            const calcDelta = t => -amplitude * Math.exp(-t / timeConstant);
            const calcLatest = t => target + calcDelta(t);
            const applyFriction = t => {
                const delta = calcDelta(t);
                const latest = calcLatest(t);
                state.done = Math.abs(delta) <= restDelta;
                state.value = state.done ? target : latest;
            };
            let timeReachedBoundary;
            let spring$1;
            const checkCatchBoundary = t => {
                if (!isOutOfBounds(state.value)) return;
                timeReachedBoundary = t;
                spring$1 = spring({
                    keyframes: [ state.value, nearestBoundary(state.value) ],
                    velocity: calcGeneratorVelocity(calcLatest, t, state.value),
                    damping: bounceDamping,
                    stiffness: bounceStiffness,
                    restDelta,
                    restSpeed
                });
            };
            checkCatchBoundary(0);
            return {
                calculatedDuration: null,
                next: t => {
                    let hasUpdatedFrame = false;
                    if (!spring$1 && timeReachedBoundary === void 0) {
                        hasUpdatedFrame = true;
                        applyFriction(t);
                        checkCatchBoundary(t);
                    }
                    if (timeReachedBoundary !== void 0 && t >= timeReachedBoundary) return spring$1.next(t - timeReachedBoundary); else {
                        !hasUpdatedFrame && applyFriction(t);
                        return state;
                    }
                }
            };
        }
        const calcBezier = (t, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1) * t;
        const subdivisionPrecision = 1e-7;
        const subdivisionMaxIterations = 12;
        function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
            let currentX;
            let currentT;
            let i = 0;
            do {
                currentT = lowerBound + (upperBound - lowerBound) / 2;
                currentX = calcBezier(currentT, mX1, mX2) - x;
                if (currentX > 0) upperBound = currentT; else lowerBound = currentT;
            } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
            return currentT;
        }
        function cubicBezier(mX1, mY1, mX2, mY2) {
            if (mX1 === mY1 && mX2 === mY2) return noop;
            const getTForX = aX => binarySubdivide(aX, 0, 1, mX1, mX2);
            return t => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
        }
        const easeIn = cubicBezier(.42, 0, 1, 1);
        const easeOut = cubicBezier(0, 0, .58, 1);
        const easeInOut = cubicBezier(.42, 0, .58, 1);
        const isEasingArray = ease => Array.isArray(ease) && typeof ease[0] !== "number";
        const mirrorEasing = easing => p => p <= .5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
        const reverseEasing = easing => p => 1 - easing(1 - p);
        const backOut = cubicBezier(.33, 1.53, .69, .99);
        const backIn = reverseEasing(backOut);
        const backInOut = mirrorEasing(backIn);
        const anticipate = p => (p *= 2) < 1 ? .5 * backIn(p) : .5 * (2 - Math.pow(2, -10 * (p - 1)));
        const circIn = p => 1 - Math.sin(Math.acos(p));
        const circOut = reverseEasing(circIn);
        const circInOut = mirrorEasing(circIn);
        const isBezierDefinition = easing => Array.isArray(easing) && typeof easing[0] === "number";
        const easingLookup = {
            linear: noop,
            easeIn,
            easeInOut,
            easeOut,
            circIn,
            circInOut,
            circOut,
            backIn,
            backInOut,
            backOut,
            anticipate
        };
        const isValidEasing = easing => typeof easing === "string";
        const easingDefinitionToFunction = definition => {
            if (isBezierDefinition(definition)) {
                errors_invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);
                const [x1, y1, x2, y2] = definition;
                return cubicBezier(x1, y1, x2, y2);
            } else if (isValidEasing(definition)) {
                errors_invariant(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`);
                return easingLookup[definition];
            }
            return definition;
        };
        const progress = (from, to, value) => {
            const toFromDifference = to - from;
            return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
        };
        function createMixers(output, ease, customMixer) {
            const mixers = [];
            const mixerFactory = customMixer || MotionGlobalConfig.mix || mix;
            const numMixers = output.length - 1;
            for (let i = 0; i < numMixers; i++) {
                let mixer = mixerFactory(output[i], output[i + 1]);
                if (ease) {
                    const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;
                    mixer = pipe(easingFunction, mixer);
                }
                mixers.push(mixer);
            }
            return mixers;
        }
        function interpolate(input, output, {clamp: isClamp = true, ease, mixer} = {}) {
            const inputLength = input.length;
            errors_invariant(inputLength === output.length, "Both input and output ranges must be the same length");
            if (inputLength === 1) return () => output[0];
            if (inputLength === 2 && output[0] === output[1]) return () => output[1];
            const isZeroDeltaRange = input[0] === input[1];
            if (input[0] > input[inputLength - 1]) {
                input = [ ...input ].reverse();
                output = [ ...output ].reverse();
            }
            const mixers = createMixers(output, ease, mixer);
            const numMixers = mixers.length;
            const interpolator = v => {
                if (isZeroDeltaRange && v < input[0]) return output[0];
                let i = 0;
                if (numMixers > 1) for (;i < input.length - 2; i++) if (v < input[i + 1]) break;
                const progressInRange = progress(input[i], input[i + 1], v);
                return mixers[i](progressInRange);
            };
            return isClamp ? v => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;
        }
        function fillOffset(offset, remaining) {
            const min = offset[offset.length - 1];
            for (let i = 1; i <= remaining; i++) {
                const offsetProgress = progress(0, remaining, i);
                offset.push(mixNumber(min, 1, offsetProgress));
            }
        }
        function defaultOffset(arr) {
            const offset = [ 0 ];
            fillOffset(offset, arr.length - 1);
            return offset;
        }
        function convertOffsetToTimes(offset, duration) {
            return offset.map(o => o * duration);
        }
        function defaultEasing(values, easing) {
            return values.map(() => easing || easeInOut).splice(0, values.length - 1);
        }
        function keyframes({duration = 300, keyframes: keyframeValues, times, ease = "easeInOut"}) {
            const easingFunctions = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);
            const state = {
                done: false,
                value: keyframeValues[0]
            };
            const absoluteTimes = convertOffsetToTimes(times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues), duration);
            const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
                ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
            });
            return {
                calculatedDuration: duration,
                next: t => {
                    state.value = mapTimeToKeyframe(t);
                    state.done = t >= duration;
                    return state;
                }
            };
        }
        const isNotNull = value => value !== null;
        function getFinalKeyframe(keyframes, {repeat, repeatType = "loop"}, finalKeyframe, speed = 1) {
            const resolvedKeyframes = keyframes.filter(isNotNull);
            const useFirstKeyframe = speed < 0 || repeat && repeatType !== "loop" && repeat % 2 === 1;
            const index = useFirstKeyframe ? 0 : resolvedKeyframes.length - 1;
            return !index || finalKeyframe === void 0 ? resolvedKeyframes[index] : finalKeyframe;
        }
        const transitionTypeMap = {
            decay: inertia,
            inertia,
            tween: keyframes,
            keyframes,
            spring
        };
        function replaceTransitionType(transition) {
            if (typeof transition.type === "string") transition.type = transitionTypeMap[transition.type];
        }
        class WithPromise {
            constructor() {
                this.updateFinished();
            }
            get finished() {
                return this._finished;
            }
            updateFinished() {
                this._finished = new Promise(resolve => {
                    this.resolve = resolve;
                });
            }
            notifyFinished() {
                this.resolve();
            }
            then(onResolve, onReject) {
                return this.finished.then(onResolve, onReject);
            }
        }
        const percentToProgress = percent => percent / 100;
        class JSAnimation extends WithPromise {
            constructor(options) {
                super();
                this.state = "idle";
                this.startTime = null;
                this.isStopped = false;
                this.currentTime = 0;
                this.holdTime = null;
                this.playbackSpeed = 1;
                this.stop = () => {
                    const {motionValue} = this.options;
                    if (motionValue && motionValue.updatedAt !== time.now()) this.tick(time.now());
                    this.isStopped = true;
                    if (this.state === "idle") return;
                    this.teardown();
                    this.options.onStop?.();
                };
                activeAnimations.mainThread++;
                this.options = options;
                this.initAnimation();
                this.play();
                if (options.autoplay === false) this.pause();
            }
            initAnimation() {
                const {options} = this;
                replaceTransitionType(options);
                const {type = keyframes, repeat = 0, repeatDelay = 0, repeatType, velocity = 0} = options;
                let {keyframes: keyframes$1} = options;
                const generatorFactory = type || keyframes;
                if (false) ;
                if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
                    this.mixKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
                    keyframes$1 = [ 0, 100 ];
                }
                const generator = generatorFactory({
                    ...options,
                    keyframes: keyframes$1
                });
                if (repeatType === "mirror") this.mirroredGenerator = generatorFactory({
                    ...options,
                    keyframes: [ ...keyframes$1 ].reverse(),
                    velocity: -velocity
                });
                if (generator.calculatedDuration === null) generator.calculatedDuration = calcGeneratorDuration(generator);
                const {calculatedDuration} = generator;
                this.calculatedDuration = calculatedDuration;
                this.resolvedDuration = calculatedDuration + repeatDelay;
                this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;
                this.generator = generator;
            }
            updateTime(timestamp) {
                const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;
                if (this.holdTime !== null) this.currentTime = this.holdTime; else this.currentTime = animationTime;
            }
            tick(timestamp, sample = false) {
                const {generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration} = this;
                if (this.startTime === null) return generator.next(0);
                const {delay = 0, keyframes, repeat, repeatType, repeatDelay, type, onUpdate, finalKeyframe} = this.options;
                if (this.speed > 0) this.startTime = Math.min(this.startTime, timestamp); else if (this.speed < 0) this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
                if (sample) this.currentTime = timestamp; else this.updateTime(timestamp);
                const timeWithoutDelay = this.currentTime - delay * (this.playbackSpeed >= 0 ? 1 : -1);
                const isInDelayPhase = this.playbackSpeed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
                this.currentTime = Math.max(timeWithoutDelay, 0);
                if (this.state === "finished" && this.holdTime === null) this.currentTime = totalDuration;
                let elapsed = this.currentTime;
                let frameGenerator = generator;
                if (repeat) {
                    const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;
                    let currentIteration = Math.floor(progress);
                    let iterationProgress = progress % 1;
                    if (!iterationProgress && progress >= 1) iterationProgress = 1;
                    iterationProgress === 1 && currentIteration--;
                    currentIteration = Math.min(currentIteration, repeat + 1);
                    const isOddIteration = Boolean(currentIteration % 2);
                    if (isOddIteration) if (repeatType === "reverse") {
                        iterationProgress = 1 - iterationProgress;
                        if (repeatDelay) iterationProgress -= repeatDelay / resolvedDuration;
                    } else if (repeatType === "mirror") frameGenerator = mirroredGenerator;
                    elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
                }
                const state = isInDelayPhase ? {
                    done: false,
                    value: keyframes[0]
                } : frameGenerator.next(elapsed);
                if (mixKeyframes) state.value = mixKeyframes(state.value);
                let {done} = state;
                if (!isInDelayPhase && calculatedDuration !== null) done = this.playbackSpeed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
                const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
                if (isAnimationFinished && type !== inertia) state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe, this.speed);
                if (onUpdate) onUpdate(state.value);
                if (isAnimationFinished) this.finish();
                return state;
            }
            then(resolve, reject) {
                return this.finished.then(resolve, reject);
            }
            get duration() {
                return millisecondsToSeconds(this.calculatedDuration);
            }
            get time() {
                return millisecondsToSeconds(this.currentTime);
            }
            set time(newTime) {
                newTime = time_conversion_secondsToMilliseconds(newTime);
                this.currentTime = newTime;
                if (this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0) this.holdTime = newTime; else if (this.driver) this.startTime = this.driver.now() - newTime / this.playbackSpeed;
                this.driver?.start(false);
            }
            get speed() {
                return this.playbackSpeed;
            }
            set speed(newSpeed) {
                this.updateTime(time.now());
                const hasChanged = this.playbackSpeed !== newSpeed;
                this.playbackSpeed = newSpeed;
                if (hasChanged) this.time = millisecondsToSeconds(this.currentTime);
            }
            play() {
                if (this.isStopped) return;
                const {driver = frameloopDriver, startTime} = this.options;
                if (!this.driver) this.driver = driver(timestamp => this.tick(timestamp));
                this.options.onPlay?.();
                const now = this.driver.now();
                if (this.state === "finished") {
                    this.updateFinished();
                    this.startTime = now;
                } else if (this.holdTime !== null) this.startTime = now - this.holdTime; else if (!this.startTime) this.startTime = startTime ?? now;
                if (this.state === "finished" && this.speed < 0) this.startTime += this.calculatedDuration;
                this.holdTime = null;
                this.state = "running";
                this.driver.start();
            }
            pause() {
                this.state = "paused";
                this.updateTime(time.now());
                this.holdTime = this.currentTime;
            }
            complete() {
                if (this.state !== "running") this.play();
                this.state = "finished";
                this.holdTime = null;
            }
            finish() {
                this.notifyFinished();
                this.teardown();
                this.state = "finished";
                this.options.onComplete?.();
            }
            cancel() {
                this.holdTime = null;
                this.startTime = 0;
                this.tick(0);
                this.teardown();
                this.options.onCancel?.();
            }
            teardown() {
                this.state = "idle";
                this.stopDriver();
                this.startTime = this.holdTime = null;
                activeAnimations.mainThread--;
            }
            stopDriver() {
                if (!this.driver) return;
                this.driver.stop();
                this.driver = void 0;
            }
            sample(sampleTime) {
                this.startTime = 0;
                return this.tick(sampleTime, true);
            }
            attachTimeline(timeline) {
                if (this.options.allowFlatten) {
                    this.options.type = "keyframes";
                    this.options.ease = "linear";
                    this.initAnimation();
                }
                this.driver?.stop();
                return timeline.observe(this);
            }
        }
        function fillWildcards(keyframes) {
            for (let i = 1; i < keyframes.length; i++) keyframes[i] ?? (keyframes[i] = keyframes[i - 1]);
        }
        const radToDeg = rad => rad * 180 / Math.PI;
        const rotate = v => {
            const angle = radToDeg(Math.atan2(v[1], v[0]));
            return rebaseAngle(angle);
        };
        const matrix2dParsers = {
            x: 4,
            y: 5,
            translateX: 4,
            translateY: 5,
            scaleX: 0,
            scaleY: 3,
            scale: v => (Math.abs(v[0]) + Math.abs(v[3])) / 2,
            rotate,
            rotateZ: rotate,
            skewX: v => radToDeg(Math.atan(v[1])),
            skewY: v => radToDeg(Math.atan(v[2])),
            skew: v => (Math.abs(v[1]) + Math.abs(v[2])) / 2
        };
        const rebaseAngle = angle => {
            angle %= 360;
            if (angle < 0) angle += 360;
            return angle;
        };
        const rotateZ = rotate;
        const scaleX = v => Math.sqrt(v[0] * v[0] + v[1] * v[1]);
        const scaleY = v => Math.sqrt(v[4] * v[4] + v[5] * v[5]);
        const matrix3dParsers = {
            x: 12,
            y: 13,
            z: 14,
            translateX: 12,
            translateY: 13,
            translateZ: 14,
            scaleX,
            scaleY,
            scale: v => (scaleX(v) + scaleY(v)) / 2,
            rotateX: v => rebaseAngle(radToDeg(Math.atan2(v[6], v[5]))),
            rotateY: v => rebaseAngle(radToDeg(Math.atan2(-v[2], v[0]))),
            rotateZ,
            rotate: rotateZ,
            skewX: v => radToDeg(Math.atan(v[4])),
            skewY: v => radToDeg(Math.atan(v[1])),
            skew: v => (Math.abs(v[1]) + Math.abs(v[4])) / 2
        };
        function defaultTransformValue(name) {
            return name.includes("scale") ? 1 : 0;
        }
        function parseValueFromTransform(transform, name) {
            if (!transform || transform === "none") return defaultTransformValue(name);
            const matrix3dMatch = transform.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
            let parsers;
            let match;
            if (matrix3dMatch) {
                parsers = matrix3dParsers;
                match = matrix3dMatch;
            } else {
                const matrix2dMatch = transform.match(/^matrix\(([-\d.e\s,]+)\)$/u);
                parsers = matrix2dParsers;
                match = matrix2dMatch;
            }
            if (!match) return defaultTransformValue(name);
            const valueParser = parsers[name];
            const values = match[1].split(",").map(convertTransformToNumber);
            return typeof valueParser === "function" ? valueParser(values) : values[valueParser];
        }
        const readTransformValue = (instance, name) => {
            const {transform = "none"} = getComputedStyle(instance);
            return parseValueFromTransform(transform, name);
        };
        function convertTransformToNumber(value) {
            return parseFloat(value.trim());
        }
        const isNumOrPxType = v => v === number || v === px;
        const transformKeys = new Set([ "x", "y", "z" ]);
        const nonTranslationalTransformKeys = transformPropOrder.filter(key => !transformKeys.has(key));
        function removeNonTranslationalTransform(visualElement) {
            const removedTransforms = [];
            nonTranslationalTransformKeys.forEach(key => {
                const value = visualElement.getValue(key);
                if (value !== void 0) {
                    removedTransforms.push([ key, value.get() ]);
                    value.set(key.startsWith("scale") ? 1 : 0);
                }
            });
            return removedTransforms;
        }
        const positionalValues = {
            width: ({x}, {paddingLeft = "0", paddingRight = "0"}) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
            height: ({y}, {paddingTop = "0", paddingBottom = "0"}) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
            top: (_bbox, {top}) => parseFloat(top),
            left: (_bbox, {left}) => parseFloat(left),
            bottom: ({y}, {top}) => parseFloat(top) + (y.max - y.min),
            right: ({x}, {left}) => parseFloat(left) + (x.max - x.min),
            x: (_bbox, {transform}) => parseValueFromTransform(transform, "x"),
            y: (_bbox, {transform}) => parseValueFromTransform(transform, "y")
        };
        positionalValues.translateX = positionalValues.x;
        positionalValues.translateY = positionalValues.y;
        const toResolve = new Set;
        let isScheduled = false;
        let anyNeedsMeasurement = false;
        let isForced = false;
        function measureAllKeyframes() {
            if (anyNeedsMeasurement) {
                const resolversToMeasure = Array.from(toResolve).filter(resolver => resolver.needsMeasurement);
                const elementsToMeasure = new Set(resolversToMeasure.map(resolver => resolver.element));
                const transformsToRestore = new Map;
                elementsToMeasure.forEach(element => {
                    const removedTransforms = removeNonTranslationalTransform(element);
                    if (!removedTransforms.length) return;
                    transformsToRestore.set(element, removedTransforms);
                    element.render();
                });
                resolversToMeasure.forEach(resolver => resolver.measureInitialState());
                elementsToMeasure.forEach(element => {
                    element.render();
                    const restore = transformsToRestore.get(element);
                    if (restore) restore.forEach(([key, value]) => {
                        element.getValue(key)?.set(value);
                    });
                });
                resolversToMeasure.forEach(resolver => resolver.measureEndState());
                resolversToMeasure.forEach(resolver => {
                    if (resolver.suspendedScrollY !== void 0) window.scrollTo(0, resolver.suspendedScrollY);
                });
            }
            anyNeedsMeasurement = false;
            isScheduled = false;
            toResolve.forEach(resolver => resolver.complete(isForced));
            toResolve.clear();
        }
        function readAllKeyframes() {
            toResolve.forEach(resolver => {
                resolver.readKeyframes();
                if (resolver.needsMeasurement) anyNeedsMeasurement = true;
            });
        }
        function flushKeyframeResolvers() {
            isForced = true;
            readAllKeyframes();
            measureAllKeyframes();
            isForced = false;
        }
        class KeyframeResolver {
            constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {
                this.state = "pending";
                this.isAsync = false;
                this.needsMeasurement = false;
                this.unresolvedKeyframes = [ ...unresolvedKeyframes ];
                this.onComplete = onComplete;
                this.name = name;
                this.motionValue = motionValue;
                this.element = element;
                this.isAsync = isAsync;
            }
            scheduleResolve() {
                this.state = "scheduled";
                if (this.isAsync) {
                    toResolve.add(this);
                    if (!isScheduled) {
                        isScheduled = true;
                        frame_frame.read(readAllKeyframes);
                        frame_frame.resolveKeyframes(measureAllKeyframes);
                    }
                } else {
                    this.readKeyframes();
                    this.complete();
                }
            }
            readKeyframes() {
                const {unresolvedKeyframes, name, element, motionValue} = this;
                if (unresolvedKeyframes[0] === null) {
                    const currentValue = motionValue?.get();
                    const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
                    if (currentValue !== void 0) unresolvedKeyframes[0] = currentValue; else if (element && name) {
                        const valueAsRead = element.readValue(name, finalKeyframe);
                        if (valueAsRead !== void 0 && valueAsRead !== null) unresolvedKeyframes[0] = valueAsRead;
                    }
                    if (unresolvedKeyframes[0] === void 0) unresolvedKeyframes[0] = finalKeyframe;
                    if (motionValue && currentValue === void 0) motionValue.set(unresolvedKeyframes[0]);
                }
                fillWildcards(unresolvedKeyframes);
            }
            setFinalKeyframe() {}
            measureInitialState() {}
            renderEndStyles() {}
            measureEndState() {}
            complete(isForcedComplete = false) {
                this.state = "complete";
                this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForcedComplete);
                toResolve.delete(this);
            }
            cancel() {
                if (this.state === "scheduled") {
                    toResolve.delete(this);
                    this.state = "pending";
                }
            }
            resume() {
                if (this.state === "pending") this.scheduleResolve();
            }
        }
        const isCSSVar = name => name.startsWith("--");
        function setStyle(element, name, value) {
            isCSSVar(name) ? element.style.setProperty(name, value) : element.style[name] = value;
        }
        function memo(callback) {
            let result;
            return () => {
                if (result === void 0) result = callback();
                return result;
            };
        }
        const supportsScrollTimeline = memo(() => window.ScrollTimeline !== void 0);
        const supportsFlags = {};
        function memoSupports(callback, supportsFlag) {
            const memoized = memo(callback);
            return () => supportsFlags[supportsFlag] ?? memoized();
        }
        const supportsLinearEasing = memoSupports(() => {
            try {
                document.createElement("div").animate({
                    opacity: 0
                }, {
                    easing: "linear(0, 1)"
                });
            } catch (e) {
                return false;
            }
            return true;
        }, "linearEasing");
        const cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;
        const supportedWaapiEasing = {
            linear: "linear",
            ease: "ease",
            easeIn: "ease-in",
            easeOut: "ease-out",
            easeInOut: "ease-in-out",
            circIn: cubicBezierAsString([ 0, .65, .55, 1 ]),
            circOut: cubicBezierAsString([ .55, 0, 1, .45 ]),
            backIn: cubicBezierAsString([ .31, .01, .66, -.59 ]),
            backOut: cubicBezierAsString([ .33, 1.53, .69, .99 ])
        };
        function mapEasingToNativeEasing(easing, duration) {
            if (!easing) return; else if (typeof easing === "function") return supportsLinearEasing() ? generateLinearEasing(easing, duration) : "ease-out"; else if (isBezierDefinition(easing)) return cubicBezierAsString(easing); else if (Array.isArray(easing)) return easing.map(segmentEasing => mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut); else return supportedWaapiEasing[easing];
        }
        function startWaapiAnimation(element, valueName, keyframes, {delay = 0, duration = 300, repeat = 0, repeatType = "loop", ease = "easeOut", times} = {}, pseudoElement = void 0) {
            const keyframeOptions = {
                [valueName]: keyframes
            };
            if (times) keyframeOptions.offset = times;
            const easing = mapEasingToNativeEasing(ease, duration);
            if (Array.isArray(easing)) keyframeOptions.easing = easing;
            if (statsBuffer.value) activeAnimations.waapi++;
            const options = {
                delay,
                duration,
                easing: !Array.isArray(easing) ? easing : "linear",
                fill: "both",
                iterations: repeat + 1,
                direction: repeatType === "reverse" ? "alternate" : "normal"
            };
            if (pseudoElement) options.pseudoElement = pseudoElement;
            const animation = element.animate(keyframeOptions, options);
            if (statsBuffer.value) animation.finished.finally(() => {
                activeAnimations.waapi--;
            });
            return animation;
        }
        function isGenerator(type) {
            return typeof type === "function" && "applyToOptions" in type;
        }
        function applyGeneratorOptions({type, ...options}) {
            if (isGenerator(type) && supportsLinearEasing()) return type.applyToOptions(options); else {
                options.duration ?? (options.duration = 300);
                options.ease ?? (options.ease = "easeOut");
            }
            return options;
        }
        class NativeAnimation extends WithPromise {
            constructor(options) {
                super();
                this.finishedTime = null;
                this.isStopped = false;
                if (!options) return;
                const {element, name, keyframes, pseudoElement, allowFlatten = false, finalKeyframe, onComplete} = options;
                this.isPseudoElement = Boolean(pseudoElement);
                this.allowFlatten = allowFlatten;
                this.options = options;
                errors_invariant(typeof options.type !== "string", `animateMini doesn't support "type" as a string. Did you mean to import { spring } from "motion"?`);
                const transition = applyGeneratorOptions(options);
                this.animation = startWaapiAnimation(element, name, keyframes, transition, pseudoElement);
                if (transition.autoplay === false) this.animation.pause();
                this.animation.onfinish = () => {
                    this.finishedTime = this.time;
                    if (!pseudoElement) {
                        const keyframe = getFinalKeyframe(keyframes, this.options, finalKeyframe, this.speed);
                        if (this.updateMotionValue) this.updateMotionValue(keyframe); else setStyle(element, name, keyframe);
                        this.animation.cancel();
                    }
                    onComplete?.();
                    this.notifyFinished();
                };
            }
            play() {
                if (this.isStopped) return;
                this.animation.play();
                if (this.state === "finished") this.updateFinished();
            }
            pause() {
                this.animation.pause();
            }
            complete() {
                this.animation.finish?.();
            }
            cancel() {
                try {
                    this.animation.cancel();
                } catch (e) {}
            }
            stop() {
                if (this.isStopped) return;
                this.isStopped = true;
                const {state} = this;
                if (state === "idle" || state === "finished") return;
                if (this.updateMotionValue) this.updateMotionValue(); else this.commitStyles();
                if (!this.isPseudoElement) this.cancel();
            }
            commitStyles() {
                if (!this.isPseudoElement) this.animation.commitStyles?.();
            }
            get duration() {
                const duration = this.animation.effect?.getComputedTiming?.().duration || 0;
                return millisecondsToSeconds(Number(duration));
            }
            get time() {
                return millisecondsToSeconds(Number(this.animation.currentTime) || 0);
            }
            set time(newTime) {
                this.finishedTime = null;
                this.animation.currentTime = time_conversion_secondsToMilliseconds(newTime);
            }
            get speed() {
                return this.animation.playbackRate;
            }
            set speed(newSpeed) {
                if (newSpeed < 0) this.finishedTime = null;
                this.animation.playbackRate = newSpeed;
            }
            get state() {
                return this.finishedTime !== null ? "finished" : this.animation.playState;
            }
            get startTime() {
                return Number(this.animation.startTime);
            }
            set startTime(newStartTime) {
                this.animation.startTime = newStartTime;
            }
            attachTimeline({timeline, observe}) {
                if (this.allowFlatten) this.animation.effect?.updateTiming({
                    easing: "linear"
                });
                this.animation.onfinish = null;
                if (timeline && supportsScrollTimeline()) {
                    this.animation.timeline = timeline;
                    return noop;
                } else return observe(this);
            }
        }
        const unsupportedEasingFunctions = {
            anticipate,
            backInOut,
            circInOut
        };
        function isUnsupportedEase(key) {
            return key in unsupportedEasingFunctions;
        }
        function replaceStringEasing(transition) {
            if (typeof transition.ease === "string" && isUnsupportedEase(transition.ease)) transition.ease = unsupportedEasingFunctions[transition.ease];
        }
        const sampleDelta = 10;
        class NativeAnimationExtended extends NativeAnimation {
            constructor(options) {
                replaceStringEasing(options);
                replaceTransitionType(options);
                super(options);
                if (options.startTime) this.startTime = options.startTime;
                this.options = options;
            }
            updateMotionValue(value) {
                const {motionValue, onUpdate, onComplete, element, ...options} = this.options;
                if (!motionValue) return;
                if (value !== void 0) {
                    motionValue.set(value);
                    return;
                }
                const sampleAnimation = new JSAnimation({
                    ...options,
                    autoplay: false
                });
                const sampleTime = time_conversion_secondsToMilliseconds(this.finishedTime ?? this.time);
                motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
                sampleAnimation.stop();
            }
        }
        const isAnimatable = (value, name) => {
            if (name === "zIndex") return false;
            if (typeof value === "number" || Array.isArray(value)) return true;
            if (typeof value === "string" && (complex.test(value) || value === "0") && !value.startsWith("url(")) return true;
            return false;
        };
        function hasKeyframesChanged(keyframes) {
            const current = keyframes[0];
            if (keyframes.length === 1) return true;
            for (let i = 0; i < keyframes.length; i++) if (keyframes[i] !== current) return true;
        }
        function canAnimate(keyframes, name, type, velocity) {
            const originKeyframe = keyframes[0];
            if (originKeyframe === null) return false;
            if (name === "display" || name === "visibility") return true;
            const targetKeyframe = keyframes[keyframes.length - 1];
            const isOriginAnimatable = isAnimatable(originKeyframe, name);
            const isTargetAnimatable = isAnimatable(targetKeyframe, name);
            errors_warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
            if (!isOriginAnimatable || !isTargetAnimatable) return false;
            return hasKeyframesChanged(keyframes) || (type === "spring" || isGenerator(type)) && velocity;
        }
        const acceleratedValues = new Set([ "opacity", "clipPath", "filter", "transform" ]);
        const supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
        function supportsBrowserAnimation(options) {
            const {motionValue, name, repeatDelay, repeatType, damping, type} = options;
            if (!isHTMLElement(motionValue?.owner?.current)) return false;
            const {onUpdate, transformTemplate} = motionValue.owner.getProps();
            return supportsWaapi() && name && acceleratedValues.has(name) && (name !== "transform" || !transformTemplate) && !onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
        }
        const MAX_RESOLVE_DELAY = 40;
        class AsyncMotionValueAnimation extends WithPromise {
            constructor({autoplay = true, delay = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", keyframes, name, motionValue, element, ...options}) {
                super();
                this.stop = () => {
                    if (this._animation) {
                        this._animation.stop();
                        this.stopTimeline?.();
                    }
                    this.keyframeResolver?.cancel();
                };
                this.createdAt = time.now();
                const optionsWithDefaults = {
                    autoplay,
                    delay,
                    type,
                    repeat,
                    repeatDelay,
                    repeatType,
                    name,
                    motionValue,
                    element,
                    ...options
                };
                const KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;
                this.keyframeResolver = new KeyframeResolver$1(keyframes, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue, element);
                this.keyframeResolver?.scheduleResolve();
            }
            onKeyframesResolved(keyframes, finalKeyframe, options, sync) {
                this.keyframeResolver = void 0;
                const {name, type, velocity, delay, isHandoff, onUpdate} = options;
                this.resolvedAt = time.now();
                if (!canAnimate(keyframes, name, type, velocity)) {
                    if (MotionGlobalConfig.instantAnimations || !delay) onUpdate?.(getFinalKeyframe(keyframes, options, finalKeyframe));
                    keyframes[0] = keyframes[keyframes.length - 1];
                    options.duration = 0;
                    options.repeat = 0;
                }
                const startTime = sync ? !this.resolvedAt ? this.createdAt : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : void 0;
                const resolvedOptions = {
                    startTime,
                    finalKeyframe,
                    ...options,
                    keyframes
                };
                const animation = !isHandoff && supportsBrowserAnimation(resolvedOptions) ? new NativeAnimationExtended({
                    ...resolvedOptions,
                    element: resolvedOptions.motionValue.owner.current
                }) : new JSAnimation(resolvedOptions);
                animation.finished.then(() => this.notifyFinished()).catch(noop);
                if (this.pendingTimeline) {
                    this.stopTimeline = animation.attachTimeline(this.pendingTimeline);
                    this.pendingTimeline = void 0;
                }
                this._animation = animation;
            }
            get finished() {
                if (!this._animation) return this._finished; else return this.animation.finished;
            }
            then(onResolve, _onReject) {
                return this.finished.finally(onResolve).then(() => {});
            }
            get animation() {
                if (!this._animation) {
                    this.keyframeResolver?.resume();
                    flushKeyframeResolvers();
                }
                return this._animation;
            }
            get duration() {
                return this.animation.duration;
            }
            get time() {
                return this.animation.time;
            }
            set time(newTime) {
                this.animation.time = newTime;
            }
            get speed() {
                return this.animation.speed;
            }
            get state() {
                return this.animation.state;
            }
            set speed(newSpeed) {
                this.animation.speed = newSpeed;
            }
            get startTime() {
                return this.animation.startTime;
            }
            attachTimeline(timeline) {
                if (this._animation) this.stopTimeline = this.animation.attachTimeline(timeline); else this.pendingTimeline = timeline;
                return () => this.stop();
            }
            play() {
                this.animation.play();
            }
            pause() {
                this.animation.pause();
            }
            complete() {
                this.animation.complete();
            }
            cancel() {
                if (this._animation) this.animation.cancel();
                this.keyframeResolver?.cancel();
            }
        }
        const get_final_keyframe_isNotNull = value => value !== null;
        function get_final_keyframe_getFinalKeyframe(keyframes, {repeat, repeatType = "loop"}, finalKeyframe) {
            const resolvedKeyframes = keyframes.filter(get_final_keyframe_isNotNull);
            const index = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
            return !index || finalKeyframe === void 0 ? resolvedKeyframes[index] : finalKeyframe;
        }
        const underDampedSpring = {
            type: "spring",
            stiffness: 500,
            damping: 25,
            restSpeed: 10
        };
        const criticallyDampedSpring = target => ({
            type: "spring",
            stiffness: 550,
            damping: target === 0 ? 2 * Math.sqrt(550) : 30,
            restSpeed: 10
        });
        const keyframesTransition = {
            type: "keyframes",
            duration: .8
        };
        const ease = {
            type: "keyframes",
            ease: [ .25, .1, .35, 1 ],
            duration: .3
        };
        const getDefaultTransition = (valueKey, {keyframes}) => {
            if (keyframes.length > 2) return keyframesTransition; else if (transformProps.has(valueKey)) return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes[1]) : underDampedSpring;
            return ease;
        };
        function isTransitionDefined({when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition}) {
            return !!Object.keys(transition).length;
        }
        const animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => onComplete => {
            const valueTransition = getValueTransition(transition, name) || {};
            const delay = valueTransition.delay || transition.delay || 0;
            let {elapsed = 0} = transition;
            elapsed -= time_conversion_secondsToMilliseconds(delay);
            const options = {
                keyframes: Array.isArray(target) ? target : [ null, target ],
                ease: "easeOut",
                velocity: value.getVelocity(),
                ...valueTransition,
                delay: -elapsed,
                onUpdate: v => {
                    value.set(v);
                    valueTransition.onUpdate && valueTransition.onUpdate(v);
                },
                onComplete: () => {
                    onComplete();
                    valueTransition.onComplete && valueTransition.onComplete();
                },
                name,
                motionValue: value,
                element: isHandoff ? void 0 : element
            };
            if (!isTransitionDefined(valueTransition)) Object.assign(options, getDefaultTransition(name, options));
            options.duration && (options.duration = time_conversion_secondsToMilliseconds(options.duration));
            options.repeatDelay && (options.repeatDelay = time_conversion_secondsToMilliseconds(options.repeatDelay));
            if (options.from !== void 0) options.keyframes[0] = options.from;
            let shouldSkip = false;
            if (options.type === false || options.duration === 0 && !options.repeatDelay) {
                options.duration = 0;
                if (options.delay === 0) shouldSkip = true;
            }
            if (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations) {
                shouldSkip = true;
                options.duration = 0;
                options.delay = 0;
            }
            options.allowFlatten = !valueTransition.type && !valueTransition.ease;
            if (shouldSkip && !isHandoff && value.get() !== void 0) {
                const finalKeyframe = get_final_keyframe_getFinalKeyframe(options.keyframes, valueTransition);
                if (finalKeyframe !== void 0) {
                    frame_frame.update(() => {
                        options.onUpdate(finalKeyframe);
                        options.onComplete();
                    });
                    return;
                }
            }
            return valueTransition.isSync ? new JSAnimation(options) : new AsyncMotionValueAnimation(options);
        };
        function shouldBlockAnimation({protectedKeys, needsAnimating}, key) {
            const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
            needsAnimating[key] = false;
            return shouldBlock;
        }
        function animateTarget(visualElement, targetAndTransition, {delay = 0, transitionOverride, type} = {}) {
            let {transition = visualElement.getDefaultTransition(), transitionEnd, ...target} = targetAndTransition;
            if (transitionOverride) transition = transitionOverride;
            const animations = [];
            const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
            for (const key in target) {
                const value = visualElement.getValue(key, visualElement.latestValues[key] ?? null);
                const valueTarget = target[key];
                if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) continue;
                const valueTransition = {
                    delay,
                    ...getValueTransition(transition || {}, key)
                };
                const currentValue = value.get();
                if (currentValue !== void 0 && !value.isAnimating && !Array.isArray(valueTarget) && valueTarget === currentValue && !valueTransition.velocity) continue;
                let isHandoff = false;
                if (window.MotionHandoffAnimation) {
                    const appearId = getOptimisedAppearId(visualElement);
                    if (appearId) {
                        const startTime = window.MotionHandoffAnimation(appearId, key, frame_frame);
                        if (startTime !== null) {
                            valueTransition.startTime = startTime;
                            isHandoff = true;
                        }
                    }
                }
                addValueToWillChange(visualElement, key);
                value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key) ? {
                    type: false
                } : valueTransition, visualElement, isHandoff));
                const animation = value.animation;
                if (animation) animations.push(animation);
            }
            if (transitionEnd) Promise.all(animations).then(() => {
                frame_frame.update(() => {
                    transitionEnd && setTarget(visualElement, transitionEnd);
                });
            });
            return animations;
        }
        function animateVariant(visualElement, variant, options = {}) {
            const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? visualElement.presenceContext?.custom : void 0);
            let {transition = visualElement.getDefaultTransition() || {}} = resolved || {};
            if (options.transitionOverride) transition = options.transitionOverride;
            const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
            const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
                const {delayChildren = 0, staggerChildren, staggerDirection} = transition;
                return animateChildren(visualElement, variant, forwardDelay, delayChildren, staggerChildren, staggerDirection, options);
            } : () => Promise.resolve();
            const {when} = transition;
            if (when) {
                const [first, last] = when === "beforeChildren" ? [ getAnimation, getChildAnimations ] : [ getChildAnimations, getAnimation ];
                return first().then(() => last());
            } else return Promise.all([ getAnimation(), getChildAnimations(options.delay) ]);
        }
        function animateChildren(visualElement, variant, delay = 0, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
            const animations = [];
            const numChildren = visualElement.variantChildren.size;
            const maxStaggerDuration = (numChildren - 1) * staggerChildren;
            const delayIsFunction = typeof delayChildren === "function";
            const generateStaggerDuration = delayIsFunction ? i => delayChildren(i, numChildren) : staggerDirection === 1 ? (i = 0) => i * staggerChildren : (i = 0) => maxStaggerDuration - i * staggerChildren;
            Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i) => {
                child.notify("AnimationStart", variant);
                animations.push(animateVariant(child, variant, {
                    ...options,
                    delay: delay + (delayIsFunction ? 0 : delayChildren) + generateStaggerDuration(i)
                }).then(() => child.notify("AnimationComplete", variant)));
            });
            return Promise.all(animations);
        }
        function sortByTreeOrder(a, b) {
            return a.sortNodePosition(b);
        }
        function animateVisualElement(visualElement, definition, options = {}) {
            visualElement.notify("AnimationStart", definition);
            let animation;
            if (Array.isArray(definition)) {
                const animations = definition.map(variant => animateVariant(visualElement, variant, options));
                animation = Promise.all(animations);
            } else if (typeof definition === "string") animation = animateVariant(visualElement, definition, options); else {
                const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
                animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
            }
            return animation.then(() => {
                visualElement.notify("AnimationComplete", definition);
            });
        }
        function shallowCompare(next, prev) {
            if (!Array.isArray(prev)) return false;
            const prevLength = prev.length;
            if (prevLength !== next.length) return false;
            for (let i = 0; i < prevLength; i++) if (prev[i] !== next[i]) return false;
            return true;
        }
        function isVariantLabel(v) {
            return typeof v === "string" || Array.isArray(v);
        }
        const variantPriorityOrder = [ "animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit" ];
        const variantProps = [ "initial", ...variantPriorityOrder ];
        const numVariantProps = variantProps.length;
        function getVariantContext(visualElement) {
            if (!visualElement) return;
            if (!visualElement.isControllingVariants) {
                const context = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
                if (visualElement.props.initial !== void 0) context.initial = visualElement.props.initial;
                return context;
            }
            const context = {};
            for (let i = 0; i < numVariantProps; i++) {
                const name = variantProps[i];
                const prop = visualElement.props[name];
                if (isVariantLabel(prop) || prop === false) context[name] = prop;
            }
            return context;
        }
        const reversePriorityOrder = [ ...variantPriorityOrder ].reverse();
        const numAnimationTypes = variantPriorityOrder.length;
        function animateList(visualElement) {
            return animations => Promise.all(animations.map(({animation, options}) => animateVisualElement(visualElement, animation, options)));
        }
        function createAnimationState(visualElement) {
            let animate = animateList(visualElement);
            let state = createState();
            let isInitialRender = true;
            const buildResolvedTypeValues = type => (acc, definition) => {
                const resolved = resolveVariant(visualElement, definition, type === "exit" ? visualElement.presenceContext?.custom : void 0);
                if (resolved) {
                    const {transition, transitionEnd, ...target} = resolved;
                    acc = {
                        ...acc,
                        ...target,
                        ...transitionEnd
                    };
                }
                return acc;
            };
            function setAnimateFunction(makeAnimator) {
                animate = makeAnimator(visualElement);
            }
            function animateChanges(changedActiveType) {
                const {props} = visualElement;
                const context = getVariantContext(visualElement.parent) || {};
                const animations = [];
                const removedKeys = new Set;
                let encounteredKeys = {};
                let removedVariantIndex = 1 / 0;
                for (let i = 0; i < numAnimationTypes; i++) {
                    const type = reversePriorityOrder[i];
                    const typeState = state[type];
                    const prop = props[type] !== void 0 ? props[type] : context[type];
                    const propIsVariant = isVariantLabel(prop);
                    const activeDelta = type === changedActiveType ? typeState.isActive : null;
                    if (activeDelta === false) removedVariantIndex = i;
                    let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
                    if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) isInherited = false;
                    typeState.protectedKeys = {
                        ...encounteredKeys
                    };
                    if (!typeState.isActive && activeDelta === null || !prop && !typeState.prevProp || isAnimationControls(prop) || typeof prop === "boolean") continue;
                    const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
                    let shouldAnimateType = variantDidChange || type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || i > removedVariantIndex && propIsVariant;
                    let handledRemovedValues = false;
                    const definitionList = Array.isArray(prop) ? prop : [ prop ];
                    let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
                    if (activeDelta === false) resolvedValues = {};
                    const {prevResolvedValues = {}} = typeState;
                    const allKeys = {
                        ...prevResolvedValues,
                        ...resolvedValues
                    };
                    const markToAnimate = key => {
                        shouldAnimateType = true;
                        if (removedKeys.has(key)) {
                            handledRemovedValues = true;
                            removedKeys.delete(key);
                        }
                        typeState.needsAnimating[key] = true;
                        const motionValue = visualElement.getValue(key);
                        if (motionValue) motionValue.liveStyle = false;
                    };
                    for (const key in allKeys) {
                        const next = resolvedValues[key];
                        const prev = prevResolvedValues[key];
                        if (encounteredKeys.hasOwnProperty(key)) continue;
                        let valueHasChanged = false;
                        if (isKeyframesTarget(next) && isKeyframesTarget(prev)) valueHasChanged = !shallowCompare(next, prev); else valueHasChanged = next !== prev;
                        if (valueHasChanged) if (next !== void 0 && next !== null) markToAnimate(key); else removedKeys.add(key); else if (next !== void 0 && removedKeys.has(key)) markToAnimate(key); else typeState.protectedKeys[key] = true;
                    }
                    typeState.prevProp = prop;
                    typeState.prevResolvedValues = resolvedValues;
                    if (typeState.isActive) encounteredKeys = {
                        ...encounteredKeys,
                        ...resolvedValues
                    };
                    if (isInitialRender && visualElement.blockInitialAnimation) shouldAnimateType = false;
                    const willAnimateViaParent = isInherited && variantDidChange;
                    const needsAnimating = !willAnimateViaParent || handledRemovedValues;
                    if (shouldAnimateType && needsAnimating) animations.push(...definitionList.map(animation => ({
                        animation,
                        options: {
                            type
                        }
                    })));
                }
                if (removedKeys.size) {
                    const fallbackAnimation = {};
                    if (typeof props.initial !== "boolean") {
                        const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial) ? props.initial[0] : props.initial);
                        if (initialTransition && initialTransition.transition) fallbackAnimation.transition = initialTransition.transition;
                    }
                    removedKeys.forEach(key => {
                        const fallbackTarget = visualElement.getBaseTarget(key);
                        const motionValue = visualElement.getValue(key);
                        if (motionValue) motionValue.liveStyle = true;
                        fallbackAnimation[key] = fallbackTarget ?? null;
                    });
                    animations.push({
                        animation: fallbackAnimation
                    });
                }
                let shouldAnimate = Boolean(animations.length);
                if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) shouldAnimate = false;
                isInitialRender = false;
                return shouldAnimate ? animate(animations) : Promise.resolve();
            }
            function setActive(type, isActive) {
                if (state[type].isActive === isActive) return Promise.resolve();
                visualElement.variantChildren?.forEach(child => child.animationState?.setActive(type, isActive));
                state[type].isActive = isActive;
                const animations = animateChanges(type);
                for (const key in state) state[key].protectedKeys = {};
                return animations;
            }
            return {
                animateChanges,
                setActive,
                setAnimateFunction,
                getState: () => state,
                reset: () => {
                    state = createState();
                    isInitialRender = true;
                }
            };
        }
        function checkVariantsDidChange(prev, next) {
            if (typeof next === "string") return next !== prev; else if (Array.isArray(next)) return !shallowCompare(next, prev);
            return false;
        }
        function createTypeState(isActive = false) {
            return {
                isActive,
                protectedKeys: {},
                needsAnimating: {},
                prevResolvedValues: {}
            };
        }
        function createState() {
            return {
                animate: createTypeState(true),
                whileInView: createTypeState(),
                whileHover: createTypeState(),
                whileTap: createTypeState(),
                whileDrag: createTypeState(),
                whileFocus: createTypeState(),
                exit: createTypeState()
            };
        }
        class Feature {
            constructor(node) {
                this.isMounted = false;
                this.node = node;
            }
            update() {}
        }
        class AnimationFeature extends Feature {
            constructor(node) {
                super(node);
                node.animationState || (node.animationState = createAnimationState(node));
            }
            updateAnimationControlsSubscription() {
                const {animate} = this.node.getProps();
                if (isAnimationControls(animate)) this.unmountControls = animate.subscribe(this.node);
            }
            mount() {
                this.updateAnimationControlsSubscription();
            }
            update() {
                const {animate} = this.node.getProps();
                const {animate: prevAnimate} = this.node.prevProps || {};
                if (animate !== prevAnimate) this.updateAnimationControlsSubscription();
            }
            unmount() {
                this.node.animationState.reset();
                this.unmountControls?.();
            }
        }
        let id = 0;
        class ExitAnimationFeature extends Feature {
            constructor() {
                super(...arguments);
                this.id = id++;
            }
            update() {
                if (!this.node.presenceContext) return;
                const {isPresent, onExitComplete} = this.node.presenceContext;
                const {isPresent: prevIsPresent} = this.node.prevPresenceContext || {};
                if (!this.node.animationState || isPresent === prevIsPresent) return;
                const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
                if (onExitComplete && !isPresent) exitAnimation.then(() => {
                    onExitComplete(this.id);
                });
            }
            mount() {
                const {register, onExitComplete} = this.node.presenceContext || {};
                if (onExitComplete) onExitComplete(this.id);
                if (register) this.unmount = register(this.id);
            }
            unmount() {}
        }
        const animations = {
            animation: {
                Feature: AnimationFeature
            },
            exit: {
                Feature: ExitAnimationFeature
            }
        };
        const isDragging = {
            x: false,
            y: false
        };
        function isDragActive() {
            return isDragging.x || isDragging.y;
        }
        function setDragLock(axis) {
            if (axis === "x" || axis === "y") if (isDragging[axis]) return null; else {
                isDragging[axis] = true;
                return () => {
                    isDragging[axis] = false;
                };
            } else if (isDragging.x || isDragging.y) return null; else {
                isDragging.x = isDragging.y = true;
                return () => {
                    isDragging.x = isDragging.y = false;
                };
            }
        }
        function addDomEvent(target, eventName, handler, options = {
            passive: true
        }) {
            target.addEventListener(eventName, handler, options);
            return () => target.removeEventListener(eventName, handler);
        }
        const isPrimaryPointer = event => {
            if (event.pointerType === "mouse") return typeof event.button !== "number" || event.button <= 0; else return event.isPrimary !== false;
        };
        function extractEventInfo(event) {
            return {
                point: {
                    x: event.pageX,
                    y: event.pageY
                }
            };
        }
        const addPointerInfo = handler => event => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
        function addPointerEvent(target, eventName, handler, options) {
            return addDomEvent(target, eventName, addPointerInfo(handler), options);
        }
        function convertBoundingBoxToBox({top, left, right, bottom}) {
            return {
                x: {
                    min: left,
                    max: right
                },
                y: {
                    min: top,
                    max: bottom
                }
            };
        }
        function convertBoxToBoundingBox({x, y}) {
            return {
                top: y.min,
                right: x.max,
                bottom: y.max,
                left: x.min
            };
        }
        function transformBoxPoints(point, transformPoint) {
            if (!transformPoint) return point;
            const topLeft = transformPoint({
                x: point.left,
                y: point.top
            });
            const bottomRight = transformPoint({
                x: point.right,
                y: point.bottom
            });
            return {
                top: topLeft.y,
                left: topLeft.x,
                bottom: bottomRight.y,
                right: bottomRight.x
            };
        }
        const SCALE_PRECISION = 1e-4;
        const SCALE_MIN = 1 - SCALE_PRECISION;
        const SCALE_MAX = 1 + SCALE_PRECISION;
        const TRANSLATE_PRECISION = .01;
        const TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
        const TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
        function calcLength(axis) {
            return axis.max - axis.min;
        }
        function isNear(value, target, maxDistance) {
            return Math.abs(value - target) <= maxDistance;
        }
        function calcAxisDelta(delta, source, target, origin = .5) {
            delta.origin = origin;
            delta.originPoint = mixNumber(source.min, source.max, delta.origin);
            delta.scale = calcLength(target) / calcLength(source);
            delta.translate = mixNumber(target.min, target.max, delta.origin) - delta.originPoint;
            if (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) delta.scale = 1;
            if (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) delta.translate = 0;
        }
        function calcBoxDelta(delta, source, target, origin) {
            calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
            calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
        }
        function calcRelativeAxis(target, relative, parent) {
            target.min = parent.min + relative.min;
            target.max = target.min + calcLength(relative);
        }
        function calcRelativeBox(target, relative, parent) {
            calcRelativeAxis(target.x, relative.x, parent.x);
            calcRelativeAxis(target.y, relative.y, parent.y);
        }
        function calcRelativeAxisPosition(target, layout, parent) {
            target.min = layout.min - parent.min;
            target.max = target.min + calcLength(layout);
        }
        function calcRelativePosition(target, layout, parent) {
            calcRelativeAxisPosition(target.x, layout.x, parent.x);
            calcRelativeAxisPosition(target.y, layout.y, parent.y);
        }
        const createAxisDelta = () => ({
            translate: 0,
            scale: 1,
            origin: 0,
            originPoint: 0
        });
        const createDelta = () => ({
            x: createAxisDelta(),
            y: createAxisDelta()
        });
        const createAxis = () => ({
            min: 0,
            max: 0
        });
        const createBox = () => ({
            x: createAxis(),
            y: createAxis()
        });
        function eachAxis(callback) {
            return [ callback("x"), callback("y") ];
        }
        function isIdentityScale(scale) {
            return scale === void 0 || scale === 1;
        }
        function hasScale({scale, scaleX, scaleY}) {
            return !isIdentityScale(scale) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
        }
        function hasTransform(values) {
            return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
        }
        function has2DTranslate(values) {
            return is2DTranslate(values.x) || is2DTranslate(values.y);
        }
        function is2DTranslate(value) {
            return value && value !== "0%";
        }
        function scalePoint(point, scale, originPoint) {
            const distanceFromOrigin = point - originPoint;
            const scaled = scale * distanceFromOrigin;
            return originPoint + scaled;
        }
        function applyPointDelta(point, translate, scale, originPoint, boxScale) {
            if (boxScale !== void 0) point = scalePoint(point, boxScale, originPoint);
            return scalePoint(point, scale, originPoint) + translate;
        }
        function applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {
            axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);
            axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);
        }
        function applyBoxDelta(box, {x, y}) {
            applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
            applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
        }
        const TREE_SCALE_SNAP_MIN = .999999999999;
        const TREE_SCALE_SNAP_MAX = 1.0000000000001;
        function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
            const treeLength = treePath.length;
            if (!treeLength) return;
            treeScale.x = treeScale.y = 1;
            let node;
            let delta;
            for (let i = 0; i < treeLength; i++) {
                node = treePath[i];
                delta = node.projectionDelta;
                const {visualElement} = node.options;
                if (visualElement && visualElement.props.style && visualElement.props.style.display === "contents") continue;
                if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) transformBox(box, {
                    x: -node.scroll.offset.x,
                    y: -node.scroll.offset.y
                });
                if (delta) {
                    treeScale.x *= delta.x.scale;
                    treeScale.y *= delta.y.scale;
                    applyBoxDelta(box, delta);
                }
                if (isSharedTransition && hasTransform(node.latestValues)) transformBox(box, node.latestValues);
            }
            if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) treeScale.x = 1;
            if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) treeScale.y = 1;
        }
        function translateAxis(axis, distance) {
            axis.min = axis.min + distance;
            axis.max = axis.max + distance;
        }
        function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = .5) {
            const originPoint = mixNumber(axis.min, axis.max, axisOrigin);
            applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
        }
        function transformBox(box, transform) {
            transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);
            transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);
        }
        function measureViewportBox(instance, transformPoint) {
            return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));
        }
        function measurePageBox(element, rootProjectionNode, transformPagePoint) {
            const viewportBox = measureViewportBox(element, transformPagePoint);
            const {scroll} = rootProjectionNode;
            if (scroll) {
                translateAxis(viewportBox.x, scroll.offset.x);
                translateAxis(viewportBox.y, scroll.offset.y);
            }
            return viewportBox;
        }
        const getContextWindow = ({current}) => current ? current.ownerDocument.defaultView : null;
        function isRefObject(ref) {
            return ref && typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
        }
        const distance = (a, b) => Math.abs(a - b);
        function distance2D(a, b) {
            const xDelta = distance(a.x, b.x);
            const yDelta = distance(a.y, b.y);
            return Math.sqrt(xDelta ** 2 + yDelta ** 2);
        }
        class PanSession {
            constructor(event, handlers, {transformPagePoint, contextWindow = window, dragSnapToOrigin = false, distanceThreshold = 3} = {}) {
                this.startEvent = null;
                this.lastMoveEvent = null;
                this.lastMoveEventInfo = null;
                this.handlers = {};
                this.contextWindow = window;
                this.updatePoint = () => {
                    if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
                    const info = getPanInfo(this.lastMoveEventInfo, this.history);
                    const isPanStarted = this.startEvent !== null;
                    const isDistancePastThreshold = distance2D(info.offset, {
                        x: 0,
                        y: 0
                    }) >= this.distanceThreshold;
                    if (!isPanStarted && !isDistancePastThreshold) return;
                    const {point} = info;
                    const {timestamp} = frameData;
                    this.history.push({
                        ...point,
                        timestamp
                    });
                    const {onStart, onMove} = this.handlers;
                    if (!isPanStarted) {
                        onStart && onStart(this.lastMoveEvent, info);
                        this.startEvent = this.lastMoveEvent;
                    }
                    onMove && onMove(this.lastMoveEvent, info);
                };
                this.handlePointerMove = (event, info) => {
                    this.lastMoveEvent = event;
                    this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);
                    frame_frame.update(this.updatePoint, true);
                };
                this.handlePointerUp = (event, info) => {
                    this.end();
                    const {onEnd, onSessionEnd, resumeAnimation} = this.handlers;
                    if (this.dragSnapToOrigin) resumeAnimation && resumeAnimation();
                    if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
                    const panInfo = getPanInfo(event.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info, this.transformPagePoint), this.history);
                    if (this.startEvent && onEnd) onEnd(event, panInfo);
                    onSessionEnd && onSessionEnd(event, panInfo);
                };
                if (!isPrimaryPointer(event)) return;
                this.dragSnapToOrigin = dragSnapToOrigin;
                this.handlers = handlers;
                this.transformPagePoint = transformPagePoint;
                this.distanceThreshold = distanceThreshold;
                this.contextWindow = contextWindow || window;
                const info = extractEventInfo(event);
                const initialInfo = transformPoint(info, this.transformPagePoint);
                const {point} = initialInfo;
                const {timestamp} = frameData;
                this.history = [ {
                    ...point,
                    timestamp
                } ];
                const {onSessionStart} = handlers;
                onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
                this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
            }
            updateHandlers(handlers) {
                this.handlers = handlers;
            }
            end() {
                this.removeListeners && this.removeListeners();
                cancelFrame(this.updatePoint);
            }
        }
        function transformPoint(info, transformPagePoint) {
            return transformPagePoint ? {
                point: transformPagePoint(info.point)
            } : info;
        }
        function subtractPoint(a, b) {
            return {
                x: a.x - b.x,
                y: a.y - b.y
            };
        }
        function getPanInfo({point}, history) {
            return {
                point,
                delta: subtractPoint(point, lastDevicePoint(history)),
                offset: subtractPoint(point, startDevicePoint(history)),
                velocity: getVelocity(history, .1)
            };
        }
        function startDevicePoint(history) {
            return history[0];
        }
        function lastDevicePoint(history) {
            return history[history.length - 1];
        }
        function getVelocity(history, timeDelta) {
            if (history.length < 2) return {
                x: 0,
                y: 0
            };
            let i = history.length - 1;
            let timestampedPoint = null;
            const lastPoint = lastDevicePoint(history);
            while (i >= 0) {
                timestampedPoint = history[i];
                if (lastPoint.timestamp - timestampedPoint.timestamp > time_conversion_secondsToMilliseconds(timeDelta)) break;
                i--;
            }
            if (!timestampedPoint) return {
                x: 0,
                y: 0
            };
            const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
            if (time === 0) return {
                x: 0,
                y: 0
            };
            const currentVelocity = {
                x: (lastPoint.x - timestampedPoint.x) / time,
                y: (lastPoint.y - timestampedPoint.y) / time
            };
            if (currentVelocity.x === 1 / 0) currentVelocity.x = 0;
            if (currentVelocity.y === 1 / 0) currentVelocity.y = 0;
            return currentVelocity;
        }
        function applyConstraints(point, {min, max}, elastic) {
            if (min !== void 0 && point < min) point = elastic ? mixNumber(min, point, elastic.min) : Math.max(point, min); else if (max !== void 0 && point > max) point = elastic ? mixNumber(max, point, elastic.max) : Math.min(point, max);
            return point;
        }
        function calcRelativeAxisConstraints(axis, min, max) {
            return {
                min: min !== void 0 ? axis.min + min : void 0,
                max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
            };
        }
        function calcRelativeConstraints(layoutBox, {top, left, bottom, right}) {
            return {
                x: calcRelativeAxisConstraints(layoutBox.x, left, right),
                y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
            };
        }
        function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
            let min = constraintsAxis.min - layoutAxis.min;
            let max = constraintsAxis.max - layoutAxis.max;
            if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) [min, max] = [ max, min ];
            return {
                min,
                max
            };
        }
        function calcViewportConstraints(layoutBox, constraintsBox) {
            return {
                x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
                y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
            };
        }
        function calcOrigin(source, target) {
            let origin = .5;
            const sourceLength = calcLength(source);
            const targetLength = calcLength(target);
            if (targetLength > sourceLength) origin = progress(target.min, target.max - sourceLength, source.min); else if (sourceLength > targetLength) origin = progress(source.min, source.max - targetLength, target.min);
            return clamp(0, 1, origin);
        }
        function rebaseAxisConstraints(layout, constraints) {
            const relativeConstraints = {};
            if (constraints.min !== void 0) relativeConstraints.min = constraints.min - layout.min;
            if (constraints.max !== void 0) relativeConstraints.max = constraints.max - layout.min;
            return relativeConstraints;
        }
        const defaultElastic = .35;
        function resolveDragElastic(dragElastic = defaultElastic) {
            if (dragElastic === false) dragElastic = 0; else if (dragElastic === true) dragElastic = defaultElastic;
            return {
                x: resolveAxisElastic(dragElastic, "left", "right"),
                y: resolveAxisElastic(dragElastic, "top", "bottom")
            };
        }
        function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
            return {
                min: resolvePointElastic(dragElastic, minLabel),
                max: resolvePointElastic(dragElastic, maxLabel)
            };
        }
        function resolvePointElastic(dragElastic, label) {
            return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
        }
        const elementDragControls = new WeakMap;
        class VisualElementDragControls {
            constructor(visualElement) {
                this.openDragLock = null;
                this.isDragging = false;
                this.currentDirection = null;
                this.originPoint = {
                    x: 0,
                    y: 0
                };
                this.constraints = false;
                this.hasMutatedConstraints = false;
                this.elastic = createBox();
                this.latestPointerEvent = null;
                this.latestPanInfo = null;
                this.visualElement = visualElement;
            }
            start(originEvent, {snapToCursor = false, distanceThreshold} = {}) {
                const {presenceContext} = this.visualElement;
                if (presenceContext && presenceContext.isPresent === false) return;
                const onSessionStart = event => {
                    const {dragSnapToOrigin} = this.getProps();
                    dragSnapToOrigin ? this.pauseAnimation() : this.stopAnimation();
                    if (snapToCursor) this.snapToCursor(extractEventInfo(event).point);
                };
                const onStart = (event, info) => {
                    const {drag, dragPropagation, onDragStart} = this.getProps();
                    if (drag && !dragPropagation) {
                        if (this.openDragLock) this.openDragLock();
                        this.openDragLock = setDragLock(drag);
                        if (!this.openDragLock) return;
                    }
                    this.latestPointerEvent = event;
                    this.latestPanInfo = info;
                    this.isDragging = true;
                    this.currentDirection = null;
                    this.resolveConstraints();
                    if (this.visualElement.projection) {
                        this.visualElement.projection.isAnimationBlocked = true;
                        this.visualElement.projection.target = void 0;
                    }
                    eachAxis(axis => {
                        let current = this.getAxisMotionValue(axis).get() || 0;
                        if (percent.test(current)) {
                            const {projection} = this.visualElement;
                            if (projection && projection.layout) {
                                const measuredAxis = projection.layout.layoutBox[axis];
                                if (measuredAxis) {
                                    const length = calcLength(measuredAxis);
                                    current = length * (parseFloat(current) / 100);
                                }
                            }
                        }
                        this.originPoint[axis] = current;
                    });
                    if (onDragStart) frame_frame.postRender(() => onDragStart(event, info));
                    addValueToWillChange(this.visualElement, "transform");
                    const {animationState} = this.visualElement;
                    animationState && animationState.setActive("whileDrag", true);
                };
                const onMove = (event, info) => {
                    this.latestPointerEvent = event;
                    this.latestPanInfo = info;
                    const {dragPropagation, dragDirectionLock, onDirectionLock, onDrag} = this.getProps();
                    if (!dragPropagation && !this.openDragLock) return;
                    const {offset} = info;
                    if (dragDirectionLock && this.currentDirection === null) {
                        this.currentDirection = getCurrentDirection(offset);
                        if (this.currentDirection !== null) onDirectionLock && onDirectionLock(this.currentDirection);
                        return;
                    }
                    this.updateAxis("x", info.point, offset);
                    this.updateAxis("y", info.point, offset);
                    this.visualElement.render();
                    onDrag && onDrag(event, info);
                };
                const onSessionEnd = (event, info) => {
                    this.latestPointerEvent = event;
                    this.latestPanInfo = info;
                    this.stop(event, info);
                    this.latestPointerEvent = null;
                    this.latestPanInfo = null;
                };
                const resumeAnimation = () => eachAxis(axis => this.getAnimationState(axis) === "paused" && this.getAxisMotionValue(axis).animation?.play());
                const {dragSnapToOrigin} = this.getProps();
                this.panSession = new PanSession(originEvent, {
                    onSessionStart,
                    onStart,
                    onMove,
                    onSessionEnd,
                    resumeAnimation
                }, {
                    transformPagePoint: this.visualElement.getTransformPagePoint(),
                    dragSnapToOrigin,
                    distanceThreshold,
                    contextWindow: getContextWindow(this.visualElement)
                });
            }
            stop(event, panInfo) {
                const finalEvent = event || this.latestPointerEvent;
                const finalPanInfo = panInfo || this.latestPanInfo;
                const isDragging = this.isDragging;
                this.cancel();
                if (!isDragging || !finalPanInfo || !finalEvent) return;
                const {velocity} = finalPanInfo;
                this.startAnimation(velocity);
                const {onDragEnd} = this.getProps();
                if (onDragEnd) frame_frame.postRender(() => onDragEnd(finalEvent, finalPanInfo));
            }
            cancel() {
                this.isDragging = false;
                const {projection, animationState} = this.visualElement;
                if (projection) projection.isAnimationBlocked = false;
                this.panSession && this.panSession.end();
                this.panSession = void 0;
                const {dragPropagation} = this.getProps();
                if (!dragPropagation && this.openDragLock) {
                    this.openDragLock();
                    this.openDragLock = null;
                }
                animationState && animationState.setActive("whileDrag", false);
            }
            updateAxis(axis, _point, offset) {
                const {drag} = this.getProps();
                if (!offset || !shouldDrag(axis, drag, this.currentDirection)) return;
                const axisValue = this.getAxisMotionValue(axis);
                let next = this.originPoint[axis] + offset[axis];
                if (this.constraints && this.constraints[axis]) next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
                axisValue.set(next);
            }
            resolveConstraints() {
                const {dragConstraints, dragElastic} = this.getProps();
                const layout = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : this.visualElement.projection?.layout;
                const prevConstraints = this.constraints;
                if (dragConstraints && isRefObject(dragConstraints)) {
                    if (!this.constraints) this.constraints = this.resolveRefConstraints();
                } else if (dragConstraints && layout) this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints); else this.constraints = false;
                this.elastic = resolveDragElastic(dragElastic);
                if (prevConstraints !== this.constraints && layout && this.constraints && !this.hasMutatedConstraints) eachAxis(axis => {
                    if (this.constraints !== false && this.getAxisMotionValue(axis)) this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);
                });
            }
            resolveRefConstraints() {
                const {dragConstraints: constraints, onMeasureDragConstraints} = this.getProps();
                if (!constraints || !isRefObject(constraints)) return false;
                const constraintsElement = constraints.current;
                errors_invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
                const {projection} = this.visualElement;
                if (!projection || !projection.layout) return false;
                const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
                let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
                if (onMeasureDragConstraints) {
                    const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
                    this.hasMutatedConstraints = !!userConstraints;
                    if (userConstraints) measuredConstraints = convertBoundingBoxToBox(userConstraints);
                }
                return measuredConstraints;
            }
            startAnimation(velocity) {
                const {drag, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd} = this.getProps();
                const constraints = this.constraints || {};
                const momentumAnimations = eachAxis(axis => {
                    if (!shouldDrag(axis, drag, this.currentDirection)) return;
                    let transition = constraints && constraints[axis] || {};
                    if (dragSnapToOrigin) transition = {
                        min: 0,
                        max: 0
                    };
                    const bounceStiffness = dragElastic ? 200 : 1e6;
                    const bounceDamping = dragElastic ? 40 : 1e7;
                    const inertia = {
                        type: "inertia",
                        velocity: dragMomentum ? velocity[axis] : 0,
                        bounceStiffness,
                        bounceDamping,
                        timeConstant: 750,
                        restDelta: 1,
                        restSpeed: 10,
                        ...dragTransition,
                        ...transition
                    };
                    return this.startAxisValueAnimation(axis, inertia);
                });
                return Promise.all(momentumAnimations).then(onDragTransitionEnd);
            }
            startAxisValueAnimation(axis, transition) {
                const axisValue = this.getAxisMotionValue(axis);
                addValueToWillChange(this.visualElement, axis);
                return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));
            }
            stopAnimation() {
                eachAxis(axis => this.getAxisMotionValue(axis).stop());
            }
            pauseAnimation() {
                eachAxis(axis => this.getAxisMotionValue(axis).animation?.pause());
            }
            getAnimationState(axis) {
                return this.getAxisMotionValue(axis).animation?.state;
            }
            getAxisMotionValue(axis) {
                const dragKey = `_drag${axis.toUpperCase()}`;
                const props = this.visualElement.getProps();
                const externalMotionValue = props[dragKey];
                return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
            }
            snapToCursor(point) {
                eachAxis(axis => {
                    const {drag} = this.getProps();
                    if (!shouldDrag(axis, drag, this.currentDirection)) return;
                    const {projection} = this.visualElement;
                    const axisValue = this.getAxisMotionValue(axis);
                    if (projection && projection.layout) {
                        const {min, max} = projection.layout.layoutBox[axis];
                        axisValue.set(point[axis] - mixNumber(min, max, .5));
                    }
                });
            }
            scalePositionWithinConstraints() {
                if (!this.visualElement.current) return;
                const {drag, dragConstraints} = this.getProps();
                const {projection} = this.visualElement;
                if (!isRefObject(dragConstraints) || !projection || !this.constraints) return;
                this.stopAnimation();
                const boxProgress = {
                    x: 0,
                    y: 0
                };
                eachAxis(axis => {
                    const axisValue = this.getAxisMotionValue(axis);
                    if (axisValue && this.constraints !== false) {
                        const latest = axisValue.get();
                        boxProgress[axis] = calcOrigin({
                            min: latest,
                            max: latest
                        }, this.constraints[axis]);
                    }
                });
                const {transformTemplate} = this.visualElement.getProps();
                this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
                projection.root && projection.root.updateScroll();
                projection.updateLayout();
                this.resolveConstraints();
                eachAxis(axis => {
                    if (!shouldDrag(axis, drag, null)) return;
                    const axisValue = this.getAxisMotionValue(axis);
                    const {min, max} = this.constraints[axis];
                    axisValue.set(mixNumber(min, max, boxProgress[axis]));
                });
            }
            addListeners() {
                if (!this.visualElement.current) return;
                elementDragControls.set(this.visualElement, this);
                const element = this.visualElement.current;
                const stopPointerListener = addPointerEvent(element, "pointerdown", event => {
                    const {drag, dragListener = true} = this.getProps();
                    drag && dragListener && this.start(event);
                });
                const measureDragConstraints = () => {
                    const {dragConstraints} = this.getProps();
                    if (isRefObject(dragConstraints) && dragConstraints.current) this.constraints = this.resolveRefConstraints();
                };
                const {projection} = this.visualElement;
                const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
                if (projection && !projection.layout) {
                    projection.root && projection.root.updateScroll();
                    projection.updateLayout();
                }
                frame_frame.read(measureDragConstraints);
                const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
                const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({delta, hasLayoutChanged}) => {
                    if (this.isDragging && hasLayoutChanged) {
                        eachAxis(axis => {
                            const motionValue = this.getAxisMotionValue(axis);
                            if (!motionValue) return;
                            this.originPoint[axis] += delta[axis].translate;
                            motionValue.set(motionValue.get() + delta[axis].translate);
                        });
                        this.visualElement.render();
                    }
                });
                return () => {
                    stopResizeListener();
                    stopPointerListener();
                    stopMeasureLayoutListener();
                    stopLayoutUpdateListener && stopLayoutUpdateListener();
                };
            }
            getProps() {
                const props = this.visualElement.getProps();
                const {drag = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true} = props;
                return {
                    ...props,
                    drag,
                    dragDirectionLock,
                    dragPropagation,
                    dragConstraints,
                    dragElastic,
                    dragMomentum
                };
            }
        }
        function shouldDrag(direction, drag, currentDirection) {
            return (drag === true || drag === direction) && (currentDirection === null || currentDirection === direction);
        }
        function getCurrentDirection(offset, lockThreshold = 10) {
            let direction = null;
            if (Math.abs(offset.y) > lockThreshold) direction = "y"; else if (Math.abs(offset.x) > lockThreshold) direction = "x";
            return direction;
        }
        class DragGesture extends Feature {
            constructor(node) {
                super(node);
                this.removeGroupControls = noop;
                this.removeListeners = noop;
                this.controls = new VisualElementDragControls(node);
            }
            mount() {
                const {dragControls} = this.node.getProps();
                if (dragControls) this.removeGroupControls = dragControls.subscribe(this.controls);
                this.removeListeners = this.controls.addListeners() || noop;
            }
            unmount() {
                this.removeGroupControls();
                this.removeListeners();
            }
        }
        const asyncHandler = handler => (event, info) => {
            if (handler) frame_frame.postRender(() => handler(event, info));
        };
        class PanGesture extends Feature {
            constructor() {
                super(...arguments);
                this.removePointerDownListener = noop;
            }
            onPointerDown(pointerDownEvent) {
                this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
                    transformPagePoint: this.node.getTransformPagePoint(),
                    contextWindow: getContextWindow(this.node)
                });
            }
            createPanHandlers() {
                const {onPanSessionStart, onPanStart, onPan, onPanEnd} = this.node.getProps();
                return {
                    onSessionStart: asyncHandler(onPanSessionStart),
                    onStart: asyncHandler(onPanStart),
                    onMove: onPan,
                    onEnd: (event, info) => {
                        delete this.session;
                        if (onPanEnd) frame_frame.postRender(() => onPanEnd(event, info));
                    }
                };
            }
            mount() {
                this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", event => this.onPointerDown(event));
            }
            update() {
                this.session && this.session.updateHandlers(this.createPanHandlers());
            }
            unmount() {
                this.removePointerDownListener();
                this.session && this.session.end();
            }
        }
        const {schedule: microtask, cancel: cancelMicrotask} = createRenderBatcher(queueMicrotask, false);
        "use client";
        const SwitchLayoutGroupContext = (0, react.createContext)({});
        const globalProjectionState = {
            hasAnimatedSinceResize: true,
            hasEverUpdated: false
        };
        function pixelsToPercent(pixels, axis) {
            if (axis.max === axis.min) return 0;
            return pixels / (axis.max - axis.min) * 100;
        }
        const correctBorderRadius = {
            correct: (latest, node) => {
                if (!node.target) return latest;
                if (typeof latest === "string") if (px.test(latest)) latest = parseFloat(latest); else return latest;
                const x = pixelsToPercent(latest, node.target.x);
                const y = pixelsToPercent(latest, node.target.y);
                return `${x}% ${y}%`;
            }
        };
        const correctBoxShadow = {
            correct: (latest, {treeScale, projectionDelta}) => {
                const original = latest;
                const shadow = complex.parse(latest);
                if (shadow.length > 5) return original;
                const template = complex.createTransformer(latest);
                const offset = typeof shadow[0] !== "number" ? 1 : 0;
                const xScale = projectionDelta.x.scale * treeScale.x;
                const yScale = projectionDelta.y.scale * treeScale.y;
                shadow[0 + offset] /= xScale;
                shadow[1 + offset] /= yScale;
                const averageScale = mixNumber(xScale, yScale, .5);
                if (typeof shadow[2 + offset] === "number") shadow[2 + offset] /= averageScale;
                if (typeof shadow[3 + offset] === "number") shadow[3 + offset] /= averageScale;
                return template(shadow);
            }
        };
        const scaleCorrectors = {};
        function addScaleCorrector(correctors) {
            for (const key in correctors) {
                scaleCorrectors[key] = correctors[key];
                if (isCSSVariableName(key)) scaleCorrectors[key].isCSSVariable = true;
            }
        }
        "use client";
        let hasTakenAnySnapshot = false;
        class MeasureLayoutWithContext extends react.Component {
            componentDidMount() {
                const {visualElement, layoutGroup, switchLayoutGroup, layoutId} = this.props;
                const {projection} = visualElement;
                addScaleCorrector(defaultScaleCorrectors);
                if (projection) {
                    if (layoutGroup.group) layoutGroup.group.add(projection);
                    if (switchLayoutGroup && switchLayoutGroup.register && layoutId) switchLayoutGroup.register(projection);
                    if (hasTakenAnySnapshot) projection.root.didUpdate();
                    projection.addEventListener("animationComplete", () => {
                        this.safeToRemove();
                    });
                    projection.setOptions({
                        ...projection.options,
                        onExitComplete: () => this.safeToRemove()
                    });
                }
                globalProjectionState.hasEverUpdated = true;
            }
            getSnapshotBeforeUpdate(prevProps) {
                const {layoutDependency, visualElement, drag, isPresent} = this.props;
                const {projection} = visualElement;
                if (!projection) return null;
                projection.isPresent = isPresent;
                hasTakenAnySnapshot = true;
                if (drag || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0 || prevProps.isPresent !== isPresent) projection.willUpdate(); else this.safeToRemove();
                if (prevProps.isPresent !== isPresent) if (isPresent) projection.promote(); else if (!projection.relegate()) frame_frame.postRender(() => {
                    const stack = projection.getStack();
                    if (!stack || !stack.members.length) this.safeToRemove();
                });
                return null;
            }
            componentDidUpdate() {
                const {projection} = this.props.visualElement;
                if (projection) {
                    projection.root.didUpdate();
                    microtask.postRender(() => {
                        if (!projection.currentAnimation && projection.isLead()) this.safeToRemove();
                    });
                }
            }
            componentWillUnmount() {
                const {visualElement, layoutGroup, switchLayoutGroup: promoteContext} = this.props;
                const {projection} = visualElement;
                if (projection) {
                    projection.scheduleCheckAfterUnmount();
                    if (layoutGroup && layoutGroup.group) layoutGroup.group.remove(projection);
                    if (promoteContext && promoteContext.deregister) promoteContext.deregister(projection);
                }
            }
            safeToRemove() {
                const {safeToRemove} = this.props;
                safeToRemove && safeToRemove();
            }
            render() {
                return null;
            }
        }
        function MeasureLayout(props) {
            const [isPresent, safeToRemove] = usePresence();
            const layoutGroup = (0, react.useContext)(LayoutGroupContext);
            return (0, jsx_runtime.jsx)(MeasureLayoutWithContext, {
                ...props,
                layoutGroup,
                switchLayoutGroup: (0, react.useContext)(SwitchLayoutGroupContext),
                isPresent,
                safeToRemove
            });
        }
        const defaultScaleCorrectors = {
            borderRadius: {
                ...correctBorderRadius,
                applyTo: [ "borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius" ]
            },
            borderTopLeftRadius: correctBorderRadius,
            borderTopRightRadius: correctBorderRadius,
            borderBottomLeftRadius: correctBorderRadius,
            borderBottomRightRadius: correctBorderRadius,
            boxShadow: correctBoxShadow
        };
        function isSVGElement(element) {
            return is_object_isObject(element) && "ownerSVGElement" in element;
        }
        function isSVGSVGElement(element) {
            return isSVGElement(element) && element.tagName === "svg";
        }
        function animateSingleValue(value, keyframes, options) {
            const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
            motionValue$1.start(animateMotionValue("", motionValue$1, keyframes, options));
            return motionValue$1.animation;
        }
        const compareByDepth = (a, b) => a.depth - b.depth;
        class FlatTree {
            constructor() {
                this.children = [];
                this.isDirty = false;
            }
            add(child) {
                addUniqueItem(this.children, child);
                this.isDirty = true;
            }
            remove(child) {
                removeItem(this.children, child);
                this.isDirty = true;
            }
            forEach(callback) {
                this.isDirty && this.children.sort(compareByDepth);
                this.isDirty = false;
                this.children.forEach(callback);
            }
        }
        function delay(callback, timeout) {
            const start = time.now();
            const checkElapsed = ({timestamp}) => {
                const elapsed = timestamp - start;
                if (elapsed >= timeout) {
                    cancelFrame(checkElapsed);
                    callback(elapsed - timeout);
                }
            };
            frame_frame.setup(checkElapsed, true);
            return () => cancelFrame(checkElapsed);
        }
        function resolveMotionValue(value) {
            return isMotionValue(value) ? value.get() : value;
        }
        const borders = [ "TopLeft", "TopRight", "BottomLeft", "BottomRight" ];
        const numBorders = borders.length;
        const asNumber = value => typeof value === "string" ? parseFloat(value) : value;
        const isPx = value => typeof value === "number" || px.test(value);
        function mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {
            if (shouldCrossfadeOpacity) {
                target.opacity = mixNumber(0, lead.opacity ?? 1, easeCrossfadeIn(progress));
                target.opacityExit = mixNumber(follow.opacity ?? 1, 0, easeCrossfadeOut(progress));
            } else if (isOnlyMember) target.opacity = mixNumber(follow.opacity ?? 1, lead.opacity ?? 1, progress);
            for (let i = 0; i < numBorders; i++) {
                const borderLabel = `border${borders[i]}Radius`;
                let followRadius = getRadius(follow, borderLabel);
                let leadRadius = getRadius(lead, borderLabel);
                if (followRadius === void 0 && leadRadius === void 0) continue;
                followRadius || (followRadius = 0);
                leadRadius || (leadRadius = 0);
                const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
                if (canMix) {
                    target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress), 0);
                    if (percent.test(leadRadius) || percent.test(followRadius)) target[borderLabel] += "%";
                } else target[borderLabel] = leadRadius;
            }
            if (follow.rotate || lead.rotate) target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress);
        }
        function getRadius(values, radiusName) {
            return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
        }
        const easeCrossfadeIn = compress(0, .5, circOut);
        const easeCrossfadeOut = compress(.5, .95, noop);
        function compress(min, max, easing) {
            return p => {
                if (p < min) return 0;
                if (p > max) return 1;
                return easing(progress(min, max, p));
            };
        }
        function copyAxisInto(axis, originAxis) {
            axis.min = originAxis.min;
            axis.max = originAxis.max;
        }
        function copyBoxInto(box, originBox) {
            copyAxisInto(box.x, originBox.x);
            copyAxisInto(box.y, originBox.y);
        }
        function copyAxisDeltaInto(delta, originDelta) {
            delta.translate = originDelta.translate;
            delta.scale = originDelta.scale;
            delta.originPoint = originDelta.originPoint;
            delta.origin = originDelta.origin;
        }
        function removePointDelta(point, translate, scale, originPoint, boxScale) {
            point -= translate;
            point = scalePoint(point, 1 / scale, originPoint);
            if (boxScale !== void 0) point = scalePoint(point, 1 / boxScale, originPoint);
            return point;
        }
        function removeAxisDelta(axis, translate = 0, scale = 1, origin = .5, boxScale, originAxis = axis, sourceAxis = axis) {
            if (percent.test(translate)) {
                translate = parseFloat(translate);
                const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);
                translate = relativeProgress - sourceAxis.min;
            }
            if (typeof translate !== "number") return;
            let originPoint = mixNumber(originAxis.min, originAxis.max, origin);
            if (axis === originAxis) originPoint -= translate;
            axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);
            axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);
        }
        function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
            removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
        }
        const xKeys = [ "x", "scaleX", "originX" ];
        const yKeys = [ "y", "scaleY", "originY" ];
        function removeBoxTransforms(box, transforms, originBox, sourceBox) {
            removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
            removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
        }
        function isAxisDeltaZero(delta) {
            return delta.translate === 0 && delta.scale === 1;
        }
        function isDeltaZero(delta) {
            return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
        }
        function axisEquals(a, b) {
            return a.min === b.min && a.max === b.max;
        }
        function boxEquals(a, b) {
            return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);
        }
        function axisEqualsRounded(a, b) {
            return Math.round(a.min) === Math.round(b.min) && Math.round(a.max) === Math.round(b.max);
        }
        function boxEqualsRounded(a, b) {
            return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);
        }
        function aspectRatio(box) {
            return calcLength(box.x) / calcLength(box.y);
        }
        function axisDeltaEquals(a, b) {
            return a.translate === b.translate && a.scale === b.scale && a.originPoint === b.originPoint;
        }
        class NodeStack {
            constructor() {
                this.members = [];
            }
            add(node) {
                addUniqueItem(this.members, node);
                node.scheduleRender();
            }
            remove(node) {
                removeItem(this.members, node);
                if (node === this.prevLead) this.prevLead = void 0;
                if (node === this.lead) {
                    const prevLead = this.members[this.members.length - 1];
                    if (prevLead) this.promote(prevLead);
                }
            }
            relegate(node) {
                const indexOfNode = this.members.findIndex(member => node === member);
                if (indexOfNode === 0) return false;
                let prevLead;
                for (let i = indexOfNode; i >= 0; i--) {
                    const member = this.members[i];
                    if (member.isPresent !== false) {
                        prevLead = member;
                        break;
                    }
                }
                if (prevLead) {
                    this.promote(prevLead);
                    return true;
                } else return false;
            }
            promote(node, preserveFollowOpacity) {
                const prevLead = this.lead;
                if (node === prevLead) return;
                this.prevLead = prevLead;
                this.lead = node;
                node.show();
                if (prevLead) {
                    prevLead.instance && prevLead.scheduleRender();
                    node.scheduleRender();
                    node.resumeFrom = prevLead;
                    if (preserveFollowOpacity) node.resumeFrom.preserveOpacity = true;
                    if (prevLead.snapshot) {
                        node.snapshot = prevLead.snapshot;
                        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
                    }
                    if (node.root && node.root.isUpdating) node.isLayoutDirty = true;
                    const {crossfade} = node.options;
                    if (crossfade === false) prevLead.hide();
                }
            }
            exitAnimationComplete() {
                this.members.forEach(node => {
                    const {options, resumingFrom} = node;
                    options.onExitComplete && options.onExitComplete();
                    if (resumingFrom) resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
                });
            }
            scheduleRender() {
                this.members.forEach(node => {
                    node.instance && node.scheduleRender(false);
                });
            }
            removeLeadSnapshot() {
                if (this.lead && this.lead.snapshot) this.lead.snapshot = void 0;
            }
        }
        function buildProjectionTransform(delta, treeScale, latestTransform) {
            let transform = "";
            const xTranslate = delta.x.translate / treeScale.x;
            const yTranslate = delta.y.translate / treeScale.y;
            const zTranslate = latestTransform?.z || 0;
            if (xTranslate || yTranslate || zTranslate) transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
            if (treeScale.x !== 1 || treeScale.y !== 1) transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
            if (latestTransform) {
                const {transformPerspective, rotate, rotateX, rotateY, skewX, skewY} = latestTransform;
                if (transformPerspective) transform = `perspective(${transformPerspective}px) ${transform}`;
                if (rotate) transform += `rotate(${rotate}deg) `;
                if (rotateX) transform += `rotateX(${rotateX}deg) `;
                if (rotateY) transform += `rotateY(${rotateY}deg) `;
                if (skewX) transform += `skewX(${skewX}deg) `;
                if (skewY) transform += `skewY(${skewY}deg) `;
            }
            const elementScaleX = delta.x.scale * treeScale.x;
            const elementScaleY = delta.y.scale * treeScale.y;
            if (elementScaleX !== 1 || elementScaleY !== 1) transform += `scale(${elementScaleX}, ${elementScaleY})`;
            return transform || "none";
        }
        const metrics = {
            nodes: 0,
            calculatedTargetDeltas: 0,
            calculatedProjections: 0
        };
        const transformAxes = [ "", "X", "Y", "Z" ];
        const animationTarget = 1e3;
        let create_projection_node_id = 0;
        function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
            const {latestValues} = visualElement;
            if (latestValues[key]) {
                values[key] = latestValues[key];
                visualElement.setStaticValue(key, 0);
                if (sharedAnimationValues) sharedAnimationValues[key] = 0;
            }
        }
        function cancelTreeOptimisedTransformAnimations(projectionNode) {
            projectionNode.hasCheckedOptimisedAppear = true;
            if (projectionNode.root === projectionNode) return;
            const {visualElement} = projectionNode.options;
            if (!visualElement) return;
            const appearId = getOptimisedAppearId(visualElement);
            if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
                const {layout, layoutId} = projectionNode.options;
                window.MotionCancelOptimisedAnimation(appearId, "transform", frame_frame, !(layout || layoutId));
            }
            const {parent} = projectionNode;
            if (parent && !parent.hasCheckedOptimisedAppear) cancelTreeOptimisedTransformAnimations(parent);
        }
        function createProjectionNode({attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform}) {
            return class ProjectionNode {
                constructor(latestValues = {}, parent = defaultParent?.()) {
                    this.id = create_projection_node_id++;
                    this.animationId = 0;
                    this.animationCommitId = 0;
                    this.children = new Set;
                    this.options = {};
                    this.isTreeAnimating = false;
                    this.isAnimationBlocked = false;
                    this.isLayoutDirty = false;
                    this.isProjectionDirty = false;
                    this.isSharedProjectionDirty = false;
                    this.isTransformDirty = false;
                    this.updateManuallyBlocked = false;
                    this.updateBlockedByResize = false;
                    this.isUpdating = false;
                    this.isSVG = false;
                    this.needsReset = false;
                    this.shouldResetTransform = false;
                    this.hasCheckedOptimisedAppear = false;
                    this.treeScale = {
                        x: 1,
                        y: 1
                    };
                    this.eventHandlers = new Map;
                    this.hasTreeAnimated = false;
                    this.updateScheduled = false;
                    this.scheduleUpdate = () => this.update();
                    this.projectionUpdateScheduled = false;
                    this.checkUpdateFailed = () => {
                        if (this.isUpdating) {
                            this.isUpdating = false;
                            this.clearAllSnapshots();
                        }
                    };
                    this.updateProjection = () => {
                        this.projectionUpdateScheduled = false;
                        if (statsBuffer.value) metrics.nodes = metrics.calculatedTargetDeltas = metrics.calculatedProjections = 0;
                        this.nodes.forEach(propagateDirtyNodes);
                        this.nodes.forEach(resolveTargetDelta);
                        this.nodes.forEach(calcProjection);
                        this.nodes.forEach(cleanDirtyNodes);
                        if (statsBuffer.addProjectionMetrics) statsBuffer.addProjectionMetrics(metrics);
                    };
                    this.resolvedRelativeTargetAt = 0;
                    this.hasProjected = false;
                    this.isVisible = true;
                    this.animationProgress = 0;
                    this.sharedNodes = new Map;
                    this.latestValues = latestValues;
                    this.root = parent ? parent.root || parent : this;
                    this.path = parent ? [ ...parent.path, parent ] : [];
                    this.parent = parent;
                    this.depth = parent ? parent.depth + 1 : 0;
                    for (let i = 0; i < this.path.length; i++) this.path[i].shouldResetTransform = true;
                    if (this.root === this) this.nodes = new FlatTree;
                }
                addEventListener(name, handler) {
                    if (!this.eventHandlers.has(name)) this.eventHandlers.set(name, new SubscriptionManager);
                    return this.eventHandlers.get(name).add(handler);
                }
                notifyListeners(name, ...args) {
                    const subscriptionManager = this.eventHandlers.get(name);
                    subscriptionManager && subscriptionManager.notify(...args);
                }
                hasListeners(name) {
                    return this.eventHandlers.has(name);
                }
                mount(instance) {
                    if (this.instance) return;
                    this.isSVG = isSVGElement(instance) && !isSVGSVGElement(instance);
                    this.instance = instance;
                    const {layoutId, layout, visualElement} = this.options;
                    if (visualElement && !visualElement.current) visualElement.mount(instance);
                    this.root.nodes.add(this);
                    this.parent && this.parent.children.add(this);
                    if (this.root.hasTreeAnimated && (layout || layoutId)) this.isLayoutDirty = true;
                    if (attachResizeListener) {
                        let cancelDelay;
                        let innerWidth = 0;
                        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
                        frame_frame.read(() => {
                            innerWidth = window.innerWidth;
                        });
                        attachResizeListener(instance, () => {
                            const newInnerWidth = window.innerWidth;
                            if (newInnerWidth === innerWidth) return;
                            innerWidth = newInnerWidth;
                            this.root.updateBlockedByResize = true;
                            cancelDelay && cancelDelay();
                            cancelDelay = delay(resizeUnblockUpdate, 250);
                            if (globalProjectionState.hasAnimatedSinceResize) {
                                globalProjectionState.hasAnimatedSinceResize = false;
                                this.nodes.forEach(finishAnimation);
                            }
                        });
                    }
                    if (layoutId) this.root.registerSharedNode(layoutId, this);
                    if (this.options.animate !== false && visualElement && (layoutId || layout)) this.addEventListener("didUpdate", ({delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout}) => {
                        if (this.isTreeAnimationBlocked()) {
                            this.target = void 0;
                            this.relativeTarget = void 0;
                            return;
                        }
                        const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
                        const {onLayoutAnimationStart, onLayoutAnimationComplete} = visualElement.getProps();
                        const hasTargetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout);
                        const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;
                        if (this.options.layoutRoot || this.resumeFrom || hasOnlyRelativeTargetChanged || hasLayoutChanged && (hasTargetChanged || !this.currentAnimation)) {
                            if (this.resumeFrom) {
                                this.resumingFrom = this.resumeFrom;
                                this.resumingFrom.resumingFrom = void 0;
                            }
                            const animationOptions = {
                                ...getValueTransition(layoutTransition, "layout"),
                                onPlay: onLayoutAnimationStart,
                                onComplete: onLayoutAnimationComplete
                            };
                            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
                                animationOptions.delay = 0;
                                animationOptions.type = false;
                            }
                            this.startAnimation(animationOptions);
                            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
                        } else {
                            if (!hasLayoutChanged) finishAnimation(this);
                            if (this.isLead() && this.options.onExitComplete) this.options.onExitComplete();
                        }
                        this.targetLayout = newLayout;
                    });
                }
                unmount() {
                    this.options.layoutId && this.willUpdate();
                    this.root.nodes.remove(this);
                    const stack = this.getStack();
                    stack && stack.remove(this);
                    this.parent && this.parent.children.delete(this);
                    this.instance = void 0;
                    this.eventHandlers.clear();
                    cancelFrame(this.updateProjection);
                }
                blockUpdate() {
                    this.updateManuallyBlocked = true;
                }
                unblockUpdate() {
                    this.updateManuallyBlocked = false;
                }
                isUpdateBlocked() {
                    return this.updateManuallyBlocked || this.updateBlockedByResize;
                }
                isTreeAnimationBlocked() {
                    return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
                }
                startUpdate() {
                    if (this.isUpdateBlocked()) return;
                    this.isUpdating = true;
                    this.nodes && this.nodes.forEach(resetSkewAndRotation);
                    this.animationId++;
                }
                getTransformTemplate() {
                    const {visualElement} = this.options;
                    return visualElement && visualElement.getProps().transformTemplate;
                }
                willUpdate(shouldNotifyListeners = true) {
                    this.root.hasTreeAnimated = true;
                    if (this.root.isUpdateBlocked()) {
                        this.options.onExitComplete && this.options.onExitComplete();
                        return;
                    }
                    if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) cancelTreeOptimisedTransformAnimations(this);
                    !this.root.isUpdating && this.root.startUpdate();
                    if (this.isLayoutDirty) return;
                    this.isLayoutDirty = true;
                    for (let i = 0; i < this.path.length; i++) {
                        const node = this.path[i];
                        node.shouldResetTransform = true;
                        node.updateScroll("snapshot");
                        if (node.options.layoutRoot) node.willUpdate(false);
                    }
                    const {layoutId, layout} = this.options;
                    if (layoutId === void 0 && !layout) return;
                    const transformTemplate = this.getTransformTemplate();
                    this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
                    this.updateSnapshot();
                    shouldNotifyListeners && this.notifyListeners("willUpdate");
                }
                update() {
                    this.updateScheduled = false;
                    const updateWasBlocked = this.isUpdateBlocked();
                    if (updateWasBlocked) {
                        this.unblockUpdate();
                        this.clearAllSnapshots();
                        this.nodes.forEach(clearMeasurements);
                        return;
                    }
                    if (this.animationId <= this.animationCommitId) {
                        this.nodes.forEach(clearIsLayoutDirty);
                        return;
                    }
                    this.animationCommitId = this.animationId;
                    if (!this.isUpdating) this.nodes.forEach(clearIsLayoutDirty); else {
                        this.isUpdating = false;
                        this.nodes.forEach(resetTransformStyle);
                        this.nodes.forEach(updateLayout);
                        this.nodes.forEach(notifyLayoutUpdate);
                    }
                    this.clearAllSnapshots();
                    const now = time.now();
                    frameData.delta = clamp(0, 1e3 / 60, now - frameData.timestamp);
                    frameData.timestamp = now;
                    frameData.isProcessing = true;
                    frameSteps.update.process(frameData);
                    frameSteps.preRender.process(frameData);
                    frameSteps.render.process(frameData);
                    frameData.isProcessing = false;
                }
                didUpdate() {
                    if (!this.updateScheduled) {
                        this.updateScheduled = true;
                        microtask.read(this.scheduleUpdate);
                    }
                }
                clearAllSnapshots() {
                    this.nodes.forEach(clearSnapshot);
                    this.sharedNodes.forEach(removeLeadSnapshots);
                }
                scheduleUpdateProjection() {
                    if (!this.projectionUpdateScheduled) {
                        this.projectionUpdateScheduled = true;
                        frame_frame.preRender(this.updateProjection, false, true);
                    }
                }
                scheduleCheckAfterUnmount() {
                    frame_frame.postRender(() => {
                        if (this.isLayoutDirty) this.root.didUpdate(); else this.root.checkUpdateFailed();
                    });
                }
                updateSnapshot() {
                    if (this.snapshot || !this.instance) return;
                    this.snapshot = this.measure();
                    if (this.snapshot && !calcLength(this.snapshot.measuredBox.x) && !calcLength(this.snapshot.measuredBox.y)) this.snapshot = void 0;
                }
                updateLayout() {
                    if (!this.instance) return;
                    this.updateScroll();
                    if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) return;
                    if (this.resumeFrom && !this.resumeFrom.instance) for (let i = 0; i < this.path.length; i++) {
                        const node = this.path[i];
                        node.updateScroll();
                    }
                    const prevLayout = this.layout;
                    this.layout = this.measure(false);
                    this.layoutCorrected = createBox();
                    this.isLayoutDirty = false;
                    this.projectionDelta = void 0;
                    this.notifyListeners("measure", this.layout.layoutBox);
                    const {visualElement} = this.options;
                    visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
                }
                updateScroll(phase = "measure") {
                    let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
                    if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) needsMeasurement = false;
                    if (needsMeasurement && this.instance) {
                        const isRoot = checkIsScrollRoot(this.instance);
                        this.scroll = {
                            animationId: this.root.animationId,
                            phase,
                            isRoot,
                            offset: measureScroll(this.instance),
                            wasRoot: this.scroll ? this.scroll.isRoot : isRoot
                        };
                    }
                }
                resetTransform() {
                    if (!resetTransform) return;
                    const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
                    const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
                    const transformTemplate = this.getTransformTemplate();
                    const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
                    const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
                    if (isResetRequested && this.instance && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
                        resetTransform(this.instance, transformTemplateValue);
                        this.shouldResetTransform = false;
                        this.scheduleRender();
                    }
                }
                measure(removeTransform = true) {
                    const pageBox = this.measurePageBox();
                    let layoutBox = this.removeElementScroll(pageBox);
                    if (removeTransform) layoutBox = this.removeTransform(layoutBox);
                    roundBox(layoutBox);
                    return {
                        animationId: this.root.animationId,
                        measuredBox: pageBox,
                        layoutBox,
                        latestValues: {},
                        source: this.id
                    };
                }
                measurePageBox() {
                    const {visualElement} = this.options;
                    if (!visualElement) return createBox();
                    const box = visualElement.measureViewportBox();
                    const wasInScrollRoot = this.scroll?.wasRoot || this.path.some(checkNodeWasScrollRoot);
                    if (!wasInScrollRoot) {
                        const {scroll} = this.root;
                        if (scroll) {
                            translateAxis(box.x, scroll.offset.x);
                            translateAxis(box.y, scroll.offset.y);
                        }
                    }
                    return box;
                }
                removeElementScroll(box) {
                    const boxWithoutScroll = createBox();
                    copyBoxInto(boxWithoutScroll, box);
                    if (this.scroll?.wasRoot) return boxWithoutScroll;
                    for (let i = 0; i < this.path.length; i++) {
                        const node = this.path[i];
                        const {scroll, options} = node;
                        if (node !== this.root && scroll && options.layoutScroll) {
                            if (scroll.wasRoot) copyBoxInto(boxWithoutScroll, box);
                            translateAxis(boxWithoutScroll.x, scroll.offset.x);
                            translateAxis(boxWithoutScroll.y, scroll.offset.y);
                        }
                    }
                    return boxWithoutScroll;
                }
                applyTransform(box, transformOnly = false) {
                    const withTransforms = createBox();
                    copyBoxInto(withTransforms, box);
                    for (let i = 0; i < this.path.length; i++) {
                        const node = this.path[i];
                        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) transformBox(withTransforms, {
                            x: -node.scroll.offset.x,
                            y: -node.scroll.offset.y
                        });
                        if (!hasTransform(node.latestValues)) continue;
                        transformBox(withTransforms, node.latestValues);
                    }
                    if (hasTransform(this.latestValues)) transformBox(withTransforms, this.latestValues);
                    return withTransforms;
                }
                removeTransform(box) {
                    const boxWithoutTransform = createBox();
                    copyBoxInto(boxWithoutTransform, box);
                    for (let i = 0; i < this.path.length; i++) {
                        const node = this.path[i];
                        if (!node.instance) continue;
                        if (!hasTransform(node.latestValues)) continue;
                        hasScale(node.latestValues) && node.updateSnapshot();
                        const sourceBox = createBox();
                        const nodeBox = node.measurePageBox();
                        copyBoxInto(sourceBox, nodeBox);
                        removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox);
                    }
                    if (hasTransform(this.latestValues)) removeBoxTransforms(boxWithoutTransform, this.latestValues);
                    return boxWithoutTransform;
                }
                setTargetDelta(delta) {
                    this.targetDelta = delta;
                    this.root.scheduleUpdateProjection();
                    this.isProjectionDirty = true;
                }
                setOptions(options) {
                    this.options = {
                        ...this.options,
                        ...options,
                        crossfade: options.crossfade !== void 0 ? options.crossfade : true
                    };
                }
                clearMeasurements() {
                    this.scroll = void 0;
                    this.layout = void 0;
                    this.snapshot = void 0;
                    this.prevTransformTemplateValue = void 0;
                    this.targetDelta = void 0;
                    this.target = void 0;
                    this.isLayoutDirty = false;
                }
                forceRelativeParentToResolveTarget() {
                    if (!this.relativeParent) return;
                    if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) this.relativeParent.resolveTargetDelta(true);
                }
                resolveTargetDelta(forceRecalculation = false) {
                    const lead = this.getLead();
                    this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
                    this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
                    this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
                    const isShared = Boolean(this.resumingFrom) || this !== lead;
                    const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize);
                    if (canSkip) return;
                    const {layout, layoutId} = this.options;
                    if (!this.layout || !(layout || layoutId)) return;
                    this.resolvedRelativeTargetAt = frameData.timestamp;
                    if (!this.targetDelta && !this.relativeTarget) {
                        const relativeParent = this.getClosestProjectingParent();
                        if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
                            this.relativeParent = relativeParent;
                            this.forceRelativeParentToResolveTarget();
                            this.relativeTarget = createBox();
                            this.relativeTargetOrigin = createBox();
                            calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
                            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
                        } else this.relativeParent = this.relativeTarget = void 0;
                    }
                    if (!this.relativeTarget && !this.targetDelta) return;
                    if (!this.target) {
                        this.target = createBox();
                        this.targetWithTransforms = createBox();
                    }
                    if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
                        this.forceRelativeParentToResolveTarget();
                        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
                    } else if (this.targetDelta) {
                        if (Boolean(this.resumingFrom)) this.target = this.applyTransform(this.layout.layoutBox); else copyBoxInto(this.target, this.layout.layoutBox);
                        applyBoxDelta(this.target, this.targetDelta);
                    } else copyBoxInto(this.target, this.layout.layoutBox);
                    if (this.attemptToResolveRelativeTarget) {
                        this.attemptToResolveRelativeTarget = false;
                        const relativeParent = this.getClosestProjectingParent();
                        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
                            this.relativeParent = relativeParent;
                            this.forceRelativeParentToResolveTarget();
                            this.relativeTarget = createBox();
                            this.relativeTargetOrigin = createBox();
                            calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
                            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
                        } else this.relativeParent = this.relativeTarget = void 0;
                    }
                    if (statsBuffer.value) metrics.calculatedTargetDeltas++;
                }
                getClosestProjectingParent() {
                    if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) return;
                    if (this.parent.isProjecting()) return this.parent; else return this.parent.getClosestProjectingParent();
                }
                isProjecting() {
                    return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
                }
                calcProjection() {
                    const lead = this.getLead();
                    const isShared = Boolean(this.resumingFrom) || this !== lead;
                    let canSkip = true;
                    if (this.isProjectionDirty || this.parent?.isProjectionDirty) canSkip = false;
                    if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) canSkip = false;
                    if (this.resolvedRelativeTargetAt === frameData.timestamp) canSkip = false;
                    if (canSkip) return;
                    const {layout, layoutId} = this.options;
                    this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
                    if (!this.isTreeAnimating) this.targetDelta = this.relativeTarget = void 0;
                    if (!this.layout || !(layout || layoutId)) return;
                    copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
                    const prevTreeScaleX = this.treeScale.x;
                    const prevTreeScaleY = this.treeScale.y;
                    applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
                    if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
                        lead.target = lead.layout.layoutBox;
                        lead.targetWithTransforms = createBox();
                    }
                    const {target} = lead;
                    if (!target) {
                        if (this.prevProjectionDelta) {
                            this.createProjectionDeltas();
                            this.scheduleRender();
                        }
                        return;
                    }
                    if (!this.projectionDelta || !this.prevProjectionDelta) this.createProjectionDeltas(); else {
                        copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
                        copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
                    }
                    calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
                    if (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
                        this.hasProjected = true;
                        this.scheduleRender();
                        this.notifyListeners("projectionUpdate", target);
                    }
                    if (statsBuffer.value) metrics.calculatedProjections++;
                }
                hide() {
                    this.isVisible = false;
                }
                show() {
                    this.isVisible = true;
                }
                scheduleRender(notifyAll = true) {
                    this.options.visualElement?.scheduleRender();
                    if (notifyAll) {
                        const stack = this.getStack();
                        stack && stack.scheduleRender();
                    }
                    if (this.resumingFrom && !this.resumingFrom.instance) this.resumingFrom = void 0;
                }
                createProjectionDeltas() {
                    this.prevProjectionDelta = createDelta();
                    this.projectionDelta = createDelta();
                    this.projectionDeltaWithTransform = createDelta();
                }
                setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
                    const snapshot = this.snapshot;
                    const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
                    const mixedValues = {
                        ...this.latestValues
                    };
                    const targetDelta = createDelta();
                    if (!this.relativeParent || !this.relativeParent.options.layoutRoot) this.relativeTarget = this.relativeTargetOrigin = void 0;
                    this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
                    const relativeLayout = createBox();
                    const snapshotSource = snapshot ? snapshot.source : void 0;
                    const layoutSource = this.layout ? this.layout.source : void 0;
                    const isSharedLayoutAnimation = snapshotSource !== layoutSource;
                    const stack = this.getStack();
                    const isOnlyMember = !stack || stack.members.length <= 1;
                    const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
                    this.animationProgress = 0;
                    let prevRelativeTarget;
                    this.mixTargetDelta = latest => {
                        const progress = latest / 1e3;
                        mixAxisDelta(targetDelta.x, delta.x, progress);
                        mixAxisDelta(targetDelta.y, delta.y, progress);
                        this.setTargetDelta(targetDelta);
                        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
                            calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
                            mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress);
                            if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) this.isProjectionDirty = false;
                            if (!prevRelativeTarget) prevRelativeTarget = createBox();
                            copyBoxInto(prevRelativeTarget, this.relativeTarget);
                        }
                        if (isSharedLayoutAnimation) {
                            this.animationValues = mixedValues;
                            mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);
                        }
                        this.root.scheduleUpdateProjection();
                        this.scheduleRender();
                        this.animationProgress = progress;
                    };
                    this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
                }
                startAnimation(options) {
                    this.notifyListeners("animationStart");
                    this.currentAnimation?.stop();
                    this.resumingFrom?.currentAnimation?.stop();
                    if (this.pendingAnimation) {
                        cancelFrame(this.pendingAnimation);
                        this.pendingAnimation = void 0;
                    }
                    this.pendingAnimation = frame_frame.update(() => {
                        globalProjectionState.hasAnimatedSinceResize = true;
                        activeAnimations.layout++;
                        this.motionValue || (this.motionValue = motionValue(0));
                        this.currentAnimation = animateSingleValue(this.motionValue, [ 0, 1e3 ], {
                            ...options,
                            velocity: 0,
                            isSync: true,
                            onUpdate: latest => {
                                this.mixTargetDelta(latest);
                                options.onUpdate && options.onUpdate(latest);
                            },
                            onStop: () => {
                                activeAnimations.layout--;
                            },
                            onComplete: () => {
                                activeAnimations.layout--;
                                options.onComplete && options.onComplete();
                                this.completeAnimation();
                            }
                        });
                        if (this.resumingFrom) this.resumingFrom.currentAnimation = this.currentAnimation;
                        this.pendingAnimation = void 0;
                    });
                }
                completeAnimation() {
                    if (this.resumingFrom) {
                        this.resumingFrom.currentAnimation = void 0;
                        this.resumingFrom.preserveOpacity = void 0;
                    }
                    const stack = this.getStack();
                    stack && stack.exitAnimationComplete();
                    this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
                    this.notifyListeners("animationComplete");
                }
                finishAnimation() {
                    if (this.currentAnimation) {
                        this.mixTargetDelta && this.mixTargetDelta(animationTarget);
                        this.currentAnimation.stop();
                    }
                    this.completeAnimation();
                }
                applyTransformsToTarget() {
                    const lead = this.getLead();
                    let {targetWithTransforms, target, layout, latestValues} = lead;
                    if (!targetWithTransforms || !target || !layout) return;
                    if (this !== lead && this.layout && layout && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {
                        target = this.target || createBox();
                        const xLength = calcLength(this.layout.layoutBox.x);
                        target.x.min = lead.target.x.min;
                        target.x.max = target.x.min + xLength;
                        const yLength = calcLength(this.layout.layoutBox.y);
                        target.y.min = lead.target.y.min;
                        target.y.max = target.y.min + yLength;
                    }
                    copyBoxInto(targetWithTransforms, target);
                    transformBox(targetWithTransforms, latestValues);
                    calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
                }
                registerSharedNode(layoutId, node) {
                    if (!this.sharedNodes.has(layoutId)) this.sharedNodes.set(layoutId, new NodeStack);
                    const stack = this.sharedNodes.get(layoutId);
                    stack.add(node);
                    const config = node.options.initialPromotionConfig;
                    node.promote({
                        transition: config ? config.transition : void 0,
                        preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node) : void 0
                    });
                }
                isLead() {
                    const stack = this.getStack();
                    return stack ? stack.lead === this : true;
                }
                getLead() {
                    const {layoutId} = this.options;
                    return layoutId ? this.getStack()?.lead || this : this;
                }
                getPrevLead() {
                    const {layoutId} = this.options;
                    return layoutId ? this.getStack()?.prevLead : void 0;
                }
                getStack() {
                    const {layoutId} = this.options;
                    if (layoutId) return this.root.sharedNodes.get(layoutId);
                }
                promote({needsReset, transition, preserveFollowOpacity} = {}) {
                    const stack = this.getStack();
                    if (stack) stack.promote(this, preserveFollowOpacity);
                    if (needsReset) {
                        this.projectionDelta = void 0;
                        this.needsReset = true;
                    }
                    if (transition) this.setOptions({
                        transition
                    });
                }
                relegate() {
                    const stack = this.getStack();
                    if (stack) return stack.relegate(this); else return false;
                }
                resetSkewAndRotation() {
                    const {visualElement} = this.options;
                    if (!visualElement) return;
                    let hasDistortingTransform = false;
                    const {latestValues} = visualElement;
                    if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) hasDistortingTransform = true;
                    if (!hasDistortingTransform) return;
                    const resetValues = {};
                    if (latestValues.z) resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
                    for (let i = 0; i < transformAxes.length; i++) {
                        resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
                        resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
                    }
                    visualElement.render();
                    for (const key in resetValues) {
                        visualElement.setStaticValue(key, resetValues[key]);
                        if (this.animationValues) this.animationValues[key] = resetValues[key];
                    }
                    visualElement.scheduleRender();
                }
                applyProjectionStyles(targetStyle, styleProp) {
                    if (!this.instance || this.isSVG) return;
                    if (!this.isVisible) {
                        targetStyle.visibility = "hidden";
                        return;
                    }
                    const transformTemplate = this.getTransformTemplate();
                    if (this.needsReset) {
                        this.needsReset = false;
                        targetStyle.visibility = "";
                        targetStyle.opacity = "";
                        targetStyle.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || "";
                        targetStyle.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
                        return;
                    }
                    const lead = this.getLead();
                    if (!this.projectionDelta || !this.layout || !lead.target) {
                        if (this.options.layoutId) {
                            targetStyle.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
                            targetStyle.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || "";
                        }
                        if (this.hasProjected && !hasTransform(this.latestValues)) {
                            targetStyle.transform = transformTemplate ? transformTemplate({}, "") : "none";
                            this.hasProjected = false;
                        }
                        return;
                    }
                    targetStyle.visibility = "";
                    const valuesToRender = lead.animationValues || lead.latestValues;
                    this.applyTransformsToTarget();
                    let transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
                    if (transformTemplate) transform = transformTemplate(valuesToRender, transform);
                    targetStyle.transform = transform;
                    const {x, y} = this.projectionDelta;
                    targetStyle.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;
                    if (lead.animationValues) targetStyle.opacity = lead === this ? valuesToRender.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit; else targetStyle.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
                    for (const key in scaleCorrectors) {
                        if (valuesToRender[key] === void 0) continue;
                        const {correct, applyTo, isCSSVariable} = scaleCorrectors[key];
                        const corrected = transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
                        if (applyTo) {
                            const num = applyTo.length;
                            for (let i = 0; i < num; i++) targetStyle[applyTo[i]] = corrected;
                        } else if (isCSSVariable) this.options.visualElement.renderState.vars[key] = corrected; else targetStyle[key] = corrected;
                    }
                    if (this.options.layoutId) targetStyle.pointerEvents = lead === this ? resolveMotionValue(styleProp?.pointerEvents) || "" : "none";
                }
                clearSnapshot() {
                    this.resumeFrom = this.snapshot = void 0;
                }
                resetTree() {
                    this.root.nodes.forEach(node => node.currentAnimation?.stop());
                    this.root.nodes.forEach(clearMeasurements);
                    this.root.sharedNodes.clear();
                }
            };
        }
        function updateLayout(node) {
            node.updateLayout();
        }
        function notifyLayoutUpdate(node) {
            const snapshot = node.resumeFrom?.snapshot || node.snapshot;
            if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
                const {layoutBox: layout, measuredBox: measuredLayout} = node.layout;
                const {animationType} = node.options;
                const isShared = snapshot.source !== node.layout.source;
                if (animationType === "size") eachAxis(axis => {
                    const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
                    const length = calcLength(axisSnapshot);
                    axisSnapshot.min = layout[axis].min;
                    axisSnapshot.max = axisSnapshot.min + length;
                }); else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) eachAxis(axis => {
                    const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
                    const length = calcLength(layout[axis]);
                    axisSnapshot.max = axisSnapshot.min + length;
                    if (node.relativeTarget && !node.currentAnimation) {
                        node.isProjectionDirty = true;
                        node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;
                    }
                });
                const layoutDelta = createDelta();
                calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);
                const visualDelta = createDelta();
                if (isShared) calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox); else calcBoxDelta(visualDelta, layout, snapshot.layoutBox);
                const hasLayoutChanged = !isDeltaZero(layoutDelta);
                let hasRelativeLayoutChanged = false;
                if (!node.resumeFrom) {
                    const relativeParent = node.getClosestProjectingParent();
                    if (relativeParent && !relativeParent.resumeFrom) {
                        const {snapshot: parentSnapshot, layout: parentLayout} = relativeParent;
                        if (parentSnapshot && parentLayout) {
                            const relativeSnapshot = createBox();
                            calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
                            const relativeLayout = createBox();
                            calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);
                            if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) hasRelativeLayoutChanged = true;
                            if (relativeParent.options.layoutRoot) {
                                node.relativeTarget = relativeLayout;
                                node.relativeTargetOrigin = relativeSnapshot;
                                node.relativeParent = relativeParent;
                            }
                        }
                    }
                }
                node.notifyListeners("didUpdate", {
                    layout,
                    snapshot,
                    delta: visualDelta,
                    layoutDelta,
                    hasLayoutChanged,
                    hasRelativeLayoutChanged
                });
            } else if (node.isLead()) {
                const {onExitComplete} = node.options;
                onExitComplete && onExitComplete();
            }
            node.options.transition = void 0;
        }
        function propagateDirtyNodes(node) {
            if (statsBuffer.value) metrics.nodes++;
            if (!node.parent) return;
            if (!node.isProjecting()) node.isProjectionDirty = node.parent.isProjectionDirty;
            node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty));
            node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
        }
        function cleanDirtyNodes(node) {
            node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;
        }
        function clearSnapshot(node) {
            node.clearSnapshot();
        }
        function clearMeasurements(node) {
            node.clearMeasurements();
        }
        function clearIsLayoutDirty(node) {
            node.isLayoutDirty = false;
        }
        function resetTransformStyle(node) {
            const {visualElement} = node.options;
            if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) visualElement.notify("BeforeLayoutMeasure");
            node.resetTransform();
        }
        function finishAnimation(node) {
            node.finishAnimation();
            node.targetDelta = node.relativeTarget = node.target = void 0;
            node.isProjectionDirty = true;
        }
        function resolveTargetDelta(node) {
            node.resolveTargetDelta();
        }
        function calcProjection(node) {
            node.calcProjection();
        }
        function resetSkewAndRotation(node) {
            node.resetSkewAndRotation();
        }
        function removeLeadSnapshots(stack) {
            stack.removeLeadSnapshot();
        }
        function mixAxisDelta(output, delta, p) {
            output.translate = mixNumber(delta.translate, 0, p);
            output.scale = mixNumber(delta.scale, 1, p);
            output.origin = delta.origin;
            output.originPoint = delta.originPoint;
        }
        function mixAxis(output, from, to, p) {
            output.min = mixNumber(from.min, to.min, p);
            output.max = mixNumber(from.max, to.max, p);
        }
        function mixBox(output, from, to, p) {
            mixAxis(output.x, from.x, to.x, p);
            mixAxis(output.y, from.y, to.y, p);
        }
        function hasOpacityCrossfade(node) {
            return node.animationValues && node.animationValues.opacityExit !== void 0;
        }
        const defaultLayoutTransition = {
            duration: .45,
            ease: [ .4, 0, .1, 1 ]
        };
        const userAgentContains = string => typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string);
        const roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop;
        function roundAxis(axis) {
            axis.min = roundPoint(axis.min);
            axis.max = roundPoint(axis.max);
        }
        function roundBox(box) {
            roundAxis(box.x);
            roundAxis(box.y);
        }
        function shouldAnimatePositionOnly(animationType, snapshot, layout) {
            return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout), .2);
        }
        function checkNodeWasScrollRoot(node) {
            return node !== node.root && node.scroll?.wasRoot;
        }
        const DocumentProjectionNode = createProjectionNode({
            attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
            measureScroll: () => ({
                x: document.documentElement.scrollLeft || document.body.scrollLeft,
                y: document.documentElement.scrollTop || document.body.scrollTop
            }),
            checkIsScrollRoot: () => true
        });
        const rootProjectionNode = {
            current: void 0
        };
        const HTMLProjectionNode = createProjectionNode({
            measureScroll: instance => ({
                x: instance.scrollLeft,
                y: instance.scrollTop
            }),
            defaultParent: () => {
                if (!rootProjectionNode.current) {
                    const documentNode = new DocumentProjectionNode({});
                    documentNode.mount(window);
                    documentNode.setOptions({
                        layoutScroll: true
                    });
                    rootProjectionNode.current = documentNode;
                }
                return rootProjectionNode.current;
            },
            resetTransform: (instance, value) => {
                instance.style.transform = value !== void 0 ? value : "none";
            },
            checkIsScrollRoot: instance => Boolean(window.getComputedStyle(instance).position === "fixed")
        });
        const drag = {
            pan: {
                Feature: PanGesture
            },
            drag: {
                Feature: DragGesture,
                ProjectionNode: HTMLProjectionNode,
                MeasureLayout
            }
        };
        function resolveElements(elementOrSelector, scope, selectorCache) {
            if (elementOrSelector instanceof EventTarget) return [ elementOrSelector ]; else if (typeof elementOrSelector === "string") {
                let root = document;
                if (scope) root = scope.current;
                const elements = selectorCache?.[elementOrSelector] ?? root.querySelectorAll(elementOrSelector);
                return elements ? Array.from(elements) : [];
            }
            return Array.from(elementOrSelector);
        }
        function setupGesture(elementOrSelector, options) {
            const elements = resolveElements(elementOrSelector);
            const gestureAbortController = new AbortController;
            const eventOptions = {
                passive: true,
                ...options,
                signal: gestureAbortController.signal
            };
            const cancel = () => gestureAbortController.abort();
            return [ elements, eventOptions, cancel ];
        }
        function isValidHover(event) {
            return !(event.pointerType === "touch" || isDragActive());
        }
        function hover(elementOrSelector, onHoverStart, options = {}) {
            const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);
            const onPointerEnter = enterEvent => {
                if (!isValidHover(enterEvent)) return;
                const {target} = enterEvent;
                const onHoverEnd = onHoverStart(target, enterEvent);
                if (typeof onHoverEnd !== "function" || !target) return;
                const onPointerLeave = leaveEvent => {
                    if (!isValidHover(leaveEvent)) return;
                    onHoverEnd(leaveEvent);
                    target.removeEventListener("pointerleave", onPointerLeave);
                };
                target.addEventListener("pointerleave", onPointerLeave, eventOptions);
            };
            elements.forEach(element => {
                element.addEventListener("pointerenter", onPointerEnter, eventOptions);
            });
            return cancel;
        }
        function handleHoverEvent(node, event, lifecycle) {
            const {props} = node;
            if (node.animationState && props.whileHover) node.animationState.setActive("whileHover", lifecycle === "Start");
            const eventName = "onHover" + lifecycle;
            const callback = props[eventName];
            if (callback) frame_frame.postRender(() => callback(event, extractEventInfo(event)));
        }
        class HoverGesture extends Feature {
            mount() {
                const {current} = this.node;
                if (!current) return;
                this.unmount = hover(current, (_element, startEvent) => {
                    handleHoverEvent(this.node, startEvent, "Start");
                    return endEvent => handleHoverEvent(this.node, endEvent, "End");
                });
            }
            unmount() {}
        }
        class FocusGesture extends Feature {
            constructor() {
                super(...arguments);
                this.isActive = false;
            }
            onFocus() {
                let isFocusVisible = false;
                try {
                    isFocusVisible = this.node.current.matches(":focus-visible");
                } catch (e) {
                    isFocusVisible = true;
                }
                if (!isFocusVisible || !this.node.animationState) return;
                this.node.animationState.setActive("whileFocus", true);
                this.isActive = true;
            }
            onBlur() {
                if (!this.isActive || !this.node.animationState) return;
                this.node.animationState.setActive("whileFocus", false);
                this.isActive = false;
            }
            mount() {
                this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
            }
            unmount() {}
        }
        const isNodeOrChild = (parent, child) => {
            if (!child) return false; else if (parent === child) return true; else return isNodeOrChild(parent, child.parentElement);
        };
        const focusableElements = new Set([ "BUTTON", "INPUT", "SELECT", "TEXTAREA", "A" ]);
        function isElementKeyboardAccessible(element) {
            return focusableElements.has(element.tagName) || element.tabIndex !== -1;
        }
        const isPressing = new WeakSet;
        function filterEvents(callback) {
            return event => {
                if (event.key !== "Enter") return;
                callback(event);
            };
        }
        function firePointerEvent(target, type) {
            target.dispatchEvent(new PointerEvent("pointer" + type, {
                isPrimary: true,
                bubbles: true
            }));
        }
        const enableKeyboardPress = (focusEvent, eventOptions) => {
            const element = focusEvent.currentTarget;
            if (!element) return;
            const handleKeydown = filterEvents(() => {
                if (isPressing.has(element)) return;
                firePointerEvent(element, "down");
                const handleKeyup = filterEvents(() => {
                    firePointerEvent(element, "up");
                });
                const handleBlur = () => firePointerEvent(element, "cancel");
                element.addEventListener("keyup", handleKeyup, eventOptions);
                element.addEventListener("blur", handleBlur, eventOptions);
            });
            element.addEventListener("keydown", handleKeydown, eventOptions);
            element.addEventListener("blur", () => element.removeEventListener("keydown", handleKeydown), eventOptions);
        };
        function isValidPressEvent(event) {
            return isPrimaryPointer(event) && !isDragActive();
        }
        function press(targetOrSelector, onPressStart, options = {}) {
            const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);
            const startPress = startEvent => {
                const target = startEvent.currentTarget;
                if (!isValidPressEvent(startEvent)) return;
                isPressing.add(target);
                const onPressEnd = onPressStart(target, startEvent);
                const onPointerEnd = (endEvent, success) => {
                    window.removeEventListener("pointerup", onPointerUp);
                    window.removeEventListener("pointercancel", onPointerCancel);
                    if (isPressing.has(target)) isPressing.delete(target);
                    if (!isValidPressEvent(endEvent)) return;
                    if (typeof onPressEnd === "function") onPressEnd(endEvent, {
                        success
                    });
                };
                const onPointerUp = upEvent => {
                    onPointerEnd(upEvent, target === window || target === document || options.useGlobalTarget || isNodeOrChild(target, upEvent.target));
                };
                const onPointerCancel = cancelEvent => {
                    onPointerEnd(cancelEvent, false);
                };
                window.addEventListener("pointerup", onPointerUp, eventOptions);
                window.addEventListener("pointercancel", onPointerCancel, eventOptions);
            };
            targets.forEach(target => {
                const pointerDownTarget = options.useGlobalTarget ? window : target;
                pointerDownTarget.addEventListener("pointerdown", startPress, eventOptions);
                if (isHTMLElement(target)) {
                    target.addEventListener("focus", event => enableKeyboardPress(event, eventOptions));
                    if (!isElementKeyboardAccessible(target) && !target.hasAttribute("tabindex")) target.tabIndex = 0;
                }
            });
            return cancelEvents;
        }
        function handlePressEvent(node, event, lifecycle) {
            const {props} = node;
            if (node.current instanceof HTMLButtonElement && node.current.disabled) return;
            if (node.animationState && props.whileTap) node.animationState.setActive("whileTap", lifecycle === "Start");
            const eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle);
            const callback = props[eventName];
            if (callback) frame_frame.postRender(() => callback(event, extractEventInfo(event)));
        }
        class PressGesture extends Feature {
            mount() {
                const {current} = this.node;
                if (!current) return;
                this.unmount = press(current, (_element, startEvent) => {
                    handlePressEvent(this.node, startEvent, "Start");
                    return (endEvent, {success}) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
                }, {
                    useGlobalTarget: this.node.props.globalTapTarget
                });
            }
            unmount() {}
        }
        const observerCallbacks = new WeakMap;
        const observers = new WeakMap;
        const fireObserverCallback = entry => {
            const callback = observerCallbacks.get(entry.target);
            callback && callback(entry);
        };
        const fireAllObserverCallbacks = entries => {
            entries.forEach(fireObserverCallback);
        };
        function initIntersectionObserver({root, ...options}) {
            const lookupRoot = root || document;
            if (!observers.has(lookupRoot)) observers.set(lookupRoot, {});
            const rootObservers = observers.get(lookupRoot);
            const key = JSON.stringify(options);
            if (!rootObservers[key]) rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, {
                root,
                ...options
            });
            return rootObservers[key];
        }
        function observeIntersection(element, options, callback) {
            const rootInteresectionObserver = initIntersectionObserver(options);
            observerCallbacks.set(element, callback);
            rootInteresectionObserver.observe(element);
            return () => {
                observerCallbacks.delete(element);
                rootInteresectionObserver.unobserve(element);
            };
        }
        const thresholdNames = {
            some: 0,
            all: 1
        };
        class InViewFeature extends Feature {
            constructor() {
                super(...arguments);
                this.hasEnteredView = false;
                this.isInView = false;
            }
            startObserver() {
                this.unmount();
                const {viewport = {}} = this.node.getProps();
                const {root, margin: rootMargin, amount = "some", once} = viewport;
                const options = {
                    root: root ? root.current : void 0,
                    rootMargin,
                    threshold: typeof amount === "number" ? amount : thresholdNames[amount]
                };
                const onIntersectionUpdate = entry => {
                    const {isIntersecting} = entry;
                    if (this.isInView === isIntersecting) return;
                    this.isInView = isIntersecting;
                    if (once && !isIntersecting && this.hasEnteredView) return; else if (isIntersecting) this.hasEnteredView = true;
                    if (this.node.animationState) this.node.animationState.setActive("whileInView", isIntersecting);
                    const {onViewportEnter, onViewportLeave} = this.node.getProps();
                    const callback = isIntersecting ? onViewportEnter : onViewportLeave;
                    callback && callback(entry);
                };
                return observeIntersection(this.node.current, options, onIntersectionUpdate);
            }
            mount() {
                this.startObserver();
            }
            update() {
                if (typeof IntersectionObserver === "undefined") return;
                const {props, prevProps} = this.node;
                const hasOptionsChanged = [ "amount", "margin", "root" ].some(hasViewportOptionChanged(props, prevProps));
                if (hasOptionsChanged) this.startObserver();
            }
            unmount() {}
        }
        function hasViewportOptionChanged({viewport = {}}, {viewport: prevViewport = {}} = {}) {
            return name => viewport[name] !== prevViewport[name];
        }
        const gestureAnimations = {
            inView: {
                Feature: InViewFeature
            },
            tap: {
                Feature: PressGesture
            },
            focus: {
                Feature: FocusGesture
            },
            hover: {
                Feature: HoverGesture
            }
        };
        const layout = {
            layout: {
                ProjectionNode: HTMLProjectionNode,
                MeasureLayout
            }
        };
        "use client";
        const LazyContext = (0, react.createContext)({
            strict: false
        });
        "use client";
        const MotionContext = (0, react.createContext)({});
        function isControllingVariants(props) {
            return isAnimationControls(props.animate) || variantProps.some(name => isVariantLabel(props[name]));
        }
        function isVariantNode(props) {
            return Boolean(isControllingVariants(props) || props.variants);
        }
        function getCurrentTreeVariants(props, context) {
            if (isControllingVariants(props)) {
                const {initial, animate} = props;
                return {
                    initial: initial === false || isVariantLabel(initial) ? initial : void 0,
                    animate: isVariantLabel(animate) ? animate : void 0
                };
            }
            return props.inherit !== false ? context : {};
        }
        function useCreateMotionContext(props) {
            const {initial, animate} = getCurrentTreeVariants(props, (0, react.useContext)(MotionContext));
            return (0, react.useMemo)(() => ({
                initial,
                animate
            }), [ variantLabelsAsDependency(initial), variantLabelsAsDependency(animate) ]);
        }
        function variantLabelsAsDependency(prop) {
            return Array.isArray(prop) ? prop.join(" ") : prop;
        }
        const featureProps = {
            animation: [ "animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag" ],
            exit: [ "exit" ],
            drag: [ "drag", "dragControls" ],
            focus: [ "whileFocus" ],
            hover: [ "whileHover", "onHoverStart", "onHoverEnd" ],
            tap: [ "whileTap", "onTap", "onTapStart", "onTapCancel" ],
            pan: [ "onPan", "onPanStart", "onPanSessionStart", "onPanEnd" ],
            inView: [ "whileInView", "onViewportEnter", "onViewportLeave" ],
            layout: [ "layout", "layoutId" ]
        };
        const featureDefinitions = {};
        for (const key in featureProps) featureDefinitions[key] = {
            isEnabled: props => featureProps[key].some(name => !!props[name])
        };
        function loadFeatures(features) {
            for (const key in features) featureDefinitions[key] = {
                ...featureDefinitions[key],
                ...features[key]
            };
        }
        const motionComponentSymbol = Symbol.for("motionComponentSymbol");
        function useMotionRef(visualState, visualElement, externalRef) {
            return (0, react.useCallback)(instance => {
                if (instance) visualState.onMount && visualState.onMount(instance);
                if (visualElement) if (instance) visualElement.mount(instance); else visualElement.unmount();
                if (externalRef) if (typeof externalRef === "function") externalRef(instance); else if (isRefObject(externalRef)) externalRef.current = instance;
            }, [ visualElement ]);
        }
        function useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {
            const {visualElement: parent} = (0, react.useContext)(MotionContext);
            const lazyContext = (0, react.useContext)(LazyContext);
            const presenceContext = (0, react.useContext)(PresenceContext_PresenceContext);
            const reducedMotionConfig = (0, react.useContext)(MotionConfigContext).reducedMotion;
            const visualElementRef = (0, react.useRef)(null);
            createVisualElement = createVisualElement || lazyContext.renderer;
            if (!visualElementRef.current && createVisualElement) visualElementRef.current = createVisualElement(Component, {
                visualState,
                parent,
                props,
                presenceContext,
                blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
                reducedMotionConfig
            });
            const visualElement = visualElementRef.current;
            const initialLayoutGroupConfig = (0, react.useContext)(SwitchLayoutGroupContext);
            if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg")) use_visual_element_createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
            const isMounted = (0, react.useRef)(false);
            (0, react.useInsertionEffect)(() => {
                if (visualElement && isMounted.current) visualElement.update(props, presenceContext);
            });
            const optimisedAppearId = props[optimizedAppearDataAttribute];
            const wantsHandoff = (0, react.useRef)(Boolean(optimisedAppearId) && !window.MotionHandoffIsComplete?.(optimisedAppearId) && window.MotionHasOptimisedAnimation?.(optimisedAppearId));
            use_isomorphic_effect_useIsomorphicLayoutEffect(() => {
                if (!visualElement) return;
                isMounted.current = true;
                window.MotionIsMounted = true;
                visualElement.updateFeatures();
                microtask.render(visualElement.render);
                if (wantsHandoff.current && visualElement.animationState) visualElement.animationState.animateChanges();
            });
            (0, react.useEffect)(() => {
                if (!visualElement) return;
                if (!wantsHandoff.current && visualElement.animationState) visualElement.animationState.animateChanges();
                if (wantsHandoff.current) {
                    queueMicrotask(() => {
                        window.MotionHandoffMarkAsComplete?.(optimisedAppearId);
                    });
                    wantsHandoff.current = false;
                }
            });
            return visualElement;
        }
        function use_visual_element_createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
            const {layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade} = props;
            visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent));
            visualElement.projection.setOptions({
                layoutId,
                layout,
                alwaysMeasureLayout: Boolean(drag) || dragConstraints && isRefObject(dragConstraints),
                visualElement,
                animationType: typeof layout === "string" ? layout : "both",
                initialPromotionConfig,
                crossfade: layoutCrossfade,
                layoutScroll,
                layoutRoot
            });
        }
        function getClosestProjectingNode(visualElement) {
            if (!visualElement) return;
            return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
        }
        "use client";
        function createRendererMotionComponent({preloadedFeatures, createVisualElement, useRender, useVisualState, Component}) {
            preloadedFeatures && loadFeatures(preloadedFeatures);
            function MotionComponent(props, externalRef) {
                let MeasureLayout;
                const configAndProps = {
                    ...(0, react.useContext)(MotionConfigContext),
                    ...props,
                    layoutId: useLayoutId(props)
                };
                const {isStatic} = configAndProps;
                const context = useCreateMotionContext(props);
                const visualState = useVisualState(props, isStatic);
                if (!isStatic && is_browser_isBrowser) {
                    useStrictMode(configAndProps, preloadedFeatures);
                    const layoutProjection = getProjectionFunctionality(configAndProps);
                    MeasureLayout = layoutProjection.MeasureLayout;
                    context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
                }
                return (0, jsx_runtime.jsxs)(MotionContext.Provider, {
                    value: context,
                    children: [ MeasureLayout && context.visualElement ? (0, jsx_runtime.jsx)(MeasureLayout, {
                        visualElement: context.visualElement,
                        ...configAndProps
                    }) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement) ]
                });
            }
            MotionComponent.displayName = `motion.${typeof Component === "string" ? Component : `create(${Component.displayName ?? Component.name ?? ""})`}`;
            const ForwardRefMotionComponent = (0, react.forwardRef)(MotionComponent);
            ForwardRefMotionComponent[motionComponentSymbol] = Component;
            return ForwardRefMotionComponent;
        }
        function useLayoutId({layoutId}) {
            const layoutGroupId = (0, react.useContext)(LayoutGroupContext).id;
            return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
        }
        function useStrictMode(configAndProps, preloadedFeatures) {
            (0, react.useContext)(LazyContext).strict;
            if (false) ;
        }
        function getProjectionFunctionality(props) {
            const {drag, layout} = featureDefinitions;
            if (!drag && !layout) return {};
            const combined = {
                ...drag,
                ...layout
            };
            return {
                MeasureLayout: drag?.isEnabled(props) || layout?.isEnabled(props) ? combined.MeasureLayout : void 0,
                ProjectionNode: combined.ProjectionNode
            };
        }
        function isForcedMotionValue(key, {layout, layoutId}) {
            return transformProps.has(key) || key.startsWith("origin") || (layout || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
        }
        const getValueAsType = (value, type) => type && typeof value === "number" ? type.transform(value) : value;
        const int_int = {
            ...number,
            transform: Math.round
        };
        const transformValueTypes = {
            rotate: degrees,
            rotateX: degrees,
            rotateY: degrees,
            rotateZ: degrees,
            scale,
            scaleX: scale,
            scaleY: scale,
            scaleZ: scale,
            skew: degrees,
            skewX: degrees,
            skewY: degrees,
            distance: px,
            translateX: px,
            translateY: px,
            translateZ: px,
            x: px,
            y: px,
            z: px,
            perspective: px,
            transformPerspective: px,
            opacity: alpha,
            originX: progressPercentage,
            originY: progressPercentage,
            originZ: px
        };
        const numberValueTypes = {
            borderWidth: px,
            borderTopWidth: px,
            borderRightWidth: px,
            borderBottomWidth: px,
            borderLeftWidth: px,
            borderRadius: px,
            radius: px,
            borderTopLeftRadius: px,
            borderTopRightRadius: px,
            borderBottomRightRadius: px,
            borderBottomLeftRadius: px,
            width: px,
            maxWidth: px,
            height: px,
            maxHeight: px,
            top: px,
            right: px,
            bottom: px,
            left: px,
            padding: px,
            paddingTop: px,
            paddingRight: px,
            paddingBottom: px,
            paddingLeft: px,
            margin: px,
            marginTop: px,
            marginRight: px,
            marginBottom: px,
            marginLeft: px,
            backgroundPositionX: px,
            backgroundPositionY: px,
            ...transformValueTypes,
            zIndex: int_int,
            fillOpacity: alpha,
            strokeOpacity: alpha,
            numOctaves: int_int
        };
        const translateAlias = {
            x: "translateX",
            y: "translateY",
            z: "translateZ",
            transformPerspective: "perspective"
        };
        const numTransforms = transformPropOrder.length;
        function buildTransform(latestValues, transform, transformTemplate) {
            let transformString = "";
            let transformIsDefault = true;
            for (let i = 0; i < numTransforms; i++) {
                const key = transformPropOrder[i];
                const value = latestValues[key];
                if (value === void 0) continue;
                let valueIsDefault = true;
                if (typeof value === "number") valueIsDefault = value === (key.startsWith("scale") ? 1 : 0); else valueIsDefault = parseFloat(value) === 0;
                if (!valueIsDefault || transformTemplate) {
                    const valueAsType = getValueAsType(value, numberValueTypes[key]);
                    if (!valueIsDefault) {
                        transformIsDefault = false;
                        const transformName = translateAlias[key] || key;
                        transformString += `${transformName}(${valueAsType}) `;
                    }
                    if (transformTemplate) transform[key] = valueAsType;
                }
            }
            transformString = transformString.trim();
            if (transformTemplate) transformString = transformTemplate(transform, transformIsDefault ? "" : transformString); else if (transformIsDefault) transformString = "none";
            return transformString;
        }
        function buildHTMLStyles(state, latestValues, transformTemplate) {
            const {style, vars, transformOrigin} = state;
            let hasTransform = false;
            let hasTransformOrigin = false;
            for (const key in latestValues) {
                const value = latestValues[key];
                if (transformProps.has(key)) {
                    hasTransform = true;
                    continue;
                } else if (isCSSVariableName(key)) {
                    vars[key] = value;
                    continue;
                } else {
                    const valueAsType = getValueAsType(value, numberValueTypes[key]);
                    if (key.startsWith("origin")) {
                        hasTransformOrigin = true;
                        transformOrigin[key] = valueAsType;
                    } else style[key] = valueAsType;
                }
            }
            if (!latestValues.transform) if (hasTransform || transformTemplate) style.transform = buildTransform(latestValues, state.transform, transformTemplate); else if (style.transform) style.transform = "none";
            if (hasTransformOrigin) {
                const {originX = "50%", originY = "50%", originZ = 0} = transformOrigin;
                style.transformOrigin = `${originX} ${originY} ${originZ}`;
            }
        }
        const createHtmlRenderState = () => ({
            style: {},
            transform: {},
            transformOrigin: {},
            vars: {}
        });
        function copyRawValuesOnly(target, source, props) {
            for (const key in source) if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) target[key] = source[key];
        }
        function useInitialMotionValues({transformTemplate}, visualState) {
            return (0, react.useMemo)(() => {
                const state = createHtmlRenderState();
                buildHTMLStyles(state, visualState, transformTemplate);
                return Object.assign({}, state.vars, state.style);
            }, [ visualState ]);
        }
        function useStyle(props, visualState) {
            const styleProp = props.style || {};
            const style = {};
            copyRawValuesOnly(style, styleProp, props);
            Object.assign(style, useInitialMotionValues(props, visualState));
            return style;
        }
        function useHTMLProps(props, visualState) {
            const htmlProps = {};
            const style = useStyle(props, visualState);
            if (props.drag && props.dragListener !== false) {
                htmlProps.draggable = false;
                style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
                style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
            }
            if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) htmlProps.tabIndex = 0;
            htmlProps.style = style;
            return htmlProps;
        }
        const dashKeys = {
            offset: "stroke-dashoffset",
            array: "stroke-dasharray"
        };
        const camelKeys = {
            offset: "strokeDashoffset",
            array: "strokeDasharray"
        };
        function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {
            attrs.pathLength = 1;
            const keys = useDashCase ? dashKeys : camelKeys;
            attrs[keys.offset] = px.transform(-offset);
            const pathLength = px.transform(length);
            const pathSpacing = px.transform(spacing);
            attrs[keys.array] = `${pathLength} ${pathSpacing}`;
        }
        function buildSVGAttrs(state, {attrX, attrY, attrScale, pathLength, pathSpacing = 1, pathOffset = 0, ...latest}, isSVGTag, transformTemplate, styleProp) {
            buildHTMLStyles(state, latest, transformTemplate);
            if (isSVGTag) {
                if (state.style.viewBox) state.attrs.viewBox = state.style.viewBox;
                return;
            }
            state.attrs = state.style;
            state.style = {};
            const {attrs, style} = state;
            if (attrs.transform) {
                style.transform = attrs.transform;
                delete attrs.transform;
            }
            if (style.transform || attrs.transformOrigin) {
                style.transformOrigin = attrs.transformOrigin ?? "50% 50%";
                delete attrs.transformOrigin;
            }
            if (style.transform) {
                style.transformBox = styleProp?.transformBox ?? "fill-box";
                delete attrs.transformBox;
            }
            if (attrX !== void 0) attrs.x = attrX;
            if (attrY !== void 0) attrs.y = attrY;
            if (attrScale !== void 0) attrs.scale = attrScale;
            if (pathLength !== void 0) buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
        }
        const createSvgRenderState = () => ({
            ...createHtmlRenderState(),
            attrs: {}
        });
        const isSVGTag = tag => typeof tag === "string" && tag.toLowerCase() === "svg";
        function useSVGProps(props, visualState, _isStatic, Component) {
            const visualProps = (0, react.useMemo)(() => {
                const state = createSvgRenderState();
                buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate, props.style);
                return {
                    ...state.attrs,
                    style: {
                        ...state.style
                    }
                };
            }, [ visualState ]);
            if (props.style) {
                const rawStyles = {};
                copyRawValuesOnly(rawStyles, props.style, props);
                visualProps.style = {
                    ...rawStyles,
                    ...visualProps.style
                };
            }
            return visualProps;
        }
        const validMotionProps = new Set([ "animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport" ]);
        function isValidMotionProp(key) {
            return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
        }
        let shouldForward = key => !isValidMotionProp(key);
        function loadExternalIsValidProp(isValidProp) {
            if (typeof isValidProp !== "function") return;
            shouldForward = key => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
        }
        try {
            loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
        } catch {}
        function filterProps(props, isDom, forwardMotionProps) {
            const filteredProps = {};
            for (const key in props) {
                if (key === "values" && typeof props.values === "object") continue;
                if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || props["draggable"] && key.startsWith("onDrag")) filteredProps[key] = props[key];
            }
            return filteredProps;
        }
        const lowercaseSVGElements = [ "animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view" ];
        function isSVGComponent(Component) {
            if (typeof Component !== "string" || Component.includes("-")) return false; else if (lowercaseSVGElements.indexOf(Component) > -1 || /[A-Z]/u.test(Component)) return true;
            return false;
        }
        function createUseRender(forwardMotionProps = false) {
            const useRender = (Component, props, ref, {latestValues}, isStatic) => {
                const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;
                const visualProps = useVisualProps(props, latestValues, isStatic, Component);
                const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
                const elementProps = Component !== react.Fragment ? {
                    ...filteredProps,
                    ...visualProps,
                    ref
                } : {};
                const {children} = props;
                const renderedChildren = (0, react.useMemo)(() => isMotionValue(children) ? children.get() : children, [ children ]);
                return (0, react.createElement)(Component, {
                    ...elementProps,
                    children: renderedChildren
                });
            };
            return useRender;
        }
        function makeState({scrapeMotionValuesFromProps, createRenderState}, props, context, presenceContext) {
            const state = {
                latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),
                renderState: createRenderState()
            };
            return state;
        }
        const makeUseVisualState = config => (props, isStatic) => {
            const context = (0, react.useContext)(MotionContext);
            const presenceContext = (0, react.useContext)(PresenceContext_PresenceContext);
            const make = () => makeState(config, props, context, presenceContext);
            return isStatic ? make() : useConstant(make);
        };
        function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
            const values = {};
            const motionValues = scrapeMotionValues(props, {});
            for (const key in motionValues) values[key] = resolveMotionValue(motionValues[key]);
            let {initial, animate} = props;
            const isControllingVariants$1 = isControllingVariants(props);
            const isVariantNode$1 = isVariantNode(props);
            if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
                if (initial === void 0) initial = context.initial;
                if (animate === void 0) animate = context.animate;
            }
            let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
            isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
            const variantToSet = isInitialAnimationBlocked ? animate : initial;
            if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
                const list = Array.isArray(variantToSet) ? variantToSet : [ variantToSet ];
                for (let i = 0; i < list.length; i++) {
                    const resolved = resolveVariantFromProps(props, list[i]);
                    if (resolved) {
                        const {transitionEnd, transition, ...target} = resolved;
                        for (const key in target) {
                            let valueTarget = target[key];
                            if (Array.isArray(valueTarget)) {
                                const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
                                valueTarget = valueTarget[index];
                            }
                            if (valueTarget !== null) values[key] = valueTarget;
                        }
                        for (const key in transitionEnd) values[key] = transitionEnd[key];
                    }
                }
            }
            return values;
        }
        function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
            const {style} = props;
            const newValues = {};
            for (const key in style) if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || visualElement?.getValue(key)?.liveStyle !== void 0) newValues[key] = style[key];
            return newValues;
        }
        const htmlMotionConfig = {
            useVisualState: makeUseVisualState({
                scrapeMotionValuesFromProps,
                createRenderState: createHtmlRenderState
            })
        };
        function scrape_motion_values_scrapeMotionValuesFromProps(props, prevProps, visualElement) {
            const newValues = scrapeMotionValuesFromProps(props, prevProps, visualElement);
            for (const key in props) if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
                const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
                newValues[targetKey] = props[key];
            }
            return newValues;
        }
        const svgMotionConfig = {
            useVisualState: makeUseVisualState({
                scrapeMotionValuesFromProps: scrape_motion_values_scrapeMotionValuesFromProps,
                createRenderState: createSvgRenderState
            })
        };
        function createMotionComponentFactory(preloadedFeatures, createVisualElement) {
            return function createMotionComponent(Component, {forwardMotionProps} = {
                forwardMotionProps: false
            }) {
                const baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;
                const config = {
                    ...baseConfig,
                    preloadedFeatures,
                    useRender: createUseRender(forwardMotionProps),
                    createVisualElement,
                    Component
                };
                return createRendererMotionComponent(config);
            };
        }
        const auto = {
            test: v => v === "auto",
            parse: v => v
        };
        const testValueType = v => type => type.test(v);
        const dimensionValueTypes = [ number, px, percent, degrees, vw, vh, auto ];
        const findDimensionValueType = v => dimensionValueTypes.find(testValueType(v));
        const isNumericalString = v => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v);
        const splitCSSVariableRegex = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
        function parseCSSVariable(current) {
            const match = splitCSSVariableRegex.exec(current);
            if (!match) return [ ,  ];
            const [, token1, token2, fallback] = match;
            return [ `--${token1 ?? token2}`, fallback ];
        }
        const maxDepth = 4;
        function getVariableValue(current, element, depth = 1) {
            errors_invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);
            const [token, fallback] = parseCSSVariable(current);
            if (!token) return;
            const resolved = window.getComputedStyle(element).getPropertyValue(token);
            if (resolved) {
                const trimmed = resolved.trim();
                return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
            }
            return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
        }
        const isZeroValueString = v => /^0[^.\s]+$/u.test(v);
        function isNone(value) {
            if (typeof value === "number") return value === 0; else if (value !== null) return value === "none" || value === "0" || isZeroValueString(value); else return true;
        }
        const maxDefaults = new Set([ "brightness", "contrast", "saturate", "opacity" ]);
        function applyDefaultFilter(v) {
            const [name, value] = v.slice(0, -1).split("(");
            if (name === "drop-shadow") return v;
            const [number] = value.match(floatRegex) || [];
            if (!number) return v;
            const unit = value.replace(number, "");
            let defaultValue = maxDefaults.has(name) ? 1 : 0;
            if (number !== value) defaultValue *= 100;
            return name + "(" + defaultValue + unit + ")";
        }
        const functionRegex = /\b([a-z-]*)\(.*?\)/gu;
        const filter = {
            ...complex,
            getAnimatableNone: v => {
                const functions = v.match(functionRegex);
                return functions ? functions.map(applyDefaultFilter).join(" ") : v;
            }
        };
        const defaultValueTypes = {
            ...numberValueTypes,
            color,
            backgroundColor: color,
            outlineColor: color,
            fill: color,
            stroke: color,
            borderColor: color,
            borderTopColor: color,
            borderRightColor: color,
            borderBottomColor: color,
            borderLeftColor: color,
            filter,
            WebkitFilter: filter
        };
        const getDefaultValueType = key => defaultValueTypes[key];
        function animatable_none_getAnimatableNone(key, value) {
            let defaultValueType = getDefaultValueType(key);
            if (defaultValueType !== filter) defaultValueType = complex;
            return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
        }
        const invalidTemplates = new Set([ "auto", "none", "0" ]);
        function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
            let i = 0;
            let animatableTemplate;
            while (i < unresolvedKeyframes.length && !animatableTemplate) {
                const keyframe = unresolvedKeyframes[i];
                if (typeof keyframe === "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length) animatableTemplate = unresolvedKeyframes[i];
                i++;
            }
            if (animatableTemplate && name) for (const noneIndex of noneKeyframeIndexes) unresolvedKeyframes[noneIndex] = animatable_none_getAnimatableNone(name, animatableTemplate);
        }
        class DOMKeyframesResolver extends KeyframeResolver {
            constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {
                super(unresolvedKeyframes, onComplete, name, motionValue, element, true);
            }
            readKeyframes() {
                const {unresolvedKeyframes, element, name} = this;
                if (!element || !element.current) return;
                super.readKeyframes();
                for (let i = 0; i < unresolvedKeyframes.length; i++) {
                    let keyframe = unresolvedKeyframes[i];
                    if (typeof keyframe === "string") {
                        keyframe = keyframe.trim();
                        if (isCSSVariableToken(keyframe)) {
                            const resolved = getVariableValue(keyframe, element.current);
                            if (resolved !== void 0) unresolvedKeyframes[i] = resolved;
                            if (i === unresolvedKeyframes.length - 1) this.finalKeyframe = keyframe;
                        }
                    }
                }
                this.resolveNoneKeyframes();
                if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) return;
                const [origin, target] = unresolvedKeyframes;
                const originType = findDimensionValueType(origin);
                const targetType = findDimensionValueType(target);
                if (originType === targetType) return;
                if (isNumOrPxType(originType) && isNumOrPxType(targetType)) for (let i = 0; i < unresolvedKeyframes.length; i++) {
                    const value = unresolvedKeyframes[i];
                    if (typeof value === "string") unresolvedKeyframes[i] = parseFloat(value);
                } else if (positionalValues[name]) this.needsMeasurement = true;
            }
            resolveNoneKeyframes() {
                const {unresolvedKeyframes, name} = this;
                const noneKeyframeIndexes = [];
                for (let i = 0; i < unresolvedKeyframes.length; i++) if (unresolvedKeyframes[i] === null || isNone(unresolvedKeyframes[i])) noneKeyframeIndexes.push(i);
                if (noneKeyframeIndexes.length) makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
            }
            measureInitialState() {
                const {element, unresolvedKeyframes, name} = this;
                if (!element || !element.current) return;
                if (name === "height") this.suspendedScrollY = window.pageYOffset;
                this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
                unresolvedKeyframes[0] = this.measuredOrigin;
                const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
                if (measureKeyframe !== void 0) element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
            }
            measureEndState() {
                const {element, name, unresolvedKeyframes} = this;
                if (!element || !element.current) return;
                const value = element.getValue(name);
                value && value.jump(this.measuredOrigin, false);
                const finalKeyframeIndex = unresolvedKeyframes.length - 1;
                const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
                unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
                if (finalKeyframe !== null && this.finalKeyframe === void 0) this.finalKeyframe = finalKeyframe;
                if (this.removedTransforms?.length) this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
                    element.getValue(unsetTransformName).set(unsetTransformValue);
                });
                this.resolveNoneKeyframes();
            }
        }
        const valueTypes = [ ...dimensionValueTypes, color, complex ];
        const findValueType = v => valueTypes.find(testValueType(v));
        const prefersReducedMotion = {
            current: null
        };
        const hasReducedMotionListener = {
            current: false
        };
        function initPrefersReducedMotion() {
            hasReducedMotionListener.current = true;
            if (!is_browser_isBrowser) return;
            if (window.matchMedia) {
                const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
                const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
                motionMediaQuery.addEventListener("change", setReducedMotionPreferences);
                setReducedMotionPreferences();
            } else prefersReducedMotion.current = false;
        }
        const visualElementStore = new WeakMap;
        function updateMotionValuesFromProps(element, next, prev) {
            for (const key in next) {
                const nextValue = next[key];
                const prevValue = prev[key];
                if (isMotionValue(nextValue)) element.addValue(key, nextValue); else if (isMotionValue(prevValue)) element.addValue(key, motionValue(nextValue, {
                    owner: element
                })); else if (prevValue !== nextValue) if (element.hasValue(key)) {
                    const existingValue = element.getValue(key);
                    if (existingValue.liveStyle === true) existingValue.jump(nextValue); else if (!existingValue.hasAnimated) existingValue.set(nextValue);
                } else {
                    const latestValue = element.getStaticValue(key);
                    element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, {
                        owner: element
                    }));
                }
            }
            for (const key in prev) if (next[key] === void 0) element.removeValue(key);
            return next;
        }
        const propEventHandlers = [ "AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete" ];
        class VisualElement {
            scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
                return {};
            }
            constructor({parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState}, options = {}) {
                this.current = null;
                this.children = new Set;
                this.isVariantNode = false;
                this.isControllingVariants = false;
                this.shouldReduceMotion = null;
                this.values = new Map;
                this.KeyframeResolver = KeyframeResolver;
                this.features = {};
                this.valueSubscriptions = new Map;
                this.prevMotionValues = {};
                this.events = {};
                this.propEventSubscriptions = {};
                this.notifyUpdate = () => this.notify("Update", this.latestValues);
                this.render = () => {
                    if (!this.current) return;
                    this.triggerBuild();
                    this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
                };
                this.renderScheduledAt = 0;
                this.scheduleRender = () => {
                    const now = time.now();
                    if (this.renderScheduledAt < now) {
                        this.renderScheduledAt = now;
                        frame_frame.render(this.render, false, true);
                    }
                };
                const {latestValues, renderState} = visualState;
                this.latestValues = latestValues;
                this.baseTarget = {
                    ...latestValues
                };
                this.initialValues = props.initial ? {
                    ...latestValues
                } : {};
                this.renderState = renderState;
                this.parent = parent;
                this.props = props;
                this.presenceContext = presenceContext;
                this.depth = parent ? parent.depth + 1 : 0;
                this.reducedMotionConfig = reducedMotionConfig;
                this.options = options;
                this.blockInitialAnimation = Boolean(blockInitialAnimation);
                this.isControllingVariants = isControllingVariants(props);
                this.isVariantNode = isVariantNode(props);
                if (this.isVariantNode) this.variantChildren = new Set;
                this.manuallyAnimateOnMount = Boolean(parent && parent.current);
                const {willChange, ...initialMotionValues} = this.scrapeMotionValuesFromProps(props, {}, this);
                for (const key in initialMotionValues) {
                    const value = initialMotionValues[key];
                    if (latestValues[key] !== void 0 && isMotionValue(value)) value.set(latestValues[key], false);
                }
            }
            mount(instance) {
                this.current = instance;
                visualElementStore.set(instance, this);
                if (this.projection && !this.projection.instance) this.projection.mount(instance);
                if (this.parent && this.isVariantNode && !this.isControllingVariants) this.removeFromVariantTree = this.parent.addVariantChild(this);
                this.values.forEach((value, key) => this.bindToMotionValue(key, value));
                if (!hasReducedMotionListener.current) initPrefersReducedMotion();
                this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
                if (false) ;
                if (this.parent) this.parent.children.add(this);
                this.update(this.props, this.presenceContext);
            }
            unmount() {
                this.projection && this.projection.unmount();
                cancelFrame(this.notifyUpdate);
                cancelFrame(this.render);
                this.valueSubscriptions.forEach(remove => remove());
                this.valueSubscriptions.clear();
                this.removeFromVariantTree && this.removeFromVariantTree();
                this.parent && this.parent.children.delete(this);
                for (const key in this.events) this.events[key].clear();
                for (const key in this.features) {
                    const feature = this.features[key];
                    if (feature) {
                        feature.unmount();
                        feature.isMounted = false;
                    }
                }
                this.current = null;
            }
            bindToMotionValue(key, value) {
                if (this.valueSubscriptions.has(key)) this.valueSubscriptions.get(key)();
                const valueIsTransform = transformProps.has(key);
                if (valueIsTransform && this.onBindTransform) this.onBindTransform();
                const removeOnChange = value.on("change", latestValue => {
                    this.latestValues[key] = latestValue;
                    this.props.onUpdate && frame_frame.preRender(this.notifyUpdate);
                    if (valueIsTransform && this.projection) this.projection.isTransformDirty = true;
                });
                const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
                let removeSyncCheck;
                if (window.MotionCheckAppearSync) removeSyncCheck = window.MotionCheckAppearSync(this, key, value);
                this.valueSubscriptions.set(key, () => {
                    removeOnChange();
                    removeOnRenderRequest();
                    if (removeSyncCheck) removeSyncCheck();
                    if (value.owner) value.stop();
                });
            }
            sortNodePosition(other) {
                if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) return 0;
                return this.sortInstanceNodePosition(this.current, other.current);
            }
            updateFeatures() {
                let key = "animation";
                for (key in featureDefinitions) {
                    const featureDefinition = featureDefinitions[key];
                    if (!featureDefinition) continue;
                    const {isEnabled, Feature: FeatureConstructor} = featureDefinition;
                    if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) this.features[key] = new FeatureConstructor(this);
                    if (this.features[key]) {
                        const feature = this.features[key];
                        if (feature.isMounted) feature.update(); else {
                            feature.mount();
                            feature.isMounted = true;
                        }
                    }
                }
            }
            triggerBuild() {
                this.build(this.renderState, this.latestValues, this.props);
            }
            measureViewportBox() {
                return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
            }
            getStaticValue(key) {
                return this.latestValues[key];
            }
            setStaticValue(key, value) {
                this.latestValues[key] = value;
            }
            update(props, presenceContext) {
                if (props.transformTemplate || this.props.transformTemplate) this.scheduleRender();
                this.prevProps = this.props;
                this.props = props;
                this.prevPresenceContext = this.presenceContext;
                this.presenceContext = presenceContext;
                for (let i = 0; i < propEventHandlers.length; i++) {
                    const key = propEventHandlers[i];
                    if (this.propEventSubscriptions[key]) {
                        this.propEventSubscriptions[key]();
                        delete this.propEventSubscriptions[key];
                    }
                    const listenerName = "on" + key;
                    const listener = props[listenerName];
                    if (listener) this.propEventSubscriptions[key] = this.on(key, listener);
                }
                this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);
                if (this.handleChildMotionValue) this.handleChildMotionValue();
            }
            getProps() {
                return this.props;
            }
            getVariant(name) {
                return this.props.variants ? this.props.variants[name] : void 0;
            }
            getDefaultTransition() {
                return this.props.transition;
            }
            getTransformPagePoint() {
                return this.props.transformPagePoint;
            }
            getClosestVariantNode() {
                return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
            }
            addVariantChild(child) {
                const closestVariantNode = this.getClosestVariantNode();
                if (closestVariantNode) {
                    closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
                    return () => closestVariantNode.variantChildren.delete(child);
                }
            }
            addValue(key, value) {
                const existingValue = this.values.get(key);
                if (value !== existingValue) {
                    if (existingValue) this.removeValue(key);
                    this.bindToMotionValue(key, value);
                    this.values.set(key, value);
                    this.latestValues[key] = value.get();
                }
            }
            removeValue(key) {
                this.values.delete(key);
                const unsubscribe = this.valueSubscriptions.get(key);
                if (unsubscribe) {
                    unsubscribe();
                    this.valueSubscriptions.delete(key);
                }
                delete this.latestValues[key];
                this.removeValueFromRenderState(key, this.renderState);
            }
            hasValue(key) {
                return this.values.has(key);
            }
            getValue(key, defaultValue) {
                if (this.props.values && this.props.values[key]) return this.props.values[key];
                let value = this.values.get(key);
                if (value === void 0 && defaultValue !== void 0) {
                    value = motionValue(defaultValue === null ? void 0 : defaultValue, {
                        owner: this
                    });
                    this.addValue(key, value);
                }
                return value;
            }
            readValue(key, target) {
                let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : this.getBaseTargetFromProps(this.props, key) ?? this.readValueFromInstance(this.current, key, this.options);
                if (value !== void 0 && value !== null) {
                    if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) value = parseFloat(value); else if (!findValueType(value) && complex.test(target)) value = animatable_none_getAnimatableNone(key, target);
                    this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
                }
                return isMotionValue(value) ? value.get() : value;
            }
            setBaseTarget(key, value) {
                this.baseTarget[key] = value;
            }
            getBaseTarget(key) {
                const {initial} = this.props;
                let valueFromInitial;
                if (typeof initial === "string" || typeof initial === "object") {
                    const variant = resolveVariantFromProps(this.props, initial, this.presenceContext?.custom);
                    if (variant) valueFromInitial = variant[key];
                }
                if (initial && valueFromInitial !== void 0) return valueFromInitial;
                const target = this.getBaseTargetFromProps(this.props, key);
                if (target !== void 0 && !isMotionValue(target)) return target;
                return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
            }
            on(eventName, callback) {
                if (!this.events[eventName]) this.events[eventName] = new SubscriptionManager;
                return this.events[eventName].add(callback);
            }
            notify(eventName, ...args) {
                if (this.events[eventName]) this.events[eventName].notify(...args);
            }
        }
        class DOMVisualElement extends VisualElement {
            constructor() {
                super(...arguments);
                this.KeyframeResolver = DOMKeyframesResolver;
            }
            sortInstanceNodePosition(a, b) {
                return a.compareDocumentPosition(b) & 2 ? 1 : -1;
            }
            getBaseTargetFromProps(props, key) {
                return props.style ? props.style[key] : void 0;
            }
            removeValueFromRenderState(key, {vars, style}) {
                delete vars[key];
                delete style[key];
            }
            handleChildMotionValue() {
                if (this.childSubscription) {
                    this.childSubscription();
                    delete this.childSubscription;
                }
                const {children} = this.props;
                if (isMotionValue(children)) this.childSubscription = children.on("change", latest => {
                    if (this.current) this.current.textContent = `${latest}`;
                });
            }
        }
        function renderHTML(element, {style, vars}, styleProp, projection) {
            const elementStyle = element.style;
            let key;
            for (key in style) elementStyle[key] = style[key];
            projection?.applyProjectionStyles(elementStyle, styleProp);
            for (key in vars) elementStyle.setProperty(key, vars[key]);
        }
        function HTMLVisualElement_getComputedStyle(element) {
            return window.getComputedStyle(element);
        }
        class HTMLVisualElement extends DOMVisualElement {
            constructor() {
                super(...arguments);
                this.type = "html";
                this.renderInstance = renderHTML;
            }
            readValueFromInstance(instance, key) {
                if (transformProps.has(key)) return this.projection?.isProjecting ? defaultTransformValue(key) : readTransformValue(instance, key); else {
                    const computedStyle = HTMLVisualElement_getComputedStyle(instance);
                    const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
                    return typeof value === "string" ? value.trim() : value;
                }
            }
            measureInstanceViewportBox(instance, {transformPagePoint}) {
                return measureViewportBox(instance, transformPagePoint);
            }
            build(renderState, latestValues, props) {
                buildHTMLStyles(renderState, latestValues, props.transformTemplate);
            }
            scrapeMotionValuesFromProps(props, prevProps, visualElement) {
                return scrapeMotionValuesFromProps(props, prevProps, visualElement);
            }
        }
        const camelCaseAttributes = new Set([ "baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust" ]);
        function renderSVG(element, renderState, _styleProp, projection) {
            renderHTML(element, renderState, void 0, projection);
            for (const key in renderState.attrs) element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
        }
        class SVGVisualElement extends DOMVisualElement {
            constructor() {
                super(...arguments);
                this.type = "svg";
                this.isSVGTag = false;
                this.measureInstanceViewportBox = createBox;
            }
            getBaseTargetFromProps(props, key) {
                return props[key];
            }
            readValueFromInstance(instance, key) {
                if (transformProps.has(key)) {
                    const defaultType = getDefaultValueType(key);
                    return defaultType ? defaultType.default || 0 : 0;
                }
                key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
                return instance.getAttribute(key);
            }
            scrapeMotionValuesFromProps(props, prevProps, visualElement) {
                return scrape_motion_values_scrapeMotionValuesFromProps(props, prevProps, visualElement);
            }
            build(renderState, latestValues, props) {
                buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate, props.style);
            }
            renderInstance(instance, renderState, styleProp, projection) {
                renderSVG(instance, renderState, styleProp, projection);
            }
            mount(instance) {
                this.isSVGTag = isSVGTag(instance.tagName);
                super.mount(instance);
            }
        }
        const createDomVisualElement = (Component, options) => isSVGComponent(Component) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
            allowProjection: Component !== react.Fragment
        });
        const createMotionComponent = createMotionComponentFactory({
            ...animations,
            ...gestureAnimations,
            ...drag,
            ...layout
        }, createDomVisualElement);
        const motion = createDOMMotionComponentProxy(createMotionComponent);
        const PlatformsSection = () => react.createElement("section", {
            className: "platforms"
        }, react.createElement("div", {
            className: "platforms__container blur-1 blur-2"
        }, react.createElement("div", {
            className: "platforms__wrapper"
        }, react.createElement("div", {
            className: "platforms__content"
        }, react.createElement("h1", {
            className: "platforms__title"
        }, react.createElement("span", null, "PLATFORM"), react.createElement("br", null), "CRM", react.createElement("br", null), " RETENTION MODULE")), react.createElement("div", {
            className: "platforms__image"
        }, react.createElement("picture", null, react.createElement("source", {
            media: "(max-width: 767.98px)",
            srcSet: "img/main/main_image-03_mob.webp"
        }), react.createElement("source", {
            media: "(min-width: 767.98px)",
            srcSet: "img/main/main_image-03_pc.webp"
        }), react.createElement("img", {
            src: "img/main/main_image-03_pc.webp",
            alt: ""
        }))))));
        const solutionspage_PlatformsSection = PlatformsSection;
        const AdvantagesSection = () => react.createElement("section", {
            className: "advantages"
        }, react.createElement("div", {
            className: "advantages__container"
        }, react.createElement("div", {
            className: "advantages__main"
        }, react.createElement("div", {
            className: "advantages__top"
        }, react.createElement("h2", {
            className: "advantages__title"
        }, "RELIABLE AND SCALABLE GAMING ", react.createElement("span", null, "PLATFORM")), react.createElement("div", {
            className: "advantages__text text-mob"
        }, "Thanks to high-availability cloud architecture and backup systems,", " ", react.createElement("br", null), react.createElement("span", null, "SPINREE"), " delivers nonstop gaming performance, 24/7.")), react.createElement("div", {
            className: "advantages__wrapper"
        }, react.createElement("div", {
            className: "advantages__item"
        }, "Security"), react.createElement("div", {
            className: "advantages__item"
        }, "SCALABILITY"), react.createElement("div", {
            className: "advantages__item"
        }, "FLEXIBILITY"))), react.createElement("div", {
            className: "advantages__bg"
        })));
        const solutionspage_AdvantagesSection = AdvantagesSection;
        const GamificationSection = () => react.createElement("section", {
            className: "gamification"
        }, react.createElement("div", {
            className: "gamification__container"
        }, react.createElement("div", {
            className: "gamification__main"
        }, react.createElement("div", {
            className: "gamification__top"
        }, react.createElement("h2", {
            className: "gamification__title"
        }, react.createElement("span", null, "PLAYER-FOCUSED"), " GAMIFICATION SYSTEM"), react.createElement("div", {
            className: "gamification__text text-mob"
        }, "Focusing on client retention excellence, our platform enhances gameplay by refining every step of the users iGaming journey.")))));
        const solutionspage_GamificationSection = GamificationSection;
        const newsSegmentations = [ {
            title: "CRM",
            image: "img/segmentations/image-01.webp",
            content: [ "A variety of bonus mechanics: cashbacks, tiered VIP programs, and local jackpots.", "Full-scale communication via Email, SMS, Push notifications, and in-game messaging.", "Gamification elements to boost player engagement." ]
        }, {
            title: "SEGMENTATION",
            image: "img/segmentations/image-02.webp",
            content: [ "Flexible user segmentation based on behavioral and demographic data.", "Automatic segment updates and real-time response to player actions.", "Integration with CRM and bonus systems." ]
        }, {
            title: "payments",
            image: "img/segmentations/image-03.webp",
            content: [ "Supports Visa, MasterCard, Pix, Paytm, UPI, SPEI, Skrill, crypto (BTC, ETH), and more.", "Easy integration of new payment methods.", "Real-time transaction tracking." ]
        }, {
            title: "games",
            image: "img/segmentations/image-04.webp",
            content: [ "Over 10,000 games from leading global providers on competitive terms.", "Ability to add any game provider upon individual request.", "Option to include a sportsbook or virtual sports." ]
        }, {
            title: "backoffice",
            image: "img/segmentations/image-05.webp",
            content: [ "Flexible configuration of all business aspects: bonuses, payment systems, CRM.", "Detailed reporting and analytics to enable timely decision-making.", "Role-based access control (RBAC) to manage permissions for different team members." ]
        } ];
        const NewsSegmentationSlide = ({title, image, content}) => react.createElement("div", {
            className: "segment__slide"
        }, react.createElement("div", {
            className: "segment__inner"
        }, react.createElement("div", {
            className: "segment__content"
        }, react.createElement("ul", {
            className: "segment__list"
        }, content.map((item, idx) => react.createElement("li", {
            className: "segment__item text-mob",
            key: idx
        }, item))), react.createElement("a", {
            href: "https://t.me/sales_spinree",
            className: "segment__more"
        }, "request info")), react.createElement("div", {
            className: "segment__image"
        }, react.createElement("img", {
            src: image,
            alt: title
        }))));
        const SegmentationSection = () => {
            const [activeIndex, setActiveIndex] = (0, react.useState)(0);
            const swiperRef = (0, react.useRef)(null);
            const onSlideChange = swiper => {
                setActiveIndex(swiper.activeIndex);
            };
            const goToSlide = index => {
                if (swiperRef.current) swiperRef.current.slideTo(index);
            };
            return react.createElement("section", {
                className: "segment"
            }, react.createElement("div", {
                className: "segment__container"
            }, react.createElement("div", {
                className: "segment__main"
            }, react.createElement("div", {
                className: "segment__titles"
            }, newsSegmentations.map((item, idx) => react.createElement("button", {
                key: idx,
                className: `segment__title ${activeIndex === idx ? "segment__title--active" : ""}`,
                onClick: () => goToSlide(idx),
                type: "button"
            }, item.title))), react.createElement("div", {
                className: "segment__title-mobile"
            }, react.createElement("button", {
                className: "segment__nav-btn segment__nav-prev _icon-arrow-btn",
                onClick: () => swiperRef.current?.slidePrev(),
                disabled: activeIndex === 0,
                "aria-label": "Previous slide",
                type: "button"
            }), react.createElement("span", {
                className: "segment__title-mobile-text"
            }, newsSegmentations[activeIndex]?.title), react.createElement("button", {
                className: "segment__nav-btn segment__nav-next _icon-arrow-btn",
                onClick: () => swiperRef.current?.slideNext(),
                disabled: activeIndex === newsSegmentations.length - 1,
                "aria-label": "Next slide",
                type: "button"
            })), react.createElement(swiper_react_Swiper, {
                modules: [ Pagination, EffectFade ],
                onSwiper: swiper => swiperRef.current = swiper,
                onSlideChange,
                effect: "fade",
                fadeEffect: {
                    crossFade: true
                },
                observer: true,
                observeParents: true,
                slidesPerView: 1,
                spaceBetween: 16,
                speed: 400,
                pagination: {
                    clickable: true
                }
            }, newsSegmentations.map((item, index) => react.createElement(SwiperSlide, {
                key: index
            }, react.createElement(NewsSegmentationSlide, item)))))));
        };
        const solutionspage_SegmentationSection = SegmentationSection;
        const solutions = [ {
            title: "Whitelabel",
            subtitle: "Solution",
            text: "A fast-launch solution based on pre-built templates. Ideal for rapid market entry without the need for deep technical involvement."
        }, {
            title: "Turnkey",
            subtitle: "Solution",
            text: "A fully customizable iGaming solution tailored to each client's business needs, including individual design, custom logic, and integrations."
        } ];
        const SolutionsSection = () => react.createElement("section", {
            className: "solutions"
        }, react.createElement("div", {
            className: "solutions__container"
        }, react.createElement("div", {
            className: "solutions__wrapper"
        }, solutions.map((item, index) => react.createElement("div", {
            className: "solutions__item",
            key: index
        }, react.createElement("div", {
            className: "solutions__title h2"
        }, react.createElement("span", null, item.title), " ", item.subtitle), react.createElement("div", {
            className: "solutions__text text-mob"
        }, item.text)))), react.createElement("div", {
            className: "solutions__bg"
        })));
        const solutionspage_SolutionsSection = SolutionsSection;
        const AdditionalServicesSection = () => {
            const services = [ {
                title: react.createElement(react.Fragment, null, react.createElement("span", null, "Game"), " Aggregation"),
                text: "API access to thousands of games from top global providers, including slots, live casino, virtual games and more.",
                image: "img/services/image-01.webp"
            }, {
                title: react.createElement(react.Fragment, null, "Technical ", react.createElement("span", null, "support"), " and updates"),
                text: "SpinRee's Game Aggregation saves integration resources and allows you to focus on growth and player retention.",
                image: "img/services/image-02.webp"
            }, {
                title: react.createElement(react.Fragment, null, react.createElement("span", null, "Blockchain"), " & Web 3.0 Development"),
                text: "Extensive expertise in developing and implementing decentralized solutions for iGaming and related industries.",
                image: "img/services/image-03.webp"
            }, {
                title: react.createElement(react.Fragment, null, "Assistance with ", react.createElement("span", null, "crypto payment"), " systems"),
                text: "Consulting on Web 3.0 strategy, legalization, and licensing Audits, scalability planning, and technical support.",
                image: "img/services/image-04.webp"
            } ];
            return react.createElement("section", {
                className: "additional-services"
            }, react.createElement("div", {
                className: "additional-services__container blur-1 blur-2"
            }, react.createElement("div", {
                className: "additional-services__title h2"
            }, "ADDITIONAL SERVICES"), react.createElement("div", {
                className: "additional-services__wrapper"
            }, services.map((service, index) => react.createElement(motion.div, {
                initial: {
                    opacity: 0,
                    y: 50
                },
                whileInView: {
                    opacity: 1,
                    y: 0
                },
                transition: {
                    duration: .8,
                    delay: index * .15
                },
                viewport: {
                    once: true,
                    amount: .3
                },
                key: index,
                className: "additional-services__item"
            }, react.createElement("div", {
                className: "additional-services__content"
            }, react.createElement("div", {
                className: "additional-services__subtitle title-m"
            }, service.title), react.createElement("div", {
                className: "additional-services__text text-s text-mob"
            }, service.text)), react.createElement("div", {
                className: "additional-services__image"
            }, react.createElement("img", {
                src: service.image,
                alt: ""
            }))))), react.createElement("div", {
                className: "additional-services__bottom title-s"
            }, "Our ", react.createElement("span", null, "goal"), " is not just to implement blockchain functionality, but to embed it into your business model for maximum value and ROI!")));
        };
        const solutionspage_AdditionalServicesSection = AdditionalServicesSection;
        function SolutionsPage() {
            return react.createElement(motion.div, {
                initial: {
                    opacity: 0,
                    y: 20
                },
                animate: {
                    opacity: 1,
                    y: 0
                },
                exit: {
                    opacity: 0,
                    y: -20
                },
                transition: {
                    duration: .2
                }
            }, react.createElement(Header, null), react.createElement("main", null, react.createElement(solutionspage_PlatformsSection, null), react.createElement(solutionspage_AdvantagesSection, null), react.createElement(solutionspage_GamificationSection, null), react.createElement(solutionspage_SegmentationSection, null), react.createElement(solutionspage_SolutionsSection, null), react.createElement(solutionspage_AdditionalServicesSection, null), react.createElement(homepage_FormSection, null)), react.createElement(Footer, null));
        }
        const src_SolutionsPage = SolutionsPage;
        const App = () => react.createElement(react.Fragment, null, react.createElement(Header, null), react.createElement("main", null, react.createElement(homepage_MainSection, null), react.createElement(AboutSection, null), react.createElement(homepage_ServicesSection, null), react.createElement(homepage_BenefitsSection, null), react.createElement(homepage_NewsSection, null), react.createElement(homepage_FormSection, null)), react.createElement(Footer, null));
        const AnimatedRoutes = () => {
            const location = useLocation();
            return react.createElement(AnimatePresence, {
                mode: "wait"
            }, react.createElement(Routes, {
                location,
                key: location.pathname
            }, react.createElement(Route, {
                path: "/",
                element: react.createElement(App, null)
            }), react.createElement(Route, {
                path: "/solutions",
                element: react.createElement(src_SolutionsPage, null)
            })));
        };
        const root = document.querySelector("#root") || document.querySelector(".wrapper");
        client.createRoot(root).render(react.createElement(react.StrictMode, null, react.createElement(HashRouter, null, react.createElement(AnimatedRoutes, null))));
        let bodyLockStatus = true;
        let bodyLockToggle = (delay = 0) => {
            if (document.documentElement.classList.contains("lock")) bodyUnlock(delay); else bodyLock(delay);
        };
        let bodyUnlock = (delay = 0) => {
            if (bodyLockStatus) {
                const lockPaddingElements = document.querySelectorAll("[data-lp]");
                setTimeout(() => {
                    lockPaddingElements.forEach(lockPaddingElement => {
                        lockPaddingElement.style.paddingRight = "";
                    });
                    document.body.style.paddingRight = "";
                    document.documentElement.classList.remove("lock");
                }, delay);
                bodyLockStatus = false;
                setTimeout(function() {
                    bodyLockStatus = true;
                }, delay);
            }
        };
        let bodyLock = (delay = 0) => {
            if (bodyLockStatus) {
                const lockPaddingElements = document.querySelectorAll("[data-lp]");
                const lockPaddingValue = window.innerWidth - document.body.offsetWidth + "px";
                lockPaddingElements.forEach(lockPaddingElement => {
                    lockPaddingElement.style.paddingRight = lockPaddingValue;
                });
                document.body.style.paddingRight = lockPaddingValue;
                document.documentElement.classList.add("lock");
                bodyLockStatus = false;
                setTimeout(function() {
                    bodyLockStatus = true;
                }, delay);
            }
        };
        window.bodyLock = bodyLock;
        window.bodyUnlock = bodyUnlock;
        window.bodyLockToggle = bodyLockToggle;
        window.bodyLockStatus = bodyLockStatus;
    })();
})();